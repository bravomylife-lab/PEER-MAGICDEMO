<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PEERMUSIC DEMO ê²€í†  ì‹œìŠ¤í…œ</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');

    * {
      font-family: 'Inter', 'Noto Sans KR', sans-serif;
    }

    body {
      background: #0a0a0a;
    }

    .glass {
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .gradient-text {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .drop-zone {
      border: 2px dashed rgba(255,255,255,0.15);
      transition: all 0.3s ease;
    }

    .drop-zone:hover, .drop-zone.drag-over {
      border-color: #667eea;
      background: rgba(102,126,234,0.1);
    }

    .drop-zone.drag-over {
      transform: scale(1.02);
      box-shadow: 0 0 30px rgba(102,126,234,0.3);
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      transition: all 0.3s ease;
    }

    .btn-primary:hover {
      box-shadow: 0 10px 40px rgba(102,126,234,0.3);
      transform: translateY(-2px);
    }

    .btn-secondary {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      transition: all 0.3s ease;
    }

    .btn-secondary:hover {
      background: rgba(255,255,255,0.15);
    }

    .star { cursor: pointer; transition: all 0.2s ease; font-size: 28px; }
    .star:hover { transform: scale(1.2); }
    .star.filled { color: #fbbf24; }
    .star.empty { color: #4b5563; }

    input:focus, textarea:focus, select:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
    }

    .fade-in { animation: fadeIn 0.4s ease-out; }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: #1a1a1a; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: #444; }

    .path-input { font-family: 'Consolas', 'Monaco', monospace; font-size: 11px; }

    .nav-button { transition: all 0.3s ease; }
    .nav-button:hover:not(:disabled) { transform: translateX(var(--direction, 0)); }
    .nav-button:disabled { opacity: 0.3; cursor: not-allowed; }

    .credit-item {
      background: rgba(102,126,234,0.1);
      border: 1px solid rgba(102,126,234,0.3);
    }
  </style>
</head>
<body class="min-h-screen">
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    const FEEDBACK_PRESETS = [
      'ë°ëª¨ì˜ í€„ë¦¬í‹°ê°€ í˜„ì €íˆ ë‚®ìŒ',
      'ì†¡ë¦¬ë“œì™€ ìƒì´í•œ ë°ëª¨',
      'ì•„í‹°ìŠ¤íŠ¸ì™€ ì–´ìš¸ë¦¬ì§€ ì•ŠëŠ” ë°ëª¨',
      'ê³¡ì€ ì¢‹ìœ¼ë‚˜ í•´ë‹¹ ë¦¬ë“œì™€ëŠ” ì–´ìš¸ë¦¬ì§€ ì•ŠëŠ” ë°ëª¨'
    ];

    const SCORES = ['5.0', '4.5', '4.0', '3.5', '3.0', '2.5', '2.0', '1.5', '1.0'];

    // ì´ë©”ì¼/í´ë”ëª… â†’ OPëª… ë§¤í•‘
    const EMAIL_TO_OP = {
      'tos92@naver.com': 'To.S',
      'dctsung@naver.com': 'ES2',
      'kino1229@naver.com': 'YJH',
      'ahlgus2696@naver.com': 'PHK',
      'mildang@naver.com': 'OYB',
      'daslkfj@hanmail.net': 'JGH',
      'coollife07@naver.com': 'Noheul',
      'molesmusik@yahoo.es': 'JM',
      'twobluebirds@shaw.ca': 'RON',
      'bcabox@gmail.com': 'BEN',
      'colin.hembus@eavesmusicgroup.com': 'EavesMusic',
      'atcmusic.ar.0328@gmail.com': 'ART.M',
    };

    // ì‘ê°€ëª… â†’ OPëª… ë§¤í•‘
    const COMPOSER_TO_OP = {
      'onetop': 'OneTop',
      'zeenan': 'OneTop',
      'andy': 'OneTop',
      'ì„œì •ì§„': 'SJJ',
      'to.s': 'To.S',
      'es2': 'ES2',
      'june': 'ES2',
      'kwh': 'ES2',
      'andreas': 'ES2',
      'ì „ê·¼í™”': 'JGH',
      'weeky1': 'JGH',
      'bt': 'JGH',
      'ìœ ì •í›ˆ': 'YJH',
      'ë°•ë¯¼ìš°': 'YJH',
      'ë°•í˜„ê·œ': 'PHK',
      'phk': 'PHK',
      'ì˜¤ì˜ë¹ˆ': 'OYB',
      'noheul': 'Noheul',
      'ë…¸ì„': 'Noheul',
      'ì°¨ë¯¼í˜¸': 'ART.M',
      'adam argyle': 'EavesMusic',
      'phil plested': 'EavesMusic',
      'nick hahn': 'EavesMusic',
      'alexander hahn': 'EavesMusic',
      'ron irving': 'RON',
      'dave pickell': 'RON',
      'corey abrams': 'RON',
      'ben charles': 'BEN',
      'jose manuel': 'JM',
      'domingo morales': 'JM',
      'santiago revilla': 'JM',
      'filo ebid': 'JM',
      'josue vergara': 'JM',
      'pablo peset': 'JM',
    };

    // ì´ë©”ì¼ì—ì„œ OPëª… ì¶”ì¶œ
    const getOPFromEmail = (email) => {
      if (!email) return '';
      const emailLower = email.toLowerCase();
      for (const [key, value] of Object.entries(EMAIL_TO_OP)) {
        if (emailLower.includes(key.toLowerCase().split('@')[0])) {
          return value;
        }
      }
      return '';
    };

    // ì €ì‘ìëª…ì—ì„œ OPëª… ì¶”ì¶œ
    const getOPFromComposer = (composer) => {
      if (!composer) return '';
      const composerLower = composer.toLowerCase();
      for (const [key, value] of Object.entries(COMPOSER_TO_OP)) {
        if (composerLower.includes(key.toLowerCase())) {
          return value;
        }
      }
      return '';
    };

    // í•œê¸€ ì´ˆì„± ì¶”ì¶œ
    const getKoreanInitials = (name) => {
      const CHO_EN = ['G','KK','N','D','DD','R','M','B','BB','S','SS','','J','JJ','CH','K','T','P','H'];
      let initials = '';
      for (let char of name) {
        const code = char.charCodeAt(0) - 44032;
        if (code >= 0 && code <= 11171) initials += CHO_EN[Math.floor(code / 588)];
      }
      return initials || name;
    };

    // ì˜ë¬¸ ì´ë‹ˆì…œ ì¶”ì¶œ
    const getEnglishInitials = (name) => {
      const words = name.split(/[\s,._-]+/).filter(w => w.length > 0);
      if (words.length === 1) return name.substring(0, 3).toUpperCase();
      return words.map(w => w[0].toUpperCase()).join('');
    };

    // í´ë” ê²½ë¡œì—ì„œ ì•„í‹°ìŠ¤íŠ¸ëª… ì¶”ì¶œ
    const extractArtistFromPath = (path) => {
      const patterns = [
        /([ê°€-í£a-zA-Z]+)\s*ì „ì²´\s*DEMO/i,
        /([ê°€-í£a-zA-Z]+)\s*DEMO/i,
      ];
      for (const pattern of patterns) {
        const match = path.match(pattern);
        if (match) return match[1];
      }
      return '';
    };

    // í´ë” ê²½ë¡œì—ì„œ ì´ë©”ì¼ ì¶”ì¶œ
    const extractEmailFromPath = (path) => {
      const emailMatch = path.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
      if (emailMatch) return emailMatch[1];
      if (path.includes('ì„±ê·œí˜¸ ì‘ê°€ë‹˜') || path.includes('ëŒ€í‘œë‹˜')) {
        return 'ëŒ€í‘œë‹˜ ì „ë‹¬ DEMO';
      }
      return '';
    };

    // í´ë” ê²½ë¡œì—ì„œ ì €ì‘ì íŒíŠ¸ ì¶”ì¶œ
    const extractComposerHintFromPath = (path) => {
      const folderMatch = path.match(/([ê°€-í£]+)_[ê°€-í£]+\s*Demo/i);
      if (folderMatch) return folderMatch[1];
      const suffixMatch = path.match(/Demo_([ê°€-í£]+)/i);
      if (suffixMatch) return suffixMatch[1];
      return '';
    };

    // ë‚ ì§œ í¬ë§·
    const formatDate = (date) => {
      if (!date) return new Date().toISOString().split('T')[0];
      const d = new Date(date);
      return d.toISOString().split('T')[0];
    };

    // ========== í•µì‹¬ íŒŒì‹± í•¨ìˆ˜ ==========
    const parseFileName = (filename, folderPath = '') => {
      const nameWithoutExt = filename.replace(/\.(mp3|wav|m4a|flac|aiff)$/i, '');
      let songName = '';
      let composer = '';
      let opName = '';

      const email = extractEmailFromPath(folderPath);
      const composerHint = extractComposerHintFromPath(folderPath);

      // íŒ¨í„´ 1: _Pitched by MCë¡œ ëë‚˜ëŠ” íŒŒì¼
      const pitchedMatch = nameWithoutExt.match(/^(.+?)_([^_]+)_Pitched by MC$/i);
      if (pitchedMatch) {
        songName = pitchedMatch[1].trim();
        opName = pitchedMatch[2].trim();
        composer = composerHint || opName;
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 2: [ì‘ê°€ëª…]_ê³¡ëª…_BPMìˆ«ì_ì¥ë¥´ í˜•ì‹
      const bracketMatch = nameWithoutExt.match(/^\[([^\]]+)\]_(.+?)(?:_BPM\d+)?(?:_[a-zA-Z]+)?$/i);
      if (bracketMatch) {
        composer = bracketMatch[1].trim();
        songName = bracketMatch[2].trim();
        opName = getOPFromComposer(composer) || composer;
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 3: ê³¡ëª…(ì‘ê°€+ì‘ê°€) (BPM,ì¥ë¥´) í˜•ì‹ (ES2 ìŠ¤íƒ€ì¼)
      const es2Match = nameWithoutExt.match(/^(.+?)\(([^)]+)\)\s*\([^)]*\)$/);
      if (es2Match) {
        songName = es2Match[1].trim();
        composer = es2Match[2].replace(/\+/g, ', ').trim();
        opName = getOPFromComposer(composer) || 'ES2';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 4: Weeky1- ê³¡ëª… [Tempoìˆ«ì] ì¥ë¥´ í˜•ì‹
      const weekyMatch = nameWithoutExt.match(/^Weeky1-\s*(.+?)\s*\[Tempo\d+\]/i);
      if (weekyMatch) {
        songName = weekyMatch[1].trim();
        composer = 'ì „ê·¼í™”(Weeky1), BT';
        opName = 'JGH';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 5: ì‘ê°€1,ì‘ê°€2_ê³¡ëª…_BPMìˆ«ì í˜•ì‹ (OneTop ìŠ¤íƒ€ì¼)
      const commaMatch = nameWithoutExt.match(/^([^_]+[,&][^_]+)_(.+?)(?:_BPM\d+)?$/i);
      if (commaMatch) {
        composer = commaMatch[1].replace(/&/g, ', ').trim();
        songName = commaMatch[2].trim();
        opName = getOPFromComposer(composer) || getEnglishInitials(composer.split(/[,&]/)[0].trim());
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 6: ìœ ì •í›ˆ_ë°•ë¯¼ìš°_ë‚˜ë¬´_B-Ab_69 í˜•ì‹ (YJH ìŠ¤íƒ€ì¼)
      const yjhMatch = nameWithoutExt.match(/^([ê°€-í£]+)_([ê°€-í£]+)_(.+?)_[A-G][#b]?[-_][A-Za-z]+_\d+$/i);
      if (yjhMatch) {
        composer = `${yjhMatch[1]}, ${yjhMatch[2]}`;
        songName = yjhMatch[3].trim();
        opName = getOPFromComposer(yjhMatch[1]) || 'YJH';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 7: 01 - Adam Argyle, ... Looks Different í˜•ì‹ (EavesMusic)
      const eavesMatch = nameWithoutExt.match(/^\d+\s*-\s*(.+?)\s*-\s*(.+)$/);
      if (eavesMatch) {
        composer = eavesMatch[1].replace(/\.\.\./g, '').trim();
        songName = eavesMatch[2].trim();
        opName = 'EavesMusic';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 8: ê³¡ëª… - ì‘ê°€ëª… í˜•ì‹ (RON ìŠ¤íƒ€ì¼)
      const dashMatch = nameWithoutExt.match(/^(.+?)\s*[-â€“]\s*([A-Z\s]+)$/);
      if (dashMatch && /^[A-Z\s]+$/.test(dashMatch[2])) {
        songName = dashMatch[1].trim();
        composer = dashMatch[2].trim().split(' ').map(w =>
          w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
        ).join(' ');
        opName = getOPFromComposer(composer) || getOPFromEmail(email) || 'RON';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 9: ì˜¤ì˜ë¹ˆ_ë‚  ë– ë‚˜ì§€ë§ˆ_74_íŒ ë°œë¼ë“œ í˜•ì‹
      const oyoMatch = nameWithoutExt.match(/^([ê°€-í£]+)_(.+?)_\d+_/);
      if (oyoMatch) {
        composer = oyoMatch[1].trim();
        songName = oyoMatch[2].trim();
        opName = getOPFromComposer(composer) || getKoreanInitials(composer);
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 10: ê³¡ëª…_OPëª… í˜•ì‹
      const simpleMatch = nameWithoutExt.match(/^(.+?)_([A-Za-z.]+)$/);
      if (simpleMatch && simpleMatch[2].length <= 10) {
        songName = simpleMatch[1].trim();
        opName = simpleMatch[2].trim();
        composer = composerHint || '';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 11: ë‹¨ìˆœ ê³¡ëª…ë§Œ ìˆëŠ” ê²½ìš° (DREAM ABOUT YOU ë“±)
      if (/^[A-Z\s'Â´]+$/i.test(nameWithoutExt)) {
        songName = nameWithoutExt.trim();
        opName = getOPFromEmail(email) || '';
        composer = '';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 12: ì´ì°½ì„­ Demoê°€ í¬í•¨ëœ íŒŒì¼
      const demoMatch = nameWithoutExt.match(/^(.+?)\s*\(ì´ì°½ì„­\s*Demo\)\s*$/i);
      if (demoMatch) {
        songName = demoMatch[1].trim();
        composer = composerHint || '';
        opName = getOPFromComposer(composerHint) || '';
        return { songName, composer, opName, email };
      }

      // ê¸°ë³¸: íŒŒì¼ëª… ê·¸ëŒ€ë¡œ
      songName = nameWithoutExt
        .replace(/_BPM\d+/gi, '')
        .replace(/_Tempo\d+/gi, '')
        .replace(/\s*\[.*?\]\s*/g, ' ')
        .replace(/\s*\(.*?\)\s*/g, ' ')
        .trim();

      opName = getOPFromEmail(email) || '';
      composer = composerHint || '';

      return { songName, composer, opName, email };
    };

    // ê²½ë¡œ ë¬¸ìì—´ íŒŒì‹±
    const parsePathString = (pathStr) => {
      const paths = pathStr.split('\n').filter(p => p.trim());
      const results = [];

      for (const fullPath of paths) {
        const path = fullPath.trim().replace(/^["']|["']$/g, '');
        if (!path || !/\.(mp3|wav|m4a|flac|aiff)$/i.test(path)) continue;
        if (path.includes('__MACOSX')) continue;

        const separator = path.includes('\\') ? '\\' : '/';
        const parts = path.split(separator);
        const filename = parts[parts.length - 1];
        const folderPath = parts.slice(0, -1).join(separator);

        const parsed = parseFileName(filename, folderPath);

        let uploadDate = new Date().toISOString().split('T')[0];
        const dateMatch = path.match(/\((\d{4}\.\d{2}\.\d{2})\)/);
        if (dateMatch) {
          uploadDate = dateMatch[1].replace(/\./g, '-');
        }

        results.push({
          id: Date.now() + Math.random(),
          ê³¡ëª…: parsed.songName,
          ì €ì‘ì: parsed.composer,
          OPëª…: parsed.opName,
          ì´ë©”ì¼: parsed.email,
          ì›ë³¸ê²½ë¡œ: path,
          ì›ë³¸íŒŒì¼ëª…: filename,
          ì—…ë¡œë“œë‚ ì§œ: uploadDate,
          ì¶”ê°€ì¼ì‹œ: new Date().toISOString()
        });
      }

      return results;
    };

    // í¬ë ˆë”§ í…ìŠ¤íŠ¸ íŒŒì‹±
    const parseCreditText = (creditText) => {
      const credits = {};
      const lines = creditText.split('\n').map(l => l.trim()).filter(l => l);

      let currentSong = null;
      let currentCredits = [];

      for (const line of lines) {
        // ê³¡ëª…ì¸ì§€ í™•ì¸ (ì‘ê³¡, ì‘ì‚¬, í¸ê³¡, writers ë“±ì´ ì—†ëŠ” ì¤„)
        const isCredit = /^(ì‘ê³¡|ì‘ì‚¬|í¸ê³¡|writers?|composer|lyricist|arranger)/i.test(line);

        if (!isCredit && !line.includes(':') && line.length > 0) {
          // ì´ì „ ê³¡ ì €ì¥
          if (currentSong && currentCredits.length > 0) {
            credits[currentSong.toLowerCase()] = currentCredits.join(', ');
          }
          currentSong = line;
          currentCredits = [];
        } else if (currentSong) {
          // í¬ë ˆë”§ ì •ë³´ ì¶”ì¶œ
          let creditInfo = line
            .replace(/^(ì‘ê³¡|ì‘ì‚¬|í¸ê³¡|writers?|composer|lyricist|arranger)\s*/i, '')
            .replace(/[:ï¼š]\s*/, '')
            .trim();
          if (creditInfo) {
            currentCredits.push(creditInfo);
          }
        }
      }

      // ë§ˆì§€ë§‰ ê³¡ ì €ì¥
      if (currentSong && currentCredits.length > 0) {
        credits[currentSong.toLowerCase()] = currentCredits.join(', ');
      }

      return credits;
    };

    function DemoReviewSystem() {
      const [songs, setSongs] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [reviews, setReviews] = useState({});
      const [view, setView] = useState('upload'); // upload, credit, review, list
      const [artistName, setArtistName] = useState('');
      const [searchTerm, setSearchTerm] = useState('');
      const [filterStatus, setFilterStatus] = useState('all');
      const [dragOver, setDragOver] = useState(false);
      const [dragCounter, setDragCounter] = useState(0);
      const [pathInputText, setPathInputText] = useState('');
      const [showPathInput, setShowPathInput] = useState(false);
      const [creditText, setCreditText] = useState('');
      const [pendingSongs, setPendingSongs] = useState([]);
      const [isComposing, setIsComposing] = useState(false);

      const fileInputRef = useRef(null);
      const folderInputRef = useRef(null);
      const creditTextRef = useRef('');

      const STORAGE_KEY = 'peermusic_demo_reviews_v6';
      const SONGS_KEY = 'peermusic_demo_songs_v6';
      const META_KEY = 'peermusic_demo_meta_v6';

      useEffect(() => {
        const savedReviews = localStorage.getItem(STORAGE_KEY);
        const savedSongs = localStorage.getItem(SONGS_KEY);
        const savedMeta = localStorage.getItem(META_KEY);
        if (savedReviews) try { setReviews(JSON.parse(savedReviews)); } catch (e) {}
        if (savedSongs) try { const s = JSON.parse(savedSongs); setSongs(s); if (s.length > 0) setView('review'); } catch (e) {}
        if (savedMeta) try { const m = JSON.parse(savedMeta); setArtistName(m.artistName || ''); } catch (e) {}
      }, []);

      useEffect(() => { if (Object.keys(reviews).length > 0) localStorage.setItem(STORAGE_KEY, JSON.stringify(reviews)); }, [reviews]);
      useEffect(() => { if (songs.length > 0) localStorage.setItem(SONGS_KEY, JSON.stringify(songs)); }, [songs]);
      useEffect(() => { localStorage.setItem(META_KEY, JSON.stringify({ artistName })); }, [artistName]);

      const currentSong = songs[currentIndex] || null;
      const currentReview = currentSong ? (reviews[currentSong.id] || { í”¼ë“œë°±: '', ì¥ë¥´: '', ì ìˆ˜: '', OPëª…: currentSong.OPëª…, ì €ì‘ì: currentSong.ì €ì‘ì }) : null;
      const reviewedCount = useMemo(() => songs.filter(s => reviews[s.id]?.ì ìˆ˜).length, [songs, reviews]);
      const progress = songs.length > 0 ? ((reviewedCount / songs.length) * 100).toFixed(0) : 0;

      const filteredSongs = useMemo(() => {
        return songs.filter(song => {
          const review = reviews[song.id] || {};
          const matchesSearch = song.ê³¡ëª….toLowerCase().includes(searchTerm.toLowerCase()) ||
            song.ì €ì‘ì.toLowerCase().includes(searchTerm.toLowerCase()) ||
            (review.OPëª… || song.OPëª… || '').toLowerCase().includes(searchTerm.toLowerCase());
          if (filterStatus === 'reviewed') return matchesSearch && review?.ì ìˆ˜;
          if (filterStatus === 'pending') return matchesSearch && !review?.ì ìˆ˜;
          if (filterStatus === 'recommended') return matchesSearch && parseFloat(review?.ì ìˆ˜ || 0) >= 4.0;
          return matchesSearch;
        });
      }, [songs, reviews, searchTerm, filterStatus]);

      // í´ë” ì—…ë¡œë“œ ì²˜ë¦¬
      const handleFolderUpload = async (files) => {
        const audioFiles = Array.from(files).filter(f => {
          const isAudio = /\.(mp3|wav|m4a|flac|aiff)$/i.test(f.name);
          const isMacOS = f.webkitRelativePath?.includes('__MACOSX') || f.name.startsWith('._');
          return isAudio && !isMacOS;
        });

        if (audioFiles.length === 0) {
          alert('ìŒì› íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.\n\nì§€ì› í˜•ì‹: MP3, WAV, M4A, FLAC, AIFF');
          return;
        }

        const firstPath = audioFiles[0].webkitRelativePath || '';
        const detectedArtist = extractArtistFromPath(firstPath);
        if (detectedArtist && !artistName) setArtistName(detectedArtist);

        const newSongs = audioFiles.map((file, idx) => {
          const path = file.webkitRelativePath || file.name;
          const parsed = parseFileName(file.name, path);

          return {
            id: Date.now() + idx + Math.random(),
            ê³¡ëª…: parsed.songName,
            ì €ì‘ì: parsed.composer,
            OPëª…: parsed.opName,
            ì´ë©”ì¼: parsed.email,
            ì›ë³¸íŒŒì¼ëª…: file.name,
            ì›ë³¸ê²½ë¡œ: path,
            ì—…ë¡œë“œë‚ ì§œ: formatDate(file.lastModified),
            ì¶”ê°€ì¼ì‹œ: new Date().toISOString()
          };
        });

        // í¬ë ˆë”§ ì…ë ¥ í™”ë©´ìœ¼ë¡œ ì´ë™
        setPendingSongs(newSongs);
        setView('credit');
      };

      // íŒŒì¼ ì„ íƒ ì²˜ë¦¬
      const handleFileSelect = async (files) => {
        const audioFiles = Array.from(files).filter(f =>
          /\.(mp3|wav|m4a|flac|aiff)$/i.test(f.name) && !f.name.startsWith('._')
        );

        if (audioFiles.length === 0) {
          alert('ìŒì› íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.\n\nì§€ì› í˜•ì‹: MP3, WAV, M4A, FLAC, AIFF');
          return;
        }

        const newSongs = audioFiles.map((file, idx) => {
          const parsed = parseFileName(file.name, '');

          return {
            id: Date.now() + idx + Math.random(),
            ê³¡ëª…: parsed.songName,
            ì €ì‘ì: parsed.composer,
            OPëª…: parsed.opName,
            ì´ë©”ì¼: parsed.email,
            ì›ë³¸íŒŒì¼ëª…: file.name,
            ì›ë³¸ê²½ë¡œ: file.name,
            ì—…ë¡œë“œë‚ ì§œ: formatDate(file.lastModified),
            ì¶”ê°€ì¼ì‹œ: new Date().toISOString()
          };
        });

        setPendingSongs(newSongs);
        setView('credit');
      };

      // ê²½ë¡œ ì…ë ¥ ì²˜ë¦¬
      const handlePathInput = () => {
        if (!pathInputText.trim()) { alert('ê²½ë¡œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.'); return; }

        const newSongs = parsePathString(pathInputText);
        if (newSongs.length === 0) {
          alert('ìœ íš¨í•œ ìŒì› íŒŒì¼ ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤.');
          return;
        }

        const firstPath = pathInputText;
        const detectedArtist = extractArtistFromPath(firstPath);
        if (detectedArtist && !artistName) setArtistName(detectedArtist);

        setPendingSongs(newSongs);
        setPathInputText('');
        setShowPathInput(false);
        setView('credit');
      };

      // í¬ë ˆë”§ ì ìš© ë° ê²€í†  ì‹œì‘
      const applyCreditsAndStart = () => {
        let updatedSongs = [...pendingSongs];
        const textToUse = creditTextRef.current || creditText;

        if (textToUse.trim()) {
          const credits = parseCreditText(textToUse);

          updatedSongs = pendingSongs.map(song => {
            const songNameLower = song.ê³¡ëª….toLowerCase();
            const matchedCredit = credits[songNameLower];

            if (matchedCredit) {
              return {
                ...song,
                ì €ì‘ì: matchedCredit
              };
            }
            return song;
          });
        }

        setSongs(prev => [...prev, ...updatedSongs]);
        setPendingSongs([]);
        setCreditText('');
        creditTextRef.current = '';
        setView('review');
        alert(`${updatedSongs.length}ê³¡ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      };

      // í¬ë ˆë”§ ì—†ì´ ì§„í–‰
      const skipCredits = () => {
        setSongs(prev => [...prev, ...pendingSongs]);
        setPendingSongs([]);
        setCreditText('');
        creditTextRef.current = '';
        setView('review');
        alert(`${pendingSongs.length}ê³¡ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      };

      // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì²˜ë¦¬ (ì•ˆì •í™”)
      const handleDragEnter = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDragCounter(prev => prev + 1);
        setDragOver(true);
      }, []);

      const handleDragLeave = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDragCounter(prev => {
          const newCount = prev - 1;
          if (newCount <= 0) {
            setDragOver(false);
            return 0;
          }
          return newCount;
        });
      }, []);

      const handleDragOver = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = 'copy';
      }, []);

      const handleDrop = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDragOver(false);
        setDragCounter(0);

        const items = e.dataTransfer.items;
        const files = e.dataTransfer.files;

        console.log('Drop detected:', { items: items?.length, files: files?.length });

        if (items && items.length > 0) {
          const allFiles = [];
          let pendingEntries = 0;
          let hasStarted = false;
          let timeoutId = null;

          const processComplete = () => {
            if (timeoutId) clearTimeout(timeoutId);
            if (allFiles.length > 0 && !hasStarted) {
              hasStarted = true;
              console.log('Processing', allFiles.length, 'files');
              handleFolderUpload(allFiles);
            } else if (allFiles.length === 0 && !hasStarted) {
              hasStarted = true;
              alert('ìŒì› íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.\n\nì§€ì› í˜•ì‹: MP3, WAV, M4A, FLAC, AIFF');
            }
          };

          // íƒ€ì„ì•„ì›ƒ ì¶”ê°€ - 3ì´ˆ í›„ ê°•ì œ ì²˜ë¦¬
          timeoutId = setTimeout(() => {
            console.log('Timeout - processing with', allFiles.length, 'files');
            processComplete();
          }, 3000);

          const readEntry = (entry, path = '') => {
            if (!entry) return;

            if (entry.isFile) {
              pendingEntries++;
              entry.file(file => {
                try {
                  Object.defineProperty(file, 'webkitRelativePath', {
                    value: path + file.name,
                    writable: false,
                    configurable: true
                  });
                } catch (err) {
                  // ì´ë¯¸ ì„¤ì •ëœ ê²½ìš° ë¬´ì‹œ
                }
                allFiles.push(file);
                pendingEntries--;
                if (pendingEntries === 0) {
                  processComplete();
                }
              }, (err) => {
                console.error('File read error:', err);
                pendingEntries--;
                if (pendingEntries === 0) {
                  processComplete();
                }
              });
            } else if (entry.isDirectory) {
              pendingEntries++;
              const reader = entry.createReader();

              const readAllEntries = (allEntries = []) => {
                reader.readEntries(entries => {
                  if (entries.length > 0) {
                    allEntries = allEntries.concat(Array.from(entries));
                    readAllEntries(allEntries);
                  } else {
                    pendingEntries--;
                    allEntries.forEach(e => readEntry(e, path + entry.name + '/'));
                    if (pendingEntries === 0) {
                      processComplete();
                    }
                  }
                }, (err) => {
                  console.error('Directory read error:', err);
                  pendingEntries--;
                  if (pendingEntries === 0) {
                    processComplete();
                  }
                });
              };

              readAllEntries();
            }
          };

          let hasEntry = false;
          for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.kind === 'file') {
              const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
              if (entry) {
                hasEntry = true;
                console.log('Found entry:', entry.name, entry.isDirectory ? '(directory)' : '(file)');
                readEntry(entry);
              }
            }
          }

          if (!hasEntry && files.length > 0) {
            console.log('No entries, using files directly');
            if (timeoutId) clearTimeout(timeoutId);
            handleFileSelect(files);
          }
        } else if (files && files.length > 0) {
          console.log('Using files directly:', files.length);
          handleFileSelect(files);
        }
      }, []);

      const handleUpdate = (field, value) => {
        if (!currentSong) return;
        setReviews(prev => ({ ...prev, [currentSong.id]: { ...currentReview, [field]: value } }));
      };

      const goNext = () => { if (currentIndex < songs.length - 1) setCurrentIndex(currentIndex + 1); };
      const goPrev = () => { if (currentIndex > 0) setCurrentIndex(currentIndex - 1); };
      const goToSong = (idx) => { setCurrentIndex(idx); setView('review'); };
      const deleteSong = (id) => {
        if (confirm('ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
          setSongs(prev => prev.filter(s => s.id !== id));
          setReviews(prev => { const n = { ...prev }; delete n[id]; return n; });
          if (currentIndex >= songs.length - 1) setCurrentIndex(Math.max(0, songs.length - 2));
        }
      };

      // CSV ë‹¤ìš´ë¡œë“œ
      const downloadCSV = () => {
        try {
          const allData = songs.map(song => {
            const review = reviews[song.id] || {};
            const opName = review.OPëª… || song.OPëª… || '';
            const composerInfo = review.ì €ì‘ì || song.ì €ì‘ì || '';

            return {
              'ìŒì›ì—…ë¡œë“œë‚ ì§œ': song.ì—…ë¡œë“œë‚ ì§œ || new Date().toISOString().split('T')[0],
              'ì €ì‘ì ì •ë³´': composerInfo,
              'ì›ë³¸ ë°ëª¨ ì‘í’ˆëª…': song.ê³¡ëª…,
              'PITCHING ë°ëª¨': `${song.ê³¡ëª…}_${opName}_Pitched by MC`,
              'OPëª… / ì‘ê°€ëª…': opName,
              'Genre': review.ì¥ë¥´ || '',
              'Tag(Note)': review.í”¼ë“œë°± || '',
              'Note(ì„ í˜¸ë„)': review.ì ìˆ˜ ? `${review.ì ìˆ˜}/5` : '',
              'ì´ë©”ì¼ ì£¼ì†Œ': song.ì´ë©”ì¼ || '',
              'í”¼ì¹­ ì•„í‹°ìŠ¤íŠ¸': artistName
            };
          });

          const convertToCSV = (data) => {
            if (data.length === 0) return '';
            const headers = Object.keys(data[0]);
            const csvRows = [headers.join(',')];
            for (const row of data) {
              const values = headers.map(h => {
                const v = String(row[h] || '');
                return (v.includes(',') || v.includes('"') || v.includes('\n')) ? `"${v.replace(/"/g, '""')}"` : v;
              });
              csvRows.push(values.join(','));
            }
            return csvRows.join('\n');
          };

          const BOM = '\uFEFF';
          const today = new Date().toISOString().split('T')[0].replace(/-/g, '.');

          const blob = new Blob([BOM + convertToCSV(allData)], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = `${artistName || 'DEMO'}_ì „ì²´DEMO_${today}.csv`;
          link.click();

          const recommended = allData.filter((_, i) => parseFloat(reviews[songs[i].id]?.ì ìˆ˜ || 0) >= 4.0);
          if (recommended.length > 0) {
            setTimeout(() => {
              const blob2 = new Blob([BOM + convertToCSV(recommended)], { type: 'text/csv;charset=utf-8;' });
              const link2 = document.createElement('a');
              link2.href = URL.createObjectURL(blob2);
              link2.download = `${artistName || 'DEMO'}_ì¶”ì²œDEMO_${today}.csv`;
              link2.click();
            }, 500);
          }

          alert(`ë‹¤ìš´ë¡œë“œ ì™„ë£Œ\nì „ì²´: ${allData.length}ê³¡ | ì¶”ì²œ: ${recommended.length}ê³¡`);
        } catch (error) { alert('ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: ' + error.message); }
      };

      const resetAll = () => {
        if (confirm('ëª¨ë“  ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
          setSongs([]); setReviews({}); setCurrentIndex(0); setView('upload'); setArtistName('');
          localStorage.removeItem(STORAGE_KEY); localStorage.removeItem(SONGS_KEY);
        }
      };

      const getScoreColor = (score) => {
        const colors = { '5.0': 'from-emerald-500 to-emerald-600', '4.5': 'from-blue-500 to-blue-600', '4.0': 'from-cyan-500 to-cyan-600', '3.5': 'from-purple-500 to-purple-600', '3.0': 'from-amber-500 to-amber-600', '2.5': 'from-orange-500 to-orange-600', '2.0': 'from-red-500 to-red-600', '1.5': 'from-gray-500 to-gray-600', '1.0': 'from-gray-400 to-gray-500' };
        return colors[score] || 'from-gray-300 to-gray-400';
      };

      const StarRating = ({ value, onChange }) => {
        const [hover, setHover] = useState(0);
        return (
          <div className="flex gap-1 items-center">
            {[1,2,3,4,5].map(i => (
              <span key={i} className={`star ${(hover || parseFloat(value) || 0) >= i ? 'filled' : 'empty'}`}
                onMouseEnter={() => setHover(i)} onMouseLeave={() => setHover(0)}
                onClick={() => onChange(i + '.0')}>{(hover || parseFloat(value) || 0) >= i ? 'â˜…' : 'â˜†'}</span>
            ))}
            {value && <span className="ml-2 text-lg font-bold text-white">{value}</span>}
          </div>
        );
      };

      // ì—…ë¡œë“œ í™”ë©´
      const UploadView = () => (
        <div className="min-h-screen flex items-center justify-center p-6 fade-in">
          <div className="w-full max-w-2xl">
            <div className="text-center mb-12">
              <h1 className="text-5xl font-bold gradient-text mb-2">PEERMUSIC</h1>
              <p className="text-gray-500 text-lg">DEMO Review System</p>
            </div>

            <div
              className={`drop-zone rounded-3xl p-16 text-center cursor-pointer mb-4 ${dragOver ? 'drag-over' : ''}`}
              onClick={() => folderInputRef.current?.click()}
              onDragEnter={handleDragEnter}
              onDragOver={handleDragOver}
              onDragLeave={handleDragLeave}
              onDrop={handleDrop}
            >
              <div className="text-6xl mb-6 opacity-60">{dragOver ? 'ğŸ“¥' : 'ğŸ“‚'}</div>
              <h2 className="text-2xl font-semibold text-white mb-3">
                {dragOver ? 'ì—¬ê¸°ì— ë†“ìœ¼ì„¸ìš”!' : 'í´ë”ë¥¼ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­'}
              </h2>
              <p className="text-gray-500">MP3, WAV, M4A, FLAC, AIFF</p>
              <input
                ref={folderInputRef}
                type="file"
                webkitdirectory=""
                directory=""
                multiple
                onChange={(e) => e.target.files && handleFolderUpload(e.target.files)}
                className="hidden"
              />
            </div>

            <div className="flex gap-4 mb-4">
              <button
                onClick={() => fileInputRef.current?.click()}
                className="flex-1 py-4 rounded-2xl text-gray-400 hover:text-white border border-gray-800 hover:border-gray-700 transition-all"
              >
                ğŸ“„ íŒŒì¼ ì§ì ‘ ì„ íƒ
              </button>
              <button
                onClick={() => setShowPathInput(!showPathInput)}
                className="flex-1 py-4 rounded-2xl text-gray-400 hover:text-white border border-gray-800 hover:border-gray-700 transition-all"
              >
                ğŸ“‹ ê²½ë¡œ ë¶™ì—¬ë„£ê¸°
              </button>
              <input
                ref={fileInputRef}
                type="file"
                accept=".mp3,.wav,.m4a,.flac,.aiff"
                multiple
                onChange={(e) => e.target.files && handleFileSelect(e.target.files)}
                className="hidden"
              />
            </div>

            {showPathInput && (
              <div className="glass rounded-2xl p-6 mb-4 fade-in">
                <textarea
                  value={pathInputText}
                  onChange={(e) => setPathInputText(e.target.value)}
                  className="path-input w-full h-40 bg-black/50 text-gray-300 px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500 resize-none mb-4"
                  placeholder={`íŒŒì¼ ê²½ë¡œë¥¼ ë¶™ì—¬ë„£ê¸° (í•œ ì¤„ì— í•˜ë‚˜ì”©)...`}
                />
                <button onClick={handlePathInput} className="w-full btn-primary py-3 rounded-xl text-white font-medium">
                  ê²½ë¡œ ë¶„ì„ ë° ì¶”ê°€
                </button>
              </div>
            )}

            {songs.length > 0 && (
              <div className="glass rounded-2xl p-6 text-center mb-4">
                <p className="text-gray-400 mb-3">ì €ì¥ëœ ë°ì´í„°: <span className="text-white font-bold">{songs.length}ê³¡</span> ({reviewedCount}ê³¡ ì™„ë£Œ)</p>
                <button onClick={() => setView('review')} className="btn-primary px-8 py-3 rounded-xl text-white font-medium">
                  ì´ì–´ì„œ ê²€í† í•˜ê¸° â†’
                </button>
              </div>
            )}
          </div>
        </div>
      );

      // í¬ë ˆë”§ ì…ë ¥ í™”ë©´ (ë³„ë„ ì»´í¬ë„ŒíŠ¸ë¡œ ë¶„ë¦¬í•˜ì—¬ ë¦¬ë Œë”ë§ ë°©ì§€)
      const CreditTextArea = React.memo(({ onTextChange }) => {
        const textareaRef = useRef(null);

        useEffect(() => {
          if (textareaRef.current) {
            textareaRef.current.value = '';
          }
        }, []);

        const handleInput = (e) => {
          const value = e.target.value;
          creditTextRef.current = value;
          if (onTextChange) onTextChange(value);
        };

        return (
          <textarea
            ref={textareaRef}
            defaultValue=""
            onInput={handleInput}
            onBlur={(e) => { creditTextRef.current = e.target.value; }}
            className="w-full h-64 bg-black/50 text-gray-300 px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500 resize-none mb-4 font-mono text-sm"
            placeholder={`ì˜ˆì‹œ:

ê±°ê¸°ì„œ ê±°ê¸°
ì‘ê³¡ ì „ê·¼í™”
ì‘ì‚¬ ì „ê·¼í™”
í¸ê³¡ ì •ì§„ìš±

Hamburger
writers CC, Ron, JJ

ë„ˆì™€ì˜ ë°¤
ì‘ê³¡ ì „ê·¼í™”(Weeky1), BT
ì‘ì‚¬ ì „ê·¼í™”`}
          />
        );
      });

      const CreditView = () => (
        <div className="min-h-screen flex items-center justify-center p-6 fade-in">
          <div className="w-full max-w-3xl">
            <div className="text-center mb-8">
              <h1 className="text-3xl font-bold text-white mb-2">í¬ë ˆë”§ ì •ë³´ ì…ë ¥</h1>
              <p className="text-gray-500">ì—…ë¡œë“œëœ {pendingSongs.length}ê³¡ì˜ ì¶”ê°€ ì €ì‘ì ì •ë³´ë¥¼ ì…ë ¥í•˜ì„¸ìš”</p>
            </div>

            {/* ì—…ë¡œë“œëœ ê³¡ ëª©ë¡ */}
            <div className="glass rounded-2xl p-4 mb-6 max-h-48 overflow-y-auto">
              <h3 className="text-sm font-medium text-gray-400 mb-3">ì—…ë¡œë“œëœ ê³¡ ëª©ë¡</h3>
              <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                {pendingSongs.map((song, idx) => (
                  <div key={idx} className="credit-item px-3 py-2 rounded-lg text-sm">
                    <span className="text-white">{song.ê³¡ëª…}</span>
                    {song.ì €ì‘ì && <span className="text-gray-500 text-xs block">{song.ì €ì‘ì}</span>}
                  </div>
                ))}
              </div>
            </div>

            {/* í¬ë ˆë”§ ì…ë ¥ */}
            <div className="glass rounded-2xl p-6 mb-6">
              <h3 className="text-white font-medium mb-3">ğŸ“ ì¶”ê°€ í¬ë ˆë”§ ì •ë³´ (ì„ íƒì‚¬í•­)</h3>
              <p className="text-gray-500 text-sm mb-4">
                ê³¡ëª…ì„ ë¨¼ì € ì“°ê³ , ê·¸ ì•„ë˜ì— ì‘ê³¡/ì‘ì‚¬/í¸ê³¡ ë˜ëŠ” writers ì •ë³´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.
              </p>
              <CreditTextArea onTextChange={(v) => setCreditText(v)} />
            </div>

            {/* ë²„íŠ¼ */}
            <div className="flex gap-4">
              <button
                onClick={() => { setPendingSongs([]); setCreditText(''); creditTextRef.current = ''; setView('upload'); }}
                className="flex-1 btn-secondary py-4 rounded-xl text-gray-300 font-medium"
              >
                â† ì·¨ì†Œ
              </button>
              <button
                onClick={skipCredits}
                className="flex-1 btn-secondary py-4 rounded-xl text-gray-300 font-medium"
              >
                ê±´ë„ˆë›°ê¸°
              </button>
              <button
                onClick={applyCreditsAndStart}
                className="flex-1 btn-primary py-4 rounded-xl text-white font-medium"
              >
                ì ìš© ë° ê²€í†  ì‹œì‘ â†’
              </button>
            </div>
          </div>
        </div>
      );

      // ê²€í†  í™”ë©´
      const ReviewView = () => {
        if (!currentSong) return (
          <div className="min-h-screen flex items-center justify-center">
            <div className="text-center">
              <p className="text-xl text-gray-500 mb-4">ê²€í† í•  ê³¡ì´ ì—†ìŠµë‹ˆë‹¤</p>
              <button onClick={() => setView('upload')} className="btn-primary px-6 py-3 rounded-xl text-white">ê³¡ ì¶”ê°€</button>
            </div>
          </div>
        );

        return (
          <div className="max-w-5xl mx-auto p-4 md:p-6 fade-in">
            <div className="glass rounded-2xl p-4 mb-4">
              <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
                <div className="flex items-center gap-4">
                  <button onClick={() => setView('upload')} className="p-2 hover:bg-white/10 rounded-lg text-gray-400 hover:text-white">ğŸ </button>
                  <div>
                    <input
                      type="text"
                      value={artistName}
                      onChange={(e) => setArtistName(e.target.value)}
                      className="text-xl font-bold text-white bg-transparent border-b border-transparent hover:border-gray-600 focus:border-indigo-500 outline-none"
                      placeholder="ì•„í‹°ìŠ¤íŠ¸ëª… ì…ë ¥"
                    />
                    <p className="text-sm text-gray-500">{songs.length}ê³¡</p>
                  </div>
                </div>
                <div className="flex items-center gap-3">
                  <button onClick={() => setView('list')} className="px-4 py-2 rounded-lg text-gray-400 hover:text-white hover:bg-white/10">ğŸ“‹ ëª©ë¡</button>
                  <button onClick={downloadCSV} className="btn-primary px-4 py-2 rounded-lg text-white font-medium">ğŸ“¥ CSV</button>
                </div>
              </div>
              <div className="mt-4">
                <div className="flex justify-between text-sm mb-1">
                  <span className="text-gray-500">ì§„í–‰ë¥ </span>
                  <span className="text-white font-medium">{reviewedCount} / {songs.length} ({progress}%)</span>
                </div>
                <div className="h-1.5 bg-gray-800 rounded-full overflow-hidden">
                  <div className="h-full bg-gradient-to-r from-indigo-500 to-purple-500 transition-all" style={{ width: `${progress}%` }} />
                </div>
              </div>
            </div>

            <div className="flex gap-4 items-stretch">
              <button onClick={goPrev} disabled={currentIndex === 0}
                className="nav-button hidden md:flex items-center justify-center w-14 glass rounded-2xl hover:bg-white/5 text-gray-400 hover:text-white"
                style={{ '--direction': '-5px' }}><span className="text-2xl">â†</span></button>

              <div className="flex-1 glass rounded-3xl p-6 md:p-8">
                <div className="text-center mb-6">
                  <span className="inline-block px-3 py-1 bg-indigo-500/20 text-indigo-400 rounded-full text-sm font-medium mb-3">#{currentIndex + 1}</span>
                  <h2 className="text-3xl md:text-4xl font-bold text-white mb-1">{currentSong.ê³¡ëª…}</h2>
                  <p className="text-gray-500 text-sm">{currentSong.ì—…ë¡œë“œë‚ ì§œ} | {currentSong.ì›ë³¸íŒŒì¼ëª…}</p>
                </div>

                <div className="space-y-5">
                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-2">ì €ì‘ì ì •ë³´</label>
                    <input type="text" value={currentReview.ì €ì‘ì ?? currentSong.ì €ì‘ì ?? ''}
                      onChange={(e) => handleUpdate('ì €ì‘ì', e.target.value)}
                      className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                      placeholder="ì˜ˆ: OneTop, Zeenan" />
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-400 mb-2">OPëª… / ì‘ê°€ëª…</label>
                      <input type="text" value={currentReview.OPëª… ?? currentSong.OPëª… ?? ''}
                        onChange={(e) => handleUpdate('OPëª…', e.target.value)}
                        className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                        placeholder="ì˜ˆ: OneTop, SJJ" />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-400 mb-2">ì´ë©”ì¼</label>
                      <input type="text" value={currentSong.ì´ë©”ì¼ || ''}
                        className="w-full bg-black/30 text-gray-500 px-4 py-3 rounded-xl border border-gray-800"
                        readOnly />
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-3 text-center">ì„ í˜¸ë„</label>
                    <div className="flex justify-center"><StarRating value={currentReview.ì ìˆ˜} onChange={(v) => handleUpdate('ì ìˆ˜', v)} /></div>
                    <div className="flex flex-wrap justify-center gap-2 mt-3">
                      {SCORES.map(s => (
                        <button key={s} onClick={() => handleUpdate('ì ìˆ˜', s)}
                          className={`px-3 py-1 rounded-lg text-sm font-medium transition-all ${currentReview.ì ìˆ˜ === s ? `bg-gradient-to-r ${getScoreColor(s)} text-white` : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>{s}</button>
                      ))}
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-2">Genre</label>
                    <input type="text" value={currentReview.ì¥ë¥´ || ''} onChange={(e) => handleUpdate('ì¥ë¥´', e.target.value)}
                      className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                      placeholder="ì˜ˆ: ë°œë¼ë“œ, ì–´ì¿ ìŠ¤í‹± íŒ, POP BALLAD" />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-2">Tag(Note)</label>
                    <select value={FEEDBACK_PRESETS.includes(currentReview.í”¼ë“œë°±) ? currentReview.í”¼ë“œë°± : ''}
                      onChange={(e) => e.target.value && handleUpdate('í”¼ë“œë°±', e.target.value)}
                      className="w-full bg-black/30 text-gray-300 px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500 mb-2">
                      <option value="">í”„ë¦¬ì…‹ ì„ íƒ</option>
                      {FEEDBACK_PRESETS.map(p => <option key={p} value={p}>{p}</option>)}
                    </select>
                    <textarea value={currentReview.í”¼ë“œë°± || ''} onChange={(e) => handleUpdate('í”¼ë“œë°±', e.target.value)}
                      className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500 resize-none" rows={2}
                      placeholder="í”¼ë“œë°± ì…ë ¥..." />
                  </div>

                  {parseFloat(currentReview.ì ìˆ˜ || 0) >= 4.0 && (
                    <div className="text-center">
                      <span className="inline-block px-4 py-2 bg-gradient-to-r from-rose-500 to-pink-500 text-white rounded-xl font-bold">â¤ï¸ ì¶”ì²œê³¡</span>
                    </div>
                  )}
                </div>

                <div className="flex md:hidden gap-3 mt-6">
                  <button onClick={goPrev} disabled={currentIndex === 0} className="flex-1 py-3 bg-gray-800 rounded-xl text-white disabled:opacity-40">â† ì´ì „</button>
                  <button onClick={goNext} disabled={currentIndex === songs.length - 1} className="flex-1 py-3 btn-primary rounded-xl text-white disabled:opacity-40">ë‹¤ìŒ â†’</button>
                </div>
              </div>

              <button onClick={goNext} disabled={currentIndex === songs.length - 1}
                className="nav-button hidden md:flex items-center justify-center w-14 glass rounded-2xl hover:bg-white/5 text-gray-400 hover:text-white"
                style={{ '--direction': '5px' }}><span className="text-2xl">â†’</span></button>
            </div>

            <div className="mt-4 glass rounded-xl p-4">
              <div className="flex items-center justify-between">
                <button onClick={() => setCurrentIndex(0)} className="text-sm text-gray-500 hover:text-white">â®ï¸</button>
                <div className="flex items-center gap-2">
                  <input type="number" min={1} max={songs.length} value={currentIndex + 1}
                    onChange={(e) => { const i = parseInt(e.target.value) - 1; if (i >= 0 && i < songs.length) setCurrentIndex(i); }}
                    className="w-14 bg-black/30 text-white text-center px-2 py-1 rounded-lg border border-gray-800" />
                  <span className="text-gray-500">/ {songs.length}</span>
                </div>
                <button onClick={() => setCurrentIndex(songs.length - 1)} className="text-sm text-gray-500 hover:text-white">â­ï¸</button>
              </div>
            </div>
          </div>
        );
      };

      // ëª©ë¡ í™”ë©´
      const ListView = () => (
        <div className="max-w-6xl mx-auto p-4 md:p-6 fade-in">
          <div className="glass rounded-2xl p-4 mb-4">
            <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
              <div className="flex items-center gap-4">
                <button onClick={() => setView('review')} className="text-gray-400 hover:text-white">â† ê²€í† </button>
                <h1 className="text-xl font-bold text-white">ì „ì²´ ëª©ë¡ ({filteredSongs.length}ê³¡)</h1>
              </div>
              <div className="flex gap-3">
                <button onClick={downloadCSV} className="btn-primary px-4 py-2 rounded-lg text-white font-medium">ğŸ“¥ CSV</button>
                <button onClick={resetAll} className="px-4 py-2 rounded-lg bg-red-500/20 text-red-400 hover:bg-red-500/30">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
              </div>
            </div>
          </div>

          <div className="glass rounded-2xl p-4 mb-4">
            <div className="flex flex-col md:flex-row gap-4">
              <input type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)}
                className="flex-1 bg-black/30 text-white px-4 py-2 rounded-xl border border-gray-800 focus:border-indigo-500"
                placeholder="ğŸ” ê²€ìƒ‰..." />
              <div className="flex gap-2">
                {[{ k: 'all', l: 'ì „ì²´' }, { k: 'reviewed', l: 'ì™„ë£Œ' }, { k: 'pending', l: 'ë¯¸ê²€í† ' }, { k: 'recommended', l: 'ì¶”ì²œ' }].map(({ k, l }) => (
                  <button key={k} onClick={() => setFilterStatus(k)}
                    className={`px-4 py-2 rounded-xl font-medium ${filterStatus === k ? 'btn-primary text-white' : 'bg-gray-800 text-gray-400'}`}>{l}</button>
                ))}
              </div>
            </div>
          </div>

          <div className="glass rounded-2xl overflow-hidden">
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead className="bg-black/30">
                  <tr>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">#</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">ê³¡ëª…</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">ì €ì‘ì</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">OPëª…</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">ë‚ ì§œ</th>
                    <th className="px-4 py-3 text-center text-sm font-medium text-gray-400">ì ìˆ˜</th>
                    <th className="px-4 py-3 text-center text-sm font-medium text-gray-400"></th>
                  </tr>
                </thead>
                <tbody>
                  {filteredSongs.map(song => {
                    const review = reviews[song.id] || {};
                    const idx = songs.findIndex(s => s.id === song.id);
                    const isRec = parseFloat(review.ì ìˆ˜ || 0) >= 4.0;
                    return (
                      <tr key={song.id} className="border-t border-gray-800 hover:bg-white/5">
                        <td className="px-4 py-3 text-sm text-gray-500">{idx + 1}</td>
                        <td className="px-4 py-3">
                          <button onClick={() => goToSong(idx)} className="text-indigo-400 hover:underline">{song.ê³¡ëª…}</button>
                          {isRec && <span className="ml-2">â¤ï¸</span>}
                        </td>
                        <td className="px-4 py-3 text-sm text-gray-400">{review.ì €ì‘ì || song.ì €ì‘ì || '-'}</td>
                        <td className="px-4 py-3 text-sm text-gray-400">{review.OPëª… || song.OPëª… || '-'}</td>
                        <td className="px-4 py-3 text-sm text-gray-500">{song.ì—…ë¡œë“œë‚ ì§œ}</td>
                        <td className="px-4 py-3 text-center">
                          {review.ì ìˆ˜ && <span className={`px-2 py-1 rounded-full text-xs font-bold text-white bg-gradient-to-r ${getScoreColor(review.ì ìˆ˜)}`}>{review.ì ìˆ˜}</span>}
                        </td>
                        <td className="px-4 py-3 text-center">
                          <button onClick={() => deleteSong(song.id)} className="text-red-400 hover:text-red-300">ğŸ—‘ï¸</button>
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>

          <div className="mt-4 grid grid-cols-4 gap-4">
            {[{ n: songs.length, l: 'ì „ì²´', c: 'text-indigo-400' }, { n: reviewedCount, l: 'ì™„ë£Œ', c: 'text-emerald-400' },
              { n: songs.length - reviewedCount, l: 'ë¯¸ê²€í† ', c: 'text-amber-400' },
              { n: songs.filter(s => parseFloat(reviews[s.id]?.ì ìˆ˜ || 0) >= 4.0).length, l: 'ì¶”ì²œ', c: 'text-rose-400' }
            ].map(({ n, l, c }) => (
              <div key={l} className="glass rounded-xl p-4 text-center">
                <div className={`text-2xl font-bold ${c}`}>{n}</div>
                <div className="text-sm text-gray-500">{l}</div>
              </div>
            ))}
          </div>
        </div>
      );

      return (
        <div className="min-h-screen">
          {view === 'upload' && <UploadView />}
          {view === 'credit' && <CreditView />}
          {view === 'review' && <ReviewView />}
          {view === 'list' && <ListView />}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<DemoReviewSystem />);
  </script>
</body>
</html>
