<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PEERMUSIC DEMO 검토 시스템</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');

    * {
      font-family: 'Inter', 'Noto Sans KR', sans-serif;
    }

    body {
      background: #0a0a0a;
    }

    .glass {
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .gradient-text {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .upload-zone {
      border: 2px dashed rgba(255,255,255,0.15);
      transition: all 0.3s ease;
    }

    .upload-zone:hover {
      border-color: #667eea;
      background: rgba(102,126,234,0.1);
      transform: scale(1.01);
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      transition: all 0.3s ease;
    }

    .btn-primary:hover {
      box-shadow: 0 10px 40px rgba(102,126,234,0.3);
      transform: translateY(-2px);
    }

    .btn-secondary {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      transition: all 0.3s ease;
    }

    .btn-secondary:hover {
      background: rgba(255,255,255,0.15);
    }

    .star { cursor: pointer; transition: all 0.2s ease; font-size: 28px; }
    .star:hover { transform: scale(1.2); }
    .star.filled { color: #fbbf24; }
    .star.empty { color: #4b5563; }

    input:focus, textarea:focus, select:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
    }

    .fade-in { animation: fadeIn 0.4s ease-out; }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: #1a1a1a; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: #444; }

    .nav-button { transition: all 0.3s ease; }
    .nav-button:hover:not(:disabled) { transform: translateX(var(--direction, 0)); }
    .nav-button:disabled { opacity: 0.3; cursor: not-allowed; }

    .credit-item {
      background: rgba(102,126,234,0.1);
      border: 1px solid rgba(102,126,234,0.3);
    }
  </style>
</head>
<body class="min-h-screen">
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    const FEEDBACK_PRESETS = [
      // 긍정적 피드백
      '송리드와 부합하며 에너지가 있는 여자 팝곡',
      '송리드와 부합하며 에너지가 있는 남자 팝곡',
      '전체적인 밸런스가 매우 좋은 곡',
      'Aggressive한 남성스타일',
      '걸크러쉬 여성 스타일',
      // 중립적 피드백
      '전반적으로 평이한 데모',
      // 부정적 피드백
      '데모의 퀄리티가 현저히 낮음',
      '송리드와 상이한 데모',
      '아티스트와 어울리지 않는 데모',
      '곡은 좋으나 해당 리드와는 어울리지 않는 데모',
      '트렌디에서 떨어지는 데모'
    ];

    const SCORES = ['5.0', '4.5', '4.0', '3.5', '3.0', '2.5', '2.0', '1.5', '1.0'];

    // 장르 프리셋 목록
    const GENRE_PRESETS = [
      'Pop', 'K-Pop', 'J-Pop', 'J-Rock', 'House', 'Easy Listening', 'Urban', 'Synth Pop',
      'Acoustic', 'Ballad', 'K-Ballad', 'R&B', 'Hip-Hop', 'Rock',
      'Dance', 'EDM', 'Electronic', 'Tropical', 'Trap',
      'Jazz', 'Soul', 'Funk', 'Disco', 'Reggae', 'Country',
      'Folk', 'Alternative', 'Indie',
      'City Pop', 'Future Bass', 'Dubstep',
      'Chill', 'Afrobeat', 'Latin', 'Reggaeton',
      'Retro', 'Hyper', 'Mixx Pop', 'Garage', '2Step', 'OST',
      "2000's", 'Band'
    ];

    // 장르 키워드 목록 (자동 분류용)
    const GENRE_KEYWORDS = [
      // 영문 장르
      'House', 'Hiphop', 'Hip-Hop', 'Hip Hop', 'Pop', 'Rock', 'Ballad', 'R&B', 'RnB',
      'Dance', 'EDM', 'Electronic', 'Jazz', 'Soul', 'Funk', 'Disco', 'Reggae',
      'Country', 'Folk', 'Blues', 'Classical', 'Latin', 'Trap', 'Drill', 'Rage',
      'K-Pop', 'J-Pop', 'City Pop', 'Synth', 'Acoustic', 'Alternative',
      'Indie', 'Metal', 'Punk', 'Grunge', 'Lo-Fi', 'Lofi', 'Chill',
      'Afrobeat', 'Reggaeton', 'Moombahton', 'Future Bass', 'Dubstep',
      'Trance', 'Techno', 'Progressive', 'Ambient', 'New Age',
      'Gospel', 'Worship', 'Christmas', 'Slow Jam', 'Uptempo',
      'Midtempo', 'Downtempo', 'UK Garage', 'Garage', 'Grime',
      'HIP&GEN-Z', 'GEN-Z', 'Y2K', 'Retro', 'Modern', '80s', '90s',
      // 복합 장르
      'Medium Pop', 'Soft Pop', 'Hard Rock', 'Soft Rock', 'Deep House',
      'Tech House', 'Tropical House', 'Melodic House', 'Bass House',
      'Easy Listening',
      // 한글 장르
      '팝', '발라드', '힙합', '알앤비', '댄스', '재즈', '소울', '펑크', '디스코',
      '록', '블루스', '컨트리', '포크', '클래식', '라틴', '트랩', '일렉트로닉',
      '어쿠스틱', '인디', '메탈', '펑크', '칠', '레게', '레게톤', '하우스',
      '테크노', '트랜스', '앰비언트', '팝미디움', '미디움팝', '소프트팝'
    ];

    // 장르 키워드인지 확인
    const isGenreKeyword = (text) => {
      const lowerText = text.toLowerCase().replace(/[&-]/g, '');
      return GENRE_KEYWORDS.some(genre =>
        lowerText.includes(genre.toLowerCase().replace(/[&-]/g, ''))
      );
    };

    // 알려진 작곡가 목록 (자동 인식용)
    const KNOWN_COMPOSERS = new Set([
      'Smob', 'SMOB', 'Sooyoon', 'Zomay', 'Chris Alice', 'TAN', 'Sisyphus',
      '영원희', 'Karrinator', '케빈오빠', 'MOGT', 'YUSU', 'OneTop', 'Zeenan',
      'Andy', '서정진', '전근화', 'Weeky1', 'BT', '유정훈', '박민우', '박현규',
      '오영빈', 'Noheul', '노을', '차민호', 'Adam Argyle', 'Phil Plested',
      'Ron Irving', 'Dave Pickell', 'Ben Charles', 'Jose Manuel',
      "NU'MAKER", 'I-NORI', 'Gusten Dahlqvist', 'Jes Meinertz',
      'June', 'KWH', 'Andreas', '서의성', '정진욱', '이성혁',
      '김원', 'Renjin Zhao', 'J.S', '배새롬', 'KZ', 'JADE', 'IRIS',
      'Marldn', 'Oski', 'Lawrence Mace', 'TY', 'ES2', 'Louise Frick Sveen',
      '성환', 'Azsuen', '이은석', 'Silverstone', '김도경', 'DØK'
    ]);

    // 이메일/폴더명 → OP명 매핑 (확장됨)
    const EMAIL_TO_OP = {
      // 기존 매핑
      'tos92@naver.com': 'To.S',
      'dctsung@naver.com': 'ES2',
      'kino1229@naver.com': 'YJH',
      'ahlgus2696@naver.com': 'PHK',
      'mildang@naver.com': 'OYB',
      'daslkfj@hanmail.net': 'JGH',
      'coollife07@naver.com': 'Noheul',
      'molesmusik@yahoo.es': 'JM',
      'twobluebirds@shaw.ca': 'RON',
      'bcabox@gmail.com': 'BEN',
      'colin.hembus@eavesmusicgroup.com': 'EavesMusic',
      'atcmusic.ar.0328@gmail.com': 'ART.M',
      // 새로운 매핑 (NEXZ JAPAN 프로젝트 등)
      'eunae.solcire@gmail.com': 'Solcire',
      'smobmusicofficial@gmail.com': 'SMOB',
      'oskar.larsson@glmusic.dk': 'GL',
      'hjkim@musiccombine.com': 'Music Combine',
      'purpl78@hanmail.net': 'KW',  // 김원 작가
      'modern_sound@naver.com': 'Modern Sound',
      'victoria.ree@concord.com': 'CON',
      'info@wavecandy.com': 'WC',
      'emma@cosmos-music.com': 'COS',
      // 추가 국제 퍼블리셔
      'soundgraphics': 'SoundGraphics',
      'admin@soundgraphics.co.kr': 'SoundGraphics',
      'shun@soundgraphics.net': 'SG',
      // 신규 매핑
      'jty9142@gmail.com': 'JYT',
      'roxannechloe@hotmail.co.uk': 'audiofreaks',
      'zzix1234@naver.com': 'KZ',
      'jaadde@naver.com': 'JADE',
      'sae170@naver.com': 'BSR',
      'eogh8282@naver.com': 'JDH',
      'mbarocci@peermusic.com': 'PM.ITALY',
      'dyeguitar@hanmail.net': 'LDW',
      'jongmuyng@nate.com': 'ZOMAY',
      // 신규 추가 (2026-02-10)
      'min_ho0923@hanmail.net': 'JMH',
      'surpass84@naver.com': 'hiir',
      'ent102sy@naver.com': 'JSY',
    };

    // 이메일 → 저작자 매핑 (자동 저작자 입력용)
    const EMAIL_TO_COMPOSER = {
      'ahlgus2696@naver.com': '박현규',
      'purpl78@hanmail.net': '김원',
      'molesmusik@yahoo.es': 'Jose Manuel',
      'zzix1234@naver.com': 'KZ',
      'jaadde@naver.com': 'JADE',
      'sae170@naver.com': '배새롬',
      'eogh8282@naver.com': '진대호',
      'dyeguitar@hanmail.net': '이동우',
      'jongmuyng@nate.com': 'ZOMAY, MIND182, MAYFLY',
      // 신규 추가 (2026-02-10)
      'min_ho0923@hanmail.net': '진민호(Markus.J)',
      'surpass84@naver.com': 'hiir',
      'ent102sy@naver.com': 'JSY',
    };

    // 작가명 → OP명 매핑 (확장됨)
    const COMPOSER_TO_OP = {
      // 기존 매핑
      'onetop': 'OneTop',
      'zeenan': 'OneTop',
      'andy': 'OneTop',
      '서정진': 'SJJ',
      'to.s': 'To.S',
      'es2': 'ES2',
      'june': 'ES2',
      'kwh': 'ES2',
      'andreas': 'ES2',
      '서의성': 'ES2',
      '전근화': 'JGH',
      'weeky1': 'JGH',
      'bt': 'JGH',
      '정진욱': 'JGH',
      '유정훈': 'YJH',
      '박민우': 'YJH',
      '박현규': 'PHK',
      'phk': 'PHK',
      '박상민': 'PSM',
      '서민기': 'SMK',
      '오영빈': 'OYB',
      'noheul': 'Noheul',
      '노을': 'Noheul',
      '차민호': 'ART.M',
      'marco': 'LMK',
      'artmatic': 'ART.M',
      'john void': 'ENIAC',
      'eniac': 'ENIAC',
      '진대호': 'JDH',
      '이기환': 'LKH',
      'chris wahle': 'CW',
      'adam argyle': 'EavesMusic',
      'phil plested': 'EavesMusic',
      'nick hahn': 'EavesMusic',
      'alexander hahn': 'EavesMusic',
      'ron irving': 'RON',
      'dave pickell': 'RON',
      'corey abrams': 'RON',
      'ben charles': 'BEN',
      'jose manuel': 'JM',
      'domingo morales': 'JM',
      'santiago revilla': 'JM',
      'filo ebid': 'JM',
      'josue vergara': 'JM',
      'pablo peset': 'JM',
      // 새로운 매핑 (Solcire, SMOB, GL Music 등)
      'chris alice': 'Solcire',
      '영원희': 'Solcire',
      'sisyphus': 'Solcire',
      'tan': 'Solcire',
      'karrinator': 'Solcire',
      '케빈오빠': 'Solcire',
      'mogt': 'Solcire',
      'yusu': 'Solcire',
      'solcire': 'Solcire',
      '쏠시레': 'Solcire',
      'smob': 'SMOB',
      "nu'maker": 'SMOB',
      'i-nori': 'SMOB',
      // GL Music (북유럽)
      'gusten dahlqvist': 'GL',
      'cosmos': 'COS',  // COSMOS → COS
      'jes meinertz': 'GL',
      'johs': 'GL',
      'deekay': 'GL',
      'david west': 'GL',
      'lasse lindorff': 'GL',
      'svend gudiksen': 'GL',
      'mats valentin': 'GL',
      'jade ell': 'GL',
      'mattias kolstrup': 'GL',
      'frans nielsen': 'GL',
      'anders banke': 'GL',
      'mathilde nyegaard': 'GL',
      'tigerspring': 'GL',
      'olga sundin': 'GL',
      'the very good': 'GL',
      'cutfather': 'GL',
      'frederik jyll': 'GL',
      'amanda thomsen': 'GL',
      'lukas visti': 'GL',
      'renjin': 'GL',
      'rasmus gregersen': 'GL',
      'daniel michael victor': 'GL',
      'gl music': 'GL',
      // Music Combine
      '뮤직컴바인': 'Music Combine',
      'music combine': 'Music Combine',
      // SoundGraphics
      'soundgraphics': 'SoundGraphics',
      'sg': 'SoundGraphics',
      // Concord
      'concord': 'Concord',
      // 추가 한국 작곡가 (이니셜 기반 OP명)
      '손연성': 'SON',
      '주현민': 'JHM',
      '박수석': 'PSS',
      '이성혁': 'JGH',
      '배새롬': 'BSR',
      // 해외 작곡가/팀
      'kz': 'KZ',
      'jade': 'JADE',
      'marldn': 'JADE',
      // 뮤직컴바인
      '성환': 'MC.B',
      'azsuen': 'MC.B',
      '이은석': 'MC.B',
      'silverstone': 'MC.B',
      '김도경': 'MC.B',
      'døk': 'MC.B',
    };

    // 이메일에서 OP명 추출 (확장됨 - 자동 추출 지원)
    const getOPFromEmail = (email) => {
      if (!email) return '';
      const emailLower = email.toLowerCase();

      // 1. 정확한 이메일 매칭 우선 (shun@soundgraphics.net → SG)
      if (EMAIL_TO_OP[emailLower]) {
        return EMAIL_TO_OP[emailLower];
      }

      // 2. 부분 문자열 매칭 (기존 로직)
      for (const [key, value] of Object.entries(EMAIL_TO_OP)) {
        if (!key.includes('@') && emailLower.includes(key.toLowerCase())) {
          return value;
        }
      }

      // 2. 이메일 로컬파트에서 자동 추출
      // 예: audiofreaksmusic@gmail.com → audiofreak
      const atIndex = email.indexOf('@');
      if (atIndex > 0) {
        let localPart = email.substring(0, atIndex);

        // "music", "publishing", "records" 등의 접미사 제거
        localPart = localPart
          .replace(/music$/i, '')
          .replace(/publishing$/i, '')
          .replace(/records$/i, '')
          .replace(/productions?$/i, '')
          .replace(/entertainment$/i, '')
          .replace(/media$/i, '')
          .replace(/s$/i, ''); // 복수형 s 제거

        // 첫 글자 대문자로 변환
        if (localPart.length > 0) {
          return localPart.charAt(0).toUpperCase() + localPart.slice(1);
        }
      }

      return '';
    };

    // 저작자명에서 OP명 추출 (한국 작곡가 자동 이니셜 지원)
    const getOPFromComposer = (composer) => {
      if (!composer) return '';
      const composerLower = composer.toLowerCase();

      // 1. 매핑 테이블에서 검색
      for (const [key, value] of Object.entries(COMPOSER_TO_OP)) {
        if (composerLower.includes(key.toLowerCase())) {
          return value;
        }
      }

      // 2. 한국 작곡가 자동 이니셜 추출 (한글 2-4자)
      // 쉼표로 구분된 첫 번째 작곡가만 사용
      const firstComposer = composer.split(/[,/]/)[0].trim();
      if (/^[가-힣]{2,4}$/.test(firstComposer)) {
        return getKoreanInitials(firstComposer);
      }

      // 3. 영문 이름 이니셜 추출 (Chris Wahle → CW)
      if (/^[A-Z][a-z]+\s+[A-Z][a-z]+/.test(firstComposer)) {
        return getEnglishInitials(firstComposer);
      }

      // 4. 그 외: 빈칸 제거 (high seAson → highseAson)
      if (/^[A-Za-z\s]+$/.test(firstComposer)) {
        return firstComposer.replace(/\s+/g, '');
      }

      return '';
    };

    // 한글 초성 추출
    const getKoreanInitials = (name) => {
      const CHO_EN = ['G','KK','N','D','DD','R','M','B','BB','S','SS','','J','JJ','CH','K','T','P','H'];
      let initials = '';
      for (let char of name) {
        const code = char.charCodeAt(0) - 44032;
        if (code >= 0 && code <= 11171) initials += CHO_EN[Math.floor(code / 588)];
      }
      return initials || name;
    };

    // 영문 이니셜 추출
    const getEnglishInitials = (name) => {
      const words = name.split(/[\s,._-]+/).filter(w => w.length > 0);
      if (words.length === 1) return name.substring(0, 3).toUpperCase();
      return words.map(w => w[0].toUpperCase()).join('');
    };

    // 폴더 경로에서 아티스트명 추출 (개선됨 - 숫자 포함 지원)
    const extractArtistFromPath = (path) => {
      const patterns = [
        // "Hearts2Hearts 전체 DEMO(2026.01.30)" → Hearts2Hearts
        /([가-힣a-zA-Z0-9]+)\s*전체\s*DEMO/i,
        // "NEXZ(일본앨범) 수록곡 전체 DEMO" → NEXZ
        /([가-힣a-zA-Z0-9]+)\s*\([^)]+\)\s*(?:수록곡\s*)?전체\s*DEMO/i,
        // "NEXZ JAPAN 데모" → NEXZ JAPAN
        /\[.*?\]\s*([가-힣a-zA-Z0-9\s]+)\s*데모/i,
        // 일반 DEMO 패턴 (숫자 포함)
        /([가-힣a-zA-Z0-9]+)\s*DEMO/i,
      ];
      for (const pattern of patterns) {
        const match = path.match(pattern);
        if (match) return match[1].trim();
      }
      return '';
    };

    // 폴더 경로에서 업로드 날짜 추출 (새로운 함수)
    const extractDateFromPath = (path) => {
      // 패턴 1: (2026.01.28) 또는 (2026-01-28) 형식
      const parenDateMatch = path.match(/\((\d{4})[.\-](\d{2})[.\-](\d{2})\)/);
      if (parenDateMatch) {
        return `${parenDateMatch[1]}-${parenDateMatch[2]}-${parenDateMatch[3]}`;
      }

      // 패턴 2: 26.01.27 형식 (YY.MM.DD)
      const shortDateMatch = path.match(/(\d{2})[.\-](\d{2})[.\-](\d{2})/);
      if (shortDateMatch) {
        const year = parseInt(shortDateMatch[1]) < 50 ? `20${shortDateMatch[1]}` : `19${shortDateMatch[1]}`;
        return `${year}-${shortDateMatch[2]}-${shortDateMatch[3]}`;
      }

      // 패턴 3: 2026-01-28 또는 2026.01.28 형식
      const fullDateMatch = path.match(/(\d{4})[.\-](\d{2})[.\-](\d{2})/);
      if (fullDateMatch) {
        return `${fullDateMatch[1]}-${fullDateMatch[2]}-${fullDateMatch[3]}`;
      }

      return null;
    };

    // 폴더 경로에서 이메일 추출 (순수 이메일만, _ 앞의 아티스트명 제거)
    const extractEmailFromPath = (path) => {
      // 이메일 패턴 매칭 (@ 기호를 기준으로)
      const emailMatch = path.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
      if (emailMatch) {
        return cleanEmailAddress(emailMatch[1]);
      }
      if (path.includes('성규호 작가님') || path.includes('대표님')) {
        return '대표님 전달 DEMO';
      }
      return '';
    };

    // 이메일 주소 정제 함수 - '_' 이후 부분만 추출
    const cleanEmailAddress = (rawEmail) => {
      if (!rawEmail) return '';

      // _ 로 시작하면 제거 (예: _daslkfj@hanmail.net → daslkfj@hanmail.net)
      let email = rawEmail.startsWith('_') ? rawEmail.substring(1) : rawEmail;

      // @ 앞부분에서 마지막 '_' 이후가 실제 이메일 주소
      const atIndex = email.indexOf('@');
      if (atIndex > 0) {
        const localPart = email.substring(0, atIndex);
        const domain = email.substring(atIndex);

        // 로컬파트에 _가 있으면 마지막 _ 이후만 사용
        const lastUnderscoreIndex = localPart.lastIndexOf('_');
        if (lastUnderscoreIndex >= 0) {
          const afterUnderscore = localPart.substring(lastUnderscoreIndex + 1);
          // _ 이후에 유효한 문자가 있으면 그것만 사용
          if (afterUnderscore.length > 0) {
            email = afterUnderscore + domain;
          }
        }
      }

      return email;
    };

    // 폴더 경로에서 저작자 힌트 추출
    const extractComposerHintFromPath = (path) => {
      const folderMatch = path.match(/([가-힣]+)_[가-힣]+\s*Demo/i);
      if (folderMatch) return folderMatch[1];
      const suffixMatch = path.match(/Demo_([가-힣]+)/i);
      if (suffixMatch) return suffixMatch[1];
      return '';
    };

    // 날짜 포맷
    const formatDate = (date) => {
      if (!date) return new Date().toISOString().split('T')[0];
      const d = new Date(date);
      return d.toISOString().split('T')[0];
    };

    // 대괄호에서 저작자들 추출 [A][B][C] → "A, B, C"
    const extractComposersFromBrackets = (text) => {
      const matches = text.match(/\[([^\]]+)\]/g);
      if (!matches) return '';
      const composers = matches.map(m => m.replace(/[\[\]]/g, '').trim());
      return composers.join(', ');
    };

    // 곡명에서 URL/회사명/부가정보 제거
    const cleanSongName = (name) => {
      return name
        // www.로 시작하는 도메인 제거
        .replace(/\s*[-–]\s*www\.[a-z0-9.-]+/gi, '')
        // http:// 또는 https:// URL 제거
        .replace(/\s*[-–]\s*https?:\/\/[^\s]+/gi, '')
        // .com, .co.uk 등 도메인 제거
        .replace(/\s*[-–]\s*[a-z0-9-]+\.(com|co\.uk|net|org|io)/gi, '')
        // (가제), (demo), (데모) 등 괄호 안 부가 정보 제거
        .replace(/\s*\([^)]*[가제데모DEMO][^)]*\)/gi, '')
        // DEMO 완전 제거 - 어떤 위치에 있든 (앞, 중간, 뒤, 단독)
        .replace(/[\s_-]*DEMO[\s_#\d]*$/i, '')  // 끝에 있는 DEMO, DEMO#2 등
        .replace(/^DEMO[\s_-]+/i, '')  // 앞에 있는 DEMO
        .replace(/[\s_-]+DEMO(?=[\s_-]|$)/gi, '')  // 중간/끝에 있는 DEMO
        // AR, MR, INST 제거 (끝에 있는 경우)
        .replace(/\s+(AR|MR|INST)$/i, '')
        .trim();
    };

    // ========== 핵심 파싱 함수 (강력한 패턴 인식) ==========
    const parseFileName = (filename, folderPath = '') => {
      let nameWithoutExt = filename.replace(/\.(mp3|wav|m4a|flac|aiff)$/i, '');

      // SoundGraphics 등 파일명 앞의 번호 제거 (1_Wake up Dreamers, 01 Wake up Dreamers 등)
      nameWithoutExt = nameWithoutExt.replace(/^(\d+)[\s_-]+/, '');

      let songName = '';
      let composer = '';
      let opName = '';
      let genre = '';
      let bpm = '';

      // 파일명에서 모든 이메일 추출 및 정제
      const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/gi;
      const allEmails = nameWithoutExt.match(emailRegex) || [];
      const rawEmail = allEmails[0] || extractEmailFromPath(folderPath);
      let email = cleanEmailAddress(rawEmail) || '대표님 전달 DEMO'; // 이메일 없으면 기본값 (let으로 재할당 가능)

      // ★★★ 중요: 파일명에서 이메일 제거 (모든 패턴 매칭이 이메일 없는 상태에서 작동하도록) ★★★
      nameWithoutExt = nameWithoutExt.replace(emailRegex, '').replace(/_+$/, '').trim();

      const composerHint = extractComposerHintFromPath(folderPath);
      const folderOP = extractOPFromFolderPath(folderPath);

      // ========== 패턴 0-1: MC_번호_곡명 형식 (뮤직컴바인) ==========
      // 예: MC_03882_Breeze: 138BPM_Bbkey_가이드보컬 AI활용_김도경(DØK).mp3
      // 예: MC_03708_Cocococo_Intro_Soft.mp3
      const mcPattern = /^MC_\d+_([^_:]+)(?:[_:](.+))?/i;
      const mcMatch = nameWithoutExt.match(mcPattern);
      if (mcMatch) {
        songName = mcMatch[1].trim(); // Breeze, Cocococo
        const restInfo = mcMatch[2] || '';

        // 콜론 뒤 정보에서 작곡가 추출 (괄호 안 영문명 포함)
        if (restInfo.includes(':') || /[가-힣]/.test(restInfo)) {
          const composerMatches = restInfo.match(/([가-힣]+\([^)]+\))/g) ||
                                 restInfo.match(/([가-힣]{2,4})/g);
          if (composerMatches && composerMatches.length > 0) {
            composer = composerMatches.join(', ');
          }
        }

        opName = 'MC.B';
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-2: [작곡가] 날짜 코드 곡명 키/템포 형식 ==========
      // 예: [high seAson] 251107 MJ1 tell me what T127 Ab.mp3
      const bracketComposerPattern = /^\[([^\]]+)\]\s*\d+\s+[A-Z0-9]+\s+(.+?)\s+T\d+/i;
      const bracketComposerMatch = nameWithoutExt.match(bracketComposerPattern);
      if (bracketComposerMatch) {
        composer = bracketComposerMatch[1].trim();
        songName = bracketComposerMatch[2].trim();
        opName = getOPFromEmail(email) || composer.replace(/\s+/g, '');
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-3: GL Music 형식 ==========
      // 예: 05 - GL Music - Gimmi Gimmi.mp3
      // 예: GL Music - Good Girls.mp3
      // 예: 07 - GL Music Sweden - Red Zone.mp3
      const glMusicPattern = /^(?:\d+\s*-\s*)?GL\s*Music(?:\s+[A-Za-z]+)?\s*-\s*(.+)$/i;
      const glMusicMatch = nameWithoutExt.match(glMusicPattern);
      if (glMusicMatch) {
        songName = glMusicMatch[1].trim();
        opName = 'GL';
        // 저작자 정보는 크레딧 입력란에서 제공됨 (Metadata 섹션)
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-4: 번호 - 작곡가, 작곡가 - 곡명 형식 ==========
      // 예: 06 - Nick Hahn, Dagny - WOW.mp3
      const numberedComposerPattern = /^\d+\s*-\s*([^-]+?)\s*-\s*(.+)$/;
      const numberedComposerMatch = nameWithoutExt.match(numberedComposerPattern);
      if (numberedComposerMatch) {
        const potentialComposer = numberedComposerMatch[1].trim();
        songName = numberedComposerMatch[2].trim();
        // 쉼표가 있거나 영문 이름 형식이면 작곡가로 인식
        if (/,/.test(potentialComposer) || /^[A-Z][a-z]+(\s+[A-Z][a-z]+)*/.test(potentialComposer)) {
          composer = potentialComposer;
          opName = getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';
        } else {
          opName = getOPFromEmail(email) || folderOP || '';
        }
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-5: 곡명_장르_BPM_DEMO [작곡가] 형식 (Smob 스타일) ==========
      // 예: Average_HipHop&Pop_114_DEMO [Smob].mp3
      // 예: Don't Touch_Hiphop&Pop_102_DEMO [Smob][Mint].mp3
      const smobBracketPattern = /^(.+?)_([A-Za-z&]+)_(\d+)_DEMO\s*(\[.+\])+$/i;
      const smobBracketMatch = nameWithoutExt.match(smobBracketPattern);
      if (smobBracketMatch) {
        songName = smobBracketMatch[1].trim();
        const genreRaw = smobBracketMatch[2].trim();
        bpm = smobBracketMatch[3];

        // 장르 정제 (HipHop&Pop → Hip-Hop & Pop)
        genre = genreRaw.replace(/&/g, ' & ').replace(/([a-z])([A-Z])/g, '$1-$2');

        // 대괄호에서 작곡가들 추출
        const brackets = nameWithoutExt.match(/\[([^\]]+)\]/g);
        if (brackets) {
          const composers = brackets.map(b => b.replace(/[\[\]]/g, '').trim());
          composer = composers.join(', ');
          // 첫 번째 작곡가가 Smob이면 OP명은 SMOB
          opName = composers[0].toUpperCase();
        }

        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-6: [작곡가] 장르- 곡명 (Demo)-bpm숫자 형식 ==========
      // 예: [MARCO] 섹시- Don't Touch Me (Demo)-bpm128.mp3
      const demoGenrePattern = /^\[([^\]]+)\]\s+([^-]+)-\s*(.+?)\s+\(Demo\)-?bpm(\d+)/i;
      const demoGenreMatch = nameWithoutExt.match(demoGenrePattern);
      if (demoGenreMatch) {
        composer = demoGenreMatch[1].trim();
        genre = demoGenreMatch[2].trim();
        songName = demoGenreMatch[3].trim();
        bpm = demoGenreMatch[4];
        opName = getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-6-2: [작곡가] 곡명 (Demo) bpm숫자 형식 ==========
      // 예: [MARCO] DANGEROUS (Demo) bpm93.mp3
      const demoBpmPattern = /^\[([^\]]+)\]\s+(.+?)\s+\(Demo\)\s+bpm(\d+)/i;
      const demoBpmMatch = nameWithoutExt.match(demoBpmPattern);
      if (demoBpmMatch) {
        composer = demoBpmMatch[1].trim();
        songName = demoBpmMatch[2].trim();
        bpm = demoBpmMatch[3];
        opName = getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-6-3: 작가명_곡명_BPM숫자_장르 형식 ==========
      // 예: Markus.J_Satellite_180_ROCK_이메일.mp3 → 이메일은 이미 제거됨
      // 예: hiir_청춘에게 KISS_167_rock_이메일.mp3 → 이메일은 이미 제거됨
      const composerSongBpmGenrePattern = /^([A-Za-z.]+|[가-힣]+)_(.+?)_(\d+)_([A-Za-z\s]+)$/i;
      const composerSongBpmGenreMatch = nameWithoutExt.match(composerSongBpmGenrePattern);
      if (composerSongBpmGenreMatch) {
        const potentialComposer = composerSongBpmGenreMatch[1].trim();
        songName = composerSongBpmGenreMatch[2].trim();
        bpm = composerSongBpmGenreMatch[3];
        genre = composerSongBpmGenreMatch[4].trim();

        // 이메일 기반 저작자 정보가 있으면 우선 사용
        composer = EMAIL_TO_COMPOSER[email] || potentialComposer;
        opName = getOPFromEmail(email) || getOPFromComposer(composer) || folderOP || '';

        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-7: [장르]곡명 BPM숫자 형식 ==========
      // 예: [K-POP]MORE THAN U BPM140.mp3
      const genreBracketPattern = /^\[([^\]]+)\]\s*(.+?)\s+BPM(\d+)/i;
      const genreBracketMatch = nameWithoutExt.match(genreBracketPattern);
      if (genreBracketMatch) {
        const bracketContent = genreBracketMatch[1].trim();
        // K-POP, URBAN 등 장르 키워드인지 확인
        if (isGenreKeyword(bracketContent)) {
          genre = bracketContent;
          songName = genreBracketMatch[2].trim();
          bpm = genreBracketMatch[3];
          composer = composerHint || '';
          opName = getOPFromEmail(email) || getOPFromComposer(composer) || folderOP || '';
          return { songName, composer, opName, email, genre, bpm };
        }
      }

      // ========== 패턴 0-8: [OP명] 곡명_작곡가들 형식 ==========
      // 예: [ARTMATIC] 100% (PERCENT)_LUCAS, 박성민, David Simon.mp3
      const opNameBracketPattern = /^\[([^\]]+)\]\s+(.+?)_(.+)$/;
      const opNameBracketMatch = nameWithoutExt.replace(emailRegex, '').match(opNameBracketPattern);
      if (opNameBracketMatch) {
        const bracketContent = opNameBracketMatch[1].trim();
        const possibleSongName = opNameBracketMatch[2].trim();
        const possibleComposers = opNameBracketMatch[3].trim();

        // 대괄호 내용이 OP명으로 매핑되는지 확인
        const mappedOP = getOPFromComposer(bracketContent);
        if (mappedOP) {
          opName = mappedOP;
          songName = possibleSongName;
          composer = possibleComposers;
          return { songName, composer, opName, email, genre, bpm };
        }
      }

      // ========== 패턴 0-9: 곡명_작곡가, 작곡가_이메일 형식 ==========
      // 예: 99-100 Lies_Chris Wahle, MLC_chris@chriswahle.com.mp3
      const songComposerEmailPattern = /^([^_]+)_([^_@]+)_[a-zA-Z0-9._%+-]+@/;
      const songComposerEmailMatch = nameWithoutExt.match(songComposerEmailPattern);
      if (songComposerEmailMatch) {
        songName = songComposerEmailMatch[1].trim();
        composer = songComposerEmailMatch[2].trim();
        opName = getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-10: 곡명_BPM_장르 (작곡가들) final 형식 (ENIAC) ==========
      // 예: Get Dirty_110bpm_hiphop (eniac, Tricia Hye, Blue Monkey) final.mp3
      // 예: Quiet_120bpm_Hiphop EDM_(eniac & Tricia Hye & Jonathan B.T) final.mp3
      const eniacFinalPattern = /^(.+?)_(\d+)bpm[_\s]*([^(]+?)[\s_]*\(([^)]+)\)\s+final/i;
      const eniacFinalMatch = nameWithoutExt.match(eniacFinalPattern);
      if (eniacFinalMatch) {
        songName = eniacFinalMatch[1].trim();
        bpm = eniacFinalMatch[2];
        genre = eniacFinalMatch[3].trim();
        composer = eniacFinalMatch[4].trim().replace(/\s*&\s*/g, ', '); // & → ,
        // ENIAC이 포함되어 있으면 OP명은 ENIAC, 이메일은 "대표님 전달 DEMO"
        if (/eniac/i.test(composer) || /eniac/i.test(nameWithoutExt)) {
          opName = 'ENIAC';
          email = '대표님 전달 DEMO';
        } else {
          opName = getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';
        }
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-10-2: 작가명 - 곡명 (BPM_장르) ((작곡가들)) final 형식 ==========
      // 예: John Void - Dance til' we're dead (160bpm_hyper hiphop) ((eniac, Chicok, 해외작가들)) final.mp3
      const voidPattern = /^([A-Za-z\s]+)\s*-\s*(.+?)\s+\((\d+)bpm[_\s]*([^)]+)\)\s+\(\(([^)]+)\)\)/i;
      const voidMatch = nameWithoutExt.match(voidPattern);
      if (voidMatch) {
        const artistName = voidMatch[1].trim();
        songName = voidMatch[2].trim();
        bpm = voidMatch[3];
        genre = voidMatch[4].trim();
        composer = voidMatch[5].trim();
        // John Void → ENIAC
        opName = getOPFromComposer(artistName) || getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';
        // ENIAC이 포함되어 있으면 이메일 설정
        if (/eniac/i.test(composer) || /eniac/i.test(nameWithoutExt)) {
          email = '대표님 전달 DEMO';
        }
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-10-2-1: 작가명_BPM_곡명 Sketch_장르 형식 ==========
      // 예: 박상민_95BPM_Glow Sketch_POP.mp3
      const sketchPattern = /^([가-힣]{2,4})_(\d+)BPM_(.+?)\s+Sketch_([A-Za-z]+)$/i;
      const sketchMatch = nameWithoutExt.match(sketchPattern);
      if (sketchMatch) {
        composer = sketchMatch[1].trim();
        bpm = sketchMatch[2];
        songName = sketchMatch[3].trim(); // "Glow" (Sketch는 무시)
        genre = sketchMatch[4].trim(); // "POP"
        opName = getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-10-2-2: 한글이름-곡명-BPM숫자-장르 형식 (★ 중요) ==========
      // 예: 서민기-Ignite-BPM108-NewJackSwing_rhymah@naver.com.mp3
      // ★★★ 한글 이름은 절대 제목이 아니라 저작자입니다! ★★★
      const koreanBpmGenrePattern = /^([가-힣]{2,4})\s*-\s*([^-]+)\s*-\s*BPM(\d+)\s*-\s*([A-Za-z\s]+)$/i;
      const koreanBpmGenreMatch = nameWithoutExt.match(koreanBpmGenrePattern);
      if (koreanBpmGenreMatch) {
        composer = koreanBpmGenreMatch[1].trim(); // 서민기
        songName = koreanBpmGenreMatch[2].trim(); // Ignite
        bpm = koreanBpmGenreMatch[3]; // 108
        genre = koreanBpmGenreMatch[4].trim(); // NewJackSwing
        opName = getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-10-3: 작가명 - 곡명 - 장르_이메일 형식 (기본 패턴) ==========
      // 예: 이종준 - I'm You - Band_rykie456@naver.com.mp3
      // 예: 전근화 - Love Song - Pop_demo@example.com.mp3
      // ★ BPM으로 시작하는 경우는 제외 (패턴 0-10-2-2에서 처리)
      const basicComposerSongGenrePattern = /^([^-_]+)\s*-\s*([^-_]+)\s*-\s*(?!BPM)([^_]+?)(?:_|$)/i;
      const basicComposerSongGenreMatch = nameWithoutExt.match(basicComposerSongGenrePattern);
      if (basicComposerSongGenreMatch) {
        composer = basicComposerSongGenreMatch[1].trim();
        songName = basicComposerSongGenreMatch[2].trim();
        genre = basicComposerSongGenreMatch[3].trim();
        opName = getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-10-4: 작가명-곡명_이메일 형식 (하이픈 한 개, 기본 패턴) ==========
      // 예: 이기환-It's just a little too late DEMO_kihwani0311@naver.com.mp3
      // 예: 전근화-Beautiful Day_demo@example.com.mp3
      const simpleComposerSongPattern = /^([가-힣]{2,4}|[A-Z][a-z]+(?:\s[A-Z][a-z]+)*)\s*-\s*(.+?)(?:_|$)/;
      const simpleComposerSongMatch = nameWithoutExt.match(simpleComposerSongPattern);
      if (simpleComposerSongMatch) {
        composer = simpleComposerSongMatch[1].trim();
        songName = simpleComposerSongMatch[2].trim();
        opName = getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-10-5: 작곡가들 (x, 쉼표 구분) - 곡명 형식 ==========
      // 예: Hoodie x GXXD KELVIN, Samson - JETSKI.mp3
      // ★ 작곡가 여러 명 (x나 쉼표로 구분) - 곡명 (대문자)
      const multiComposerDashPattern = /^([A-Z][A-Za-z0-9\s]+(?:[x,]\s*[A-Z][A-Za-z0-9\s]+)+)\s*-\s*([A-Z][A-Z\s!?.]+)$/;
      const multiComposerDashMatch = nameWithoutExt.match(multiComposerDashPattern);
      if (multiComposerDashMatch) {
        composer = multiComposerDashMatch[1].trim().replace(/\s+x\s+/g, ', '); // x → ,
        songName = multiComposerDashMatch[2].trim();
        opName = getOPFromEmail(email) || getOPFromComposer(composer) || folderOP || '';
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 0-11: 곡명_BPM_장르_MST 형식 ==========
      // 예: BOSS ATTITUDE_155_Experimental Bass_MST.mp3
      const mstPattern = /^(.+?)_(\d+)_([^_]+)_MST$/i;
      const mstMatch = nameWithoutExt.match(mstPattern);
      if (mstMatch) {
        songName = mstMatch[1].trim();
        bpm = mstMatch[2];
        genre = mstMatch[3].trim();
        composer = composerHint || 'ENIAC';
        opName = 'ENIAC';
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 1: XO-DEMO #2 (KZ)_이메일 형식 ==========
      // 예: XO-DEMO #2 (KZ)_zzix1234@naver.com.mp3
      const kzPattern = /^([^-_]+)-DEMO\s*#?\d*\s*\(([^)]+)\)/i;
      const kzMatch = nameWithoutExt.match(kzPattern);
      if (kzMatch) {
        songName = kzMatch[1].trim();
        composer = kzMatch[2].trim();
        opName = getOPFromEmail(email) || getOPFromComposer(composer) || composer;
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 2: 곡명_ JADE, IRIS, ... 형식 (쉼표로 작곡가 나열) ==========
      // 예: Collide_ JADE, IRIS, Marldn, Oski, Lawrence Mace, TY.mp3
      const multiComposerPattern = /^([^_]+)_\s*([A-Z][a-zA-Z\s,]+)$/;
      const multiComposerMatch = nameWithoutExt
        .replace(emailRegex, '') // 이메일 먼저 제거
        .match(multiComposerPattern);
      if (multiComposerMatch) {
        songName = multiComposerMatch[1].trim();
        composer = multiComposerMatch[2].trim();
        opName = getOPFromEmail(email) || getOPFromComposer(composer) || folderOP || '';
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 3: I Promise (You)(ES2+작가) (BPM,장르) 형식 ==========
      // 예: I Promise (You)(ES2+Louise Frick Sveen) (95,Woman Dance).mp3
      const es2PlusPattern = /^(.+?)\(([^)]+\+[^)]+)\)\s*\(([^)]+)\)/;
      const es2PlusMatch = nameWithoutExt.match(es2PlusPattern);
      if (es2PlusMatch) {
        songName = es2PlusMatch[1].trim();
        composer = es2PlusMatch[2].replace(/\+/g, ' + ').trim();
        genre = es2PlusMatch[3].replace(/,/g, ', ').trim();
        opName = getOPFromEmail(email) || getOPFromComposer(composer) || 'ES2';
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 패턴 4: 작곡가,작곡가 [곡명] 형식 ==========
      // 예: KRXB,YEON [Heart reaction] DEMO_jty9142@gmail.com.mp3
      const composersBracketPattern = /^([A-Z]+(?:,[A-Z]+)*)\s*\[([^\]]+)\]/i;
      const composersBracketMatch = nameWithoutExt.match(composersBracketPattern);
      if (composersBracketMatch) {
        composer = composersBracketMatch[1].replace(/,/g, ', ').trim();
        songName = composersBracketMatch[2].trim();
        opName = getOPFromEmail(email) || getOPFromComposer(composer) || folderOP || '';
        return { songName, composer, opName, email, genre, bpm };
      }

      // 대괄호에서 저작자 추출 (기존 로직)
      const bracketComposers = extractComposersFromBrackets(nameWithoutExt);

      // 파일명에서 이메일과 대괄호 제거한 버전
      let cleanName = nameWithoutExt
        .replace(emailRegex, '')  // 이메일 제거
        .replace(/\[([^\]]+)\]/g, '')  // 대괄호 제거
        .replace(/_+/g, '_')  // 연속 언더스코어 정리
        .replace(/^_|_$/g, '')  // 앞뒤 언더스코어 제거
        .trim();

      // ★ 스마트 패턴 인식: 작곡가와 곡명 지능적 구분
      const parts = cleanName.split('_').map(p => p.trim()).filter(p => p);

      if (parts.length >= 2) {
        let composerCandidate = '';
        let songNameCandidate = '';
        let idx = 0;

        const firstPart = parts[0];

        // ========== 작곡가 판별 규칙 (우선순위 순) ==========

        // 규칙 1: 쉼표로 구분된 여러 이름 → 작곡가 리스트
        // 예: 이국현,이동영,김민규 / SFaceG-Lizlee-Dosi
        const hasMultipleComposers =
          /[,\-]/.test(firstPart) && // 쉼표나 하이픈 포함
          (firstPart.split(/[,\-]/).length >= 2); // 2명 이상

        // 규칙 2: 한글 이름 2-4자 (단일 작곡가)
        const isSingleKoreanName = /^[가-힣]{2,4}$/.test(firstPart);

        // 규칙 3: 알려진 작곡가
        const isKnownComposer = KNOWN_COMPOSERS.has(firstPart);

        // 규칙 4: 영문 이름 형식 (단일 작곡가)
        const isEnglishName = /^[A-Z][a-z]+(\s[A-Z][a-z]+)*$/.test(firstPart);

        // 작곡가로 판단
        if (hasMultipleComposers || isSingleKoreanName || isKnownComposer || isEnglishName) {
          composerCandidate = firstPart.replace(/,/g, ', ').replace(/-/g, ', '); // 쉼표/하이픈 정리
          songNameCandidate = parts[1];
          idx = 2;
        } else {
          // 곡명으로 판단
          songNameCandidate = firstPart;
          idx = 1;
        }

        songName = songNameCandidate;
        composer = composerCandidate;

        // 나머지 부분에서 BPM, 장르 추출
        const genreParts = [];

        for (let i = idx; i < parts.length; i++) {
          const part = parts[i];

          // DEMO 스킵
          if (/^DEMO[#]?$/i.test(part)) continue;

          // 숫자_장르 패턴 (140_HYPERPOP → BPM:140, 장르:HYPERPOP)
          const bpmGenreMatch = part.match(/^(\d+)_([A-Z]+)$/i);
          if (bpmGenreMatch) {
            bpm = bpmGenreMatch[1];
            genreParts.push(bpmGenreMatch[2]);
            continue;
          }

          // BPM 패턴 (BPM104, 104, Tempo104 등)
          const bpmMatch = part.match(/(?:BPM|Tempo)?(\d+)/i);
          if (bpmMatch && !bpm) {
            bpm = bpmMatch[1];
            continue;
          }

          // 장르 키워드
          if (isGenreKeyword(part)) {
            genreParts.push(part);
            continue;
          }

          // 지분율 포함 저작자 정보
          if (/\d+(\.\d+)?%/.test(part) && /[A-Za-z가-힣]/.test(part)) {
            composer = composer ? `${composer}, ${part}` : part;
            continue;
          }

          // 퍼블리셔 키워드
          if (/Peermusic|Outdustry|Publishing/i.test(part)) {
            composer = composer ? `${composer} ${part}` : part;
            continue;
          }

          // 그 외 작곡가로 추가 (매우 제한적으로만 허용)
          // 작곡가가 이미 있으면 추가 정보를 저작자에 넣지 않음
          // 장르나 기타 정보를 저작자로 오인하는 것 방지
          if (!composer && !/^\d+$/.test(part) && !/@/.test(part) && /^[가-힣A-Za-z\s]+$/.test(part)) {
            // 작곡가가 없고, 순수 문자열인 경우만 작곡가로 추가
            composer = part;
          }
        }

        // 장르 조합
        if (genreParts.length > 0) {
          genre = genreParts.join(' / ');
        }
      } else if (parts.length === 1) {
        // 단일 파트는 곡명
        songName = parts[0];
      }

      // 대괄호 저작자 우선 사용
      if (bracketComposers) {
        composer = bracketComposers;
      }

      // OP명 결정 (한국 작곡가 이니셜 최우선)
      opName = getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';

      // 이메일에서 기본 저작자 매핑 (저작자가 비어있을 때)
      if (!composer && email && EMAIL_TO_COMPOSER[email]) {
        composer = EMAIL_TO_COMPOSER[email];
      }

      // 결과가 있으면 곡명 정제 후 반환
      if (songName) {
        songName = cleanSongName(songName);
        // ★ 안전장치: 한글 이름(2-4자)이 제목에 남아있으면 작곡가로 이동
        const koreanCheck = songName.match(/^([가-힣]{2,4})\s*[-–]\s*(.+)$/);
        if (koreanCheck) {
          composer = composer || koreanCheck[1].trim();
          songName = cleanSongName(koreanCheck[2].trim());
          if (!opName) opName = getOPFromComposer(composer) || '';
        }
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 기존 특수 패턴들 (fallback) ==========

      // 패턴 1: _Pitched by MC로 끝나는 파일 (이미 처리된 파일)
      const pitchedMatch = nameWithoutExt.match(/^(.+?)_([^_]+)_Pitched by MC$/i);
      if (pitchedMatch) {
        songName = pitchedMatch[1].trim();
        opName = pitchedMatch[2].trim();
        composer = composerHint || opName;
        return { songName, composer, opName, email };
      }

      // 패턴 2: [작가명]_곡명_BPM숫자_장르 형식
      const bracketMatch = nameWithoutExt.match(/^\[([^\]]+)\]_(.+?)(?:_BPM\d+)?(?:_[a-zA-Z]+)?$/i);
      if (bracketMatch) {
        composer = bracketMatch[1].trim();
        songName = bracketMatch[2].trim();
        opName = getOPFromComposer(composer) || composer;
        return { songName, composer, opName, email };
      }

      // 패턴 3: 곡명(작가+작가) (BPM,장르) 형식 (ES2 스타일)
      const es2Match = nameWithoutExt.match(/^(.+?)\(([^)]+)\)\s*\([^)]*\)$/);
      if (es2Match) {
        songName = es2Match[1].trim();
        composer = es2Match[2].replace(/\+/g, ', ').trim();
        opName = getOPFromComposer(composer) || 'ES2';
        return { songName, composer, opName, email };
      }

      // 패턴 4: Weeky1- 곡명 [Tempo숫자] 장르 형식 (JGH 스타일)
      const weekyMatch = nameWithoutExt.match(/^Weeky1-\s*(.+?)\s*\[Tempo\d+\]/i);
      if (weekyMatch) {
        songName = weekyMatch[1].trim();
        composer = '전근화(Weeky1), BT';
        opName = 'JGH';
        return { songName, composer, opName, email };
      }

      // 패턴 5: 작가1,작가2_곡명_BPM숫자 형식 (OneTop 스타일)
      const commaMatch = nameWithoutExt.match(/^([^_]+[,&][^_]+)_(.+?)(?:_BPM\d+)?$/i);
      if (commaMatch) {
        composer = commaMatch[1].replace(/&/g, ', ').trim();
        songName = commaMatch[2].trim();
        opName = getOPFromComposer(composer) || getEnglishInitials(composer.split(/[,&]/)[0].trim());
        return { songName, composer, opName, email };
      }

      // 패턴 6: 유정훈_박민우_나무_B-Ab_69 형식 (YJH 스타일)
      const yjhMatch = nameWithoutExt.match(/^([가-힣]+)_([가-힣]+)_(.+?)_[A-G][#b]?[-_][A-Za-z]+_\d+$/i);
      if (yjhMatch) {
        composer = `${yjhMatch[1]}, ${yjhMatch[2]}`;
        songName = yjhMatch[3].trim();
        opName = getOPFromComposer(yjhMatch[1]) || 'YJH';
        return { songName, composer, opName, email };
      }

      // 패턴 7: 01 - Adam Argyle, ... Looks Different 형식 (EavesMusic)
      const eavesMatch = nameWithoutExt.match(/^\d+\s*-\s*(.+?)\s*-\s*(.+)$/);
      if (eavesMatch) {
        composer = eavesMatch[1].replace(/\.\.\./g, '').trim();
        songName = eavesMatch[2].trim();
        opName = 'EavesMusic';
        return { songName, composer, opName, email };
      }

      // 패턴 8: 곡명 - 작가명 형식 (여러 스타일)
      const dashComposerMatch = nameWithoutExt.match(/^(.+?)\s*[-–]\s*([A-Za-z\s,]+)$/);
      if (dashComposerMatch) {
        const possibleComposer = dashComposerMatch[2].trim();
        const matchedOP = getOPFromComposer(possibleComposer.toLowerCase());
        if (matchedOP || /^[A-Z][a-z]+(\s+[A-Z][a-z]+)*$/.test(possibleComposer)) {
          songName = dashComposerMatch[1].trim();
          composer = possibleComposer;
          opName = matchedOP || getOPFromEmail(email) || folderOP || '';
          return { songName, composer, opName, email };
        }
      }

      // 패턴 9: 오영빈_날 떠나지마_74_팝 발라드 형식
      const oyoMatch = nameWithoutExt.match(/^([가-힣]+)_(.+?)_\d+_/);
      if (oyoMatch) {
        composer = oyoMatch[1].trim();
        songName = oyoMatch[2].trim();
        opName = getOPFromComposer(composer) || getKoreanInitials(composer);
        return { songName, composer, opName, email };
      }

      // 패턴 10: 곡명 DEMO_OP명 또는 곡명_OP명 형식 (Solcire 스타일)
      // 예: "POP BEAT DEMO_Solcire Music.mp3" → 곡명: "POP BEAT", OP: "Solcire"
      const demoOPMatch = nameWithoutExt.match(/^(.+?)\s*(?:DEMO[#]?)?_([A-Za-z\s.]+)$/i);
      if (demoOPMatch) {
        let rawSongName = demoOPMatch[1].trim();
        const rawOP = demoOPMatch[2].trim();
        // 곡명에서 DEMO 제거
        rawSongName = rawSongName.replace(/\s*DEMO[#]?\s*$/i, '').trim();
        songName = rawSongName;
        const matchedOP = getOPFromComposer(rawOP.toLowerCase());
        opName = matchedOP || rawOP;
        composer = composerHint || '';
        return { songName, composer, opName, email };
      }

      // 패턴 11: 곡명_T숫자_Key_가이드보컬 형식
      // 예: "Saturn_T94_Gkey_가이드보컬.mp3" → 곡명: "Saturn"
      const tempoKeyMatch = nameWithoutExt.match(/^(.+?)_T\d+_[A-G][#b]?(?:key|m)?/i);
      if (tempoKeyMatch) {
        songName = tempoKeyMatch[1].trim();
        opName = getOPFromEmail(email) || folderOP || '';
        composer = composerHint || '';
        return { songName, composer, opName, email };
      }

      // 패턴 12: 곡명_장르_숫자_DEMO 형식
      // 예: "있잖아 (AHMOLLA)_HIP&GEN-Z_192_DEMO.mp3" → 곡명: "있잖아 (AHMOLLA)" 또는 "있잖아"
      const genreNumDemoMatch = nameWithoutExt.match(/^(.+?)_[A-Za-z&-]+_\d+_DEMO$/i);
      if (genreNumDemoMatch) {
        songName = genreNumDemoMatch[1].trim();
        opName = getOPFromEmail(email) || folderOP || '';
        composer = composerHint || '';
        return { songName, composer, opName, email };
      }

      // 패턴 13: 곡명#_작가명 형식
      // 예: "눈부신 사랑 DEMO#_박수석.mp3" → 곡명: "눈부신 사랑"
      const hashDemoMatch = nameWithoutExt.match(/^(.+?)\s*DEMO[#]?_([가-힣A-Za-z\s]+)$/i);
      if (hashDemoMatch) {
        songName = hashDemoMatch[1].trim();
        composer = hashDemoMatch[2].trim();
        opName = getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';
        return { songName, composer, opName, email };
      }

      // 패턴 14: 단순 곡명만 있는 경우 (영문 대문자)
      if (/^[A-Z\s'´!?]+$/i.test(nameWithoutExt) && nameWithoutExt.length > 2) {
        songName = nameWithoutExt.trim();
        opName = getOPFromEmail(email) || folderOP || '';
        composer = composerHint || '';
        return { songName, composer, opName, email };
      }

      // 패턴 15: 아티스트 Demo가 포함된 파일
      const artistDemoMatch = nameWithoutExt.match(/^(.+?)\s*\(([가-힣A-Za-z]+)\s*Demo\)\s*$/i);
      if (artistDemoMatch) {
        songName = artistDemoMatch[1].trim();
        composer = composerHint || '';
        opName = getOPFromComposer(composerHint) || getOPFromEmail(email) || folderOP || '';
        return { songName, composer, opName, email };
      }

      // 기본: 파일명 정제
      songName = nameWithoutExt
        .replace(/_BPM\d+/gi, '')
        .replace(/_Tempo\d+/gi, '')
        .replace(/_T\d+/gi, '')
        .replace(/\s*DEMO[#]?\s*/gi, ' ')
        .replace(/\s*\[.*?\]\s*/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();

      // 마지막 _ 이후가 OP명일 가능성 체크
      const lastUnderscoreIdx = songName.lastIndexOf('_');
      if (lastUnderscoreIdx > 0) {
        const possibleOP = songName.substring(lastUnderscoreIdx + 1).trim();
        const matchedOP = getOPFromComposer(possibleOP.toLowerCase());
        if (matchedOP || (possibleOP.length <= 15 && /^[A-Za-z\s.]+$/.test(possibleOP))) {
          songName = songName.substring(0, lastUnderscoreIdx).trim();
          opName = matchedOP || possibleOP;
        }
      }

      if (!opName) {
        opName = getOPFromEmail(email) || folderOP || '';
      }
      composer = composerHint || '';

      // ★★★ 최종 안전장치: 한글 이름이 제목에 절대 들어가지 않도록 ★★★
      // 한글 2-4자로 시작하는 경우 → 작곡가로 분리
      const koreanNameInTitle = songName.match(/^([가-힣]{2,4})\s*[-–]\s*(.+)$/);
      if (koreanNameInTitle) {
        composer = composer || koreanNameInTitle[1].trim();
        songName = koreanNameInTitle[2].trim();
        if (!opName) opName = getOPFromComposer(composer) || '';
      }
      // 한글 2-4자가 제목 전체인 경우 (작곡가인데 곡명으로 잘못 인식)
      if (/^[가-힣]{2,4}$/.test(songName) && !composer) {
        composer = songName;
        songName = nameWithoutExt.replace(new RegExp(`^${composer}\\s*[-_]\\s*`), '').trim() || songName;
        if (!opName) opName = getOPFromComposer(composer) || '';
      }

      // ★★★ DEMO 최종 제거 ★★★
      songName = cleanSongName(songName);

      return { songName, composer, opName, email };
    };

    // 폴더 경로에서 OP명 추출 (새로운 함수)
    const extractOPFromFolderPath = (path) => {
      // [쏠시레뮤직], [SMOB] 등 대괄호 안의 OP명 추출
      const bracketOPMatch = path.match(/\[([가-힣A-Za-z]+(?:뮤직|Music)?)\]/i);
      if (bracketOPMatch) {
        const opHint = bracketOPMatch[1].trim();
        // 매핑 테이블에서 찾기
        const matchedOP = getOPFromComposer(opHint.toLowerCase().replace(/뮤직|music/gi, ''));
        if (matchedOP) return matchedOP;
        // 그대로 반환
        return opHint.replace(/뮤직$/i, '').replace(/Music$/i, '').trim();
      }
      return '';
    };

    // ========== 완전 독립 입력 컴포넌트 (blur 비동기 처리로 떨림 방지) ==========
    const StableInput = React.memo(({ initialValue, onValueChange, placeholder, className, type = 'text', readOnly = false }) => {
      const [localValue, setLocalValue] = useState(initialValue || '');
      const initialRef = useRef(initialValue);
      const blurTimeoutRef = useRef(null);

      const handleChange = (e) => {
        setLocalValue(e.target.value);
      };

      const handleBlur = () => {
        // blur 처리를 비동기로 지연 - 클릭 이벤트가 먼저 처리되도록 함
        if (blurTimeoutRef.current) {
          clearTimeout(blurTimeoutRef.current);
        }

        blurTimeoutRef.current = setTimeout(() => {
          if (localValue !== initialRef.current && onValueChange) {
            onValueChange(localValue);
            initialRef.current = localValue;
          }
        }, 0);
      };

      // 컴포넌트 언마운트 시 타이머 정리
      useEffect(() => {
        return () => {
          if (blurTimeoutRef.current) {
            clearTimeout(blurTimeoutRef.current);
          }
        };
      }, []);

      return (
        <input
          type={type}
          value={localValue}
          onChange={handleChange}
          onBlur={handleBlur}
          className={className}
          placeholder={placeholder}
          readOnly={readOnly}
        />
      );
    });

    // 완전 독립 Textarea 컴포넌트 (blur 비동기 처리)
    const StableTextarea = React.memo(({ initialValue, onValueChange, placeholder, className, rows = 2 }) => {
      const [localValue, setLocalValue] = useState(initialValue || '');
      const initialRef = useRef(initialValue);
      const blurTimeoutRef = useRef(null);

      const handleChange = (e) => {
        setLocalValue(e.target.value);
      };

      const handleBlur = () => {
        if (blurTimeoutRef.current) {
          clearTimeout(blurTimeoutRef.current);
        }

        blurTimeoutRef.current = setTimeout(() => {
          if (localValue !== initialRef.current && onValueChange) {
            onValueChange(localValue);
            initialRef.current = localValue;
          }
        }, 0);
      };

      useEffect(() => {
        return () => {
          if (blurTimeoutRef.current) {
            clearTimeout(blurTimeoutRef.current);
          }
        };
      }, []);

      return (
        <textarea
          value={localValue}
          onChange={handleChange}
          onBlur={handleBlur}
          className={className}
          placeholder={placeholder}
          rows={rows}
        />
      );
    });

    // 크레딧 입력 컴포넌트 (DemoReviewSystem 외부에 정의하여 리렌더링 방지)
    const CreditTextArea = React.memo(({ textRef }) => {
      const localRef = useRef(null);
      const [localValue, setLocalValue] = useState('');

      const handleChange = (e) => {
        const newValue = e.target.value;
        setLocalValue(newValue);
        textRef.current = newValue;
      };

      return (
        <textarea
          ref={localRef}
          value={localValue}
          onChange={handleChange}
          className="w-full h-64 bg-black/50 text-gray-300 px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500 resize-none mb-4 font-mono text-sm"
          placeholder={`예시:

거기서 거기
작곡 전근화
작사 전근화
편곡 정진욱

Hamburger
writers CC, Ron, JJ

너와의 밤
작곡 전근화(Weeky1), BT
작사 전근화`}
        />
      );
    });

    // 크레딧 텍스트 파싱 (확장됨 - Track Title, WRITERS DETAILS, GL Music Composer, SG OP명 지원)
    const parseCreditText = (creditText) => {
      const credits = {};
      const sgOpNames = {}; // SoundGraphics 곡들의 OP명 (항상 SG)
      const lines = creditText.split('\n').map(l => l.trim()).filter(l => l);

      let currentSong = null;
      let currentCredits = [];
      let creditSaved = false; // 현재 곡의 크레딧이 이미 저장되었는지 추적

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // 섹션 헤더 스킵 (타이틀, 수록성, Metadata, Link, WRITERS DETAILS 등)
        if (/^(타이틀|수록성|수록곡|\(타이틀\)|\(수록성\)|Metadata|Link:|WRITERS DETAILS:|##?\s)/i.test(line)) {
          continue;
        }

        // 패턴 0-0: MC_번호_곡명 또는 MC_번호_곡명_ver: 작사/작곡/편곡 정보
        // 예1: MC_03882_Breeze: 138BPM_Bbkey_가이드보컬 AI활용_김도경(DØK)
        // 예2: MC_03708_Cocococo_Soft ver.
        //      참여 작가 : 작사: Kyle, Itzel 작곡: Elliot, Itzel 편곡: Kyle, Elliot
        // 예3: MC_03912_Glitch
        //      130BPM_Gkey_가이드보컬 AI활용_김도경(DØK)
        const mcCreditMatch = line.match(/^MC_\d+_([^:_]+)(?:_[^:]*)?(?::\s*(.+))?$/i);
        if (mcCreditMatch) {
          const songName = mcCreditMatch[1].trim(); // Breeze, Cocococo, Glitch
          let composerInfo = mcCreditMatch[2] || '';

          // 다음 줄에 추가 정보가 있을 수 있음 (작사/작곡/편곡 또는 BPM/키 정보)
          if (i + 1 < lines.length && !/^MC_|\d+\.|^Track Title:/i.test(lines[i + 1])) {
            i++; // 다음 줄로 이동
            const nextLine = lines[i];
            // 참여 작가가 명시된 경우 또는 BPM/키 정보인 경우 모두 처리
            composerInfo += (composerInfo ? ' ' : '') + nextLine;
          }

          if (composerInfo) {
            // 작사/작곡/편곡에서 모든 작곡가 추출
            const allComposers = new Set();

            // 작사: Kyle, Itzel / 작곡: Elliot, Itzel / 편곡: Kyle, Elliot 파싱
            const creditSections = composerInfo.split(/작사|작곡|편곡|lyricist|composer|arranger/i);
            creditSections.forEach(section => {
              // 김도경(DØK) 또는 영문 이름 또는 한글 이름 추출
              const names = section.match(/[가-힣]+\([^)]+\)|[A-Z][a-z]+|[가-힣]{2,4}/g);
              if (names) {
                names.forEach(name => {
                  const cleaned = name.replace(/[:：,\s]+$/, '').trim();
                  if (cleaned && cleaned !== '참여' && cleaned !== '작가' &&
                      !/^\d+BPM|^[A-G][#b]?key|가이드보컬|AI활용/i.test(cleaned)) {
                    allComposers.add(cleaned);
                  }
                });
              }
            });

            if (allComposers.size > 0) {
              credits[songName.toLowerCase()] = [...allComposers].join(', ');
            }
          }
          continue;
        }

        // 패턴 0: Track Title: 곡명
        const trackTitleMatch = line.match(/^Track Title:\s*(.+)$/i);
        if (trackTitleMatch) {
          // 이전 곡 저장 (줄 단위 저장 - 저작자 이름 보존)
          if (currentSong && currentCredits.length > 0 && !creditSaved) {
            const uniqueCredits = [...new Set(currentCredits.map(c => c.trim()).filter(c => c))];
            credits[currentSong.toLowerCase()] = uniqueCredits.join(', ');
          }
          currentSong = trackTitleMatch[1].trim();
          currentCredits = [];
          creditSaved = false;
          continue;
        }

        // 패턴 0-1: WRITERS DETAILS 섹션 내 작가 정보
        // 예: [33.33%]  Scott Russell Stoddart (CAE: 679119701)
        const writerDetailsMatch = line.match(/^\[[\d.]+%\]\s+([^(]+)(?:\(CAE:[^)]*\))?\s*(.*)$/);
        if (writerDetailsMatch && currentSong) {
          const writerName = writerDetailsMatch[1].trim();
          // CAE 번호와 퍼블리셔 정보 제거하고 작가명만 추출
          if (writerName && !currentCredits.includes(writerName)) {
            currentCredits.push(writerName);
          }
          continue;
        }

        // 패턴 0-2: 번호 : 곡명 : 저작자 : 퍼블리셔 형식 (SoundGraphics)
        // 예: "1 : Wake up Dreamers (J) : oni/YUUKI SANO/Tomoki Tamatani : J-Pub (SG)/KIMONO"
        const sgPattern = /^(\d+)\s*:\s*(.+?)\s*:\s*(.+?)\s*:\s*(.+)$/;
        const sgMatch = line.match(sgPattern);
        if (sgMatch) {
          const songName = sgMatch[2].trim();
          const composerInfo = sgMatch[3].trim();
          const publisherInfo = sgMatch[4].trim();
          // 저작자와 퍼블리셔 정보 합치기
          credits[songName.toLowerCase()] = `${composerInfo} : ${publisherInfo}`;
          // SG 곡의 OP명은 항상 SG
          sgOpNames[songName.toLowerCase()] = 'SG';
          continue;
        }

        // 패턴 1: 번호. 곡명 - 작가1, 작가2 형식 (마크다운 리스트)
        // 예: "1. AEROBATIC PLUM - Chris Alice, 영원희, Sisyphus"
        const numberedMatch = line.match(/^(\d+)\.\s*(.+?)\s*[-–]\s*(.+)$/);
        if (numberedMatch) {
          const songName = numberedMatch[2].trim();
          const composer = numberedMatch[3].trim();
          credits[songName.toLowerCase()] = composer;
          continue;
        }

        // 패턴 2: "곡명.mp3 | Powered by Box" 형식 (Box에서 복사한 형식)
        const boxMatch = line.match(/^(.+?)\.(mp3|wav|m4a|flac|aiff)\s*\|\s*Powered by Box$/i);
        if (boxMatch) {
          // 이전 곡 저장 (줄 단위 저장 - 저작자 이름 보존)
          if (currentSong && currentCredits.length > 0 && !creditSaved) {
            const uniqueCredits = [...new Set(currentCredits.map(c => c.trim()).filter(c => c))];
            credits[currentSong.toLowerCase()] = uniqueCredits.join(', ');
          }
          currentSong = boxMatch[1].trim();
          currentCredits = [];
          creditSaved = false;
          continue;
        }

        // 패턴 3: 테이블 형식 (| # | 곡명 | 저작자 |)
        const tableMatch = line.match(/^\|\s*\d+\s*\|\s*(.+?)\s*\|\s*(.+?)\s*\|$/);
        if (tableMatch) {
          const songName = tableMatch[1].trim();
          const composer = tableMatch[2].trim();
          if (songName && composer && songName !== '곡명' && composer !== '저작자') {
            credits[songName.toLowerCase()] = composer;
          }
          continue;
        }

        // 패턴 4: "Composer\tJay Made (GL Music) / Camilia (Lifted House)" 형식
        // 탭이나 공백으로 구분된 크레딧 필드 (Composer, Writer, Producer, Lyricist, Arranger 등)
        const creditFieldMatch = line.match(/^(Composer|Writer|Producer|Lyricist|Arranger|Songwriter)\s+(.+)$/i);
        if (creditFieldMatch && currentSong) {
          const creditInfo = creditFieldMatch[2].trim();
          // 기존 크레딧에 추가 (여러 필드가 있을 수 있음)
          if (!currentCredits.includes(creditInfo)) {
            currentCredits.push(creditInfo);
          }
          // 즉시 저장 (다음 곡이 올 수 있음)
          const uniqueCredits = [...new Set(currentCredits.map(c => c.trim()).filter(c => c))];
          credits[currentSong.toLowerCase()] = uniqueCredits.join(', ');
          creditSaved = true; // 저장 완료 플래그
          continue;
        }

        // 패턴 5: 작곡/작사/편곡/writers로 시작하는 크레딧 라인
        const isKoreanCredit = /^(작곡|작사|편곡|writers?|composer|lyricist|arranger)\s*[-:：]?\s*/i.test(line);

        // 패턴 6: 퍼센트(%)가 포함된 크레딧 라인 (Jose Manuel 50% 형식)
        const hasPercentage = /%/.test(line);

        // 패턴 7: PEERMUSIC이 포함된 라인 (크레딧 정보)
        const hasPeermusic = /PEERMUSIC/i.test(line);

        if (currentSong && (isKoreanCredit || hasPercentage || hasPeermusic)) {
          // 크레딧 정보 추출
          let creditInfo = line
            .replace(/^(작곡|작사|편곡|writers?|composer|lyricist|arranger)\s*[-:：]?\s*/i, '')
            .replace(/\s*PEERMUSIC\s*$/i, '') // 끝의 PEERMUSIC 제거
            .replace(/\s*\d+(\.\d+)?%/g, '') // 퍼센트 정보 제거
            .trim();
          if (creditInfo) {
            currentCredits.push(creditInfo);
          }
          continue;
        }

        // ========== 패턴 8: 이름 (괄호 정보) 형식 ==========
        // 예: "Elsa Søllesvik (Peermusic Artist Rights)"
        // 예: "Fabio Pizzoli (Peermusic Italy, Visionary Sapiens)"
        const nameWithParenthesesMatch = line.match(/^([A-ZÅ-Öa-zå-ö\s]+)\s*\(([^)]+)\)$/);
        if (nameWithParenthesesMatch && currentSong) {
          const name = nameWithParenthesesMatch[1].trim();
          const info = nameWithParenthesesMatch[2].trim();
          currentCredits.push(`${name} (${info})`);
          continue;
        }

        // ========== 패턴 9: 단순 이름 형식 ==========
        // 예: "Lasse Nymann", "Simon Janlov"
        // 조건: 현재 곡이 있고, 2-4개 단어로 구성되고, 각 단어가 대문자로 시작
        const simpleNameMatch = line.match(/^([A-ZÅ-Ö][a-zå-ö]+(?:\s[A-ZÅ-Ö][a-zå-ö]+){0,3})$/);
        if (simpleNameMatch && currentSong) {
          const name = simpleNameMatch[1].trim();
          // 파일 형식이 아니고, 일반 이름 형식이면 크레딧으로 추가
          if (!/\.(mp3|wav|m4a|flac|aiff)$/i.test(line) && !/@/.test(line) && !/BPM\d+/i.test(line)) {
            currentCredits.push(name);
            continue;
          }
        }

        if (!isKoreanCredit && !hasPercentage && !hasPeermusic && line.length > 0 && !/^Composer/i.test(line)) {
          // 파일명 형식 감지 (이국현,이동영,김민규_Summer, Some_BPM80_email.mp3)
          const isFilenameFormat = /\.(mp3|wav|m4a|flac|aiff)$/i.test(line) ||
                                   (/_/.test(line) && /@/.test(line)) ||
                                   (/_/.test(line) && /BPM\d+/i.test(line));

          // 이전 곡 저장 (줄 단위 저장 - 저작자 이름 보존)
          // creditSaved가 true이면 이미 Composer 패턴에서 저장했으므로 스킵
          if (currentSong && currentCredits.length > 0 && !creditSaved) {
            const uniqueCredits = [...new Set(currentCredits.map(c => c.trim()).filter(c => c))];
            credits[currentSong.toLowerCase()] = uniqueCredits.join(', ');
          }

          if (isFilenameFormat) {
            // 파일명에서 작곡가_곡명 파싱
            const cleanLine = line.replace(/\.(mp3|wav|m4a|flac|aiff)$/i, '').replace(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/gi, '');
            const parts = cleanLine.split('_').filter(p => p.trim());

            if (parts.length >= 2) {
              const firstPart = parts[0].trim();
              // 쉼표로 구분된 여러 이름 또는 한글 2-4자 → 작곡가
              const hasMultipleComposers = /[,\-]/.test(firstPart) && firstPart.split(/[,\-]/).length >= 2;
              const isSingleKoreanName = /^[가-힣]{2,4}$/.test(firstPart);

              if (hasMultipleComposers || isSingleKoreanName) {
                currentSong = parts[1].trim(); // 곡명
                currentCredits = [firstPart.replace(/[,\-]/g, ' ')]; // 작곡가들
              } else {
                currentSong = line;
                currentCredits = [];
              }
            } else {
              currentSong = line;
              currentCredits = [];
            }
          } else {
            // 일반 곡명
            currentSong = line;
            currentCredits = [];
          }
          creditSaved = false; // 새 곡 시작 시 플래그 리셋
        }
      }

      // 마지막 곡 저장 (줄 단위 저장 - 저작자 이름 보존)
      // creditSaved가 true이면 이미 저장되었으므로 스킵
      if (currentSong && currentCredits.length > 0 && !creditSaved) {
        const uniqueCredits = [...new Set(currentCredits.map(c => c.trim()).filter(c => c))];
        credits[currentSong.toLowerCase()] = uniqueCredits.join(', ');
      }

      console.log('parseCreditText 완료 - 저장된 곡:', Object.keys(credits));
      return { credits, sgOpNames };
    };

    const getScoreColor = (score) => {
      const colors = { '5.0': 'from-emerald-500 to-emerald-600', '4.5': 'from-blue-500 to-blue-600', '4.0': 'from-cyan-500 to-cyan-600', '3.5': 'from-purple-500 to-purple-600', '3.0': 'from-amber-500 to-amber-600', '2.5': 'from-orange-500 to-orange-600', '2.0': 'from-red-500 to-red-600', '1.5': 'from-gray-500 to-gray-600', '1.0': 'from-gray-400 to-gray-500' };
      return colors[score] || 'from-gray-300 to-gray-400';
    };

    const StarRating = React.memo(({ value, onChange }) => {
      const [hover, setHover] = useState(0);
      return (
        <div className="flex gap-1 items-center">
          {[1,2,3,4,5].map(i => (
            <span key={i} className={`star ${(hover || parseFloat(value) || 0) >= i ? 'filled' : 'empty'}`}
              onMouseEnter={() => setHover(i)} onMouseLeave={() => setHover(0)}
              onClick={() => onChange(i + '.0')}>{(hover || parseFloat(value) || 0) >= i ? '★' : '☆'}</span>
          ))}
          {value && <span className="ml-2 text-lg font-bold text-white">{value}</span>}
        </div>
      );
    });

    function DemoReviewSystem() {
      const [songs, setSongs] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [reviews, setReviews] = useState({});
      const [view, setView] = useState('upload'); // upload, credit, review, list
      const [artistName, setArtistName] = useState('');
      const [searchTerm, setSearchTerm] = useState('');
      const [filterStatus, setFilterStatus] = useState('all');
      const [creditText, setCreditText] = useState('');
      const [pendingSongs, setPendingSongs] = useState([]);
      const [presetVersion, setPresetVersion] = useState(0); // 프리셋 선택 시 증가하여 피드백 필드 재생성

      const folderInputRef = useRef(null);
      const creditTextRef = useRef('');
      const pathTextRef = useRef('');

      const STORAGE_KEY = 'peermusic_demo_reviews_v6';
      const SONGS_KEY = 'peermusic_demo_songs_v6';
      const META_KEY = 'peermusic_demo_meta_v6';
      const ARCHIVE_KEY = 'peermusic_demo_archive_v1';
      const [archivedSessions, setArchivedSessions] = useState([]);
      const [archiveSearch, setArchiveSearch] = useState('');
      const [archiveExpandedId, setArchiveExpandedId] = useState(null);
      const jsonImportRef = useRef(null);

      useEffect(() => {
        const savedReviews = localStorage.getItem(STORAGE_KEY);
        const savedSongs = localStorage.getItem(SONGS_KEY);
        const savedMeta = localStorage.getItem(META_KEY);
        const savedArchive = localStorage.getItem(ARCHIVE_KEY);
        if (savedReviews) try { setReviews(JSON.parse(savedReviews)); } catch (e) {}
        if (savedSongs) try { const s = JSON.parse(savedSongs); setSongs(s); if (s.length > 0) setView('review'); } catch (e) {}
        if (savedMeta) try { const m = JSON.parse(savedMeta); setArtistName(m.artistName || ''); } catch (e) {}
        if (savedArchive) try { setArchivedSessions(JSON.parse(savedArchive)); } catch (e) {}
      }, []);

      useEffect(() => { if (Object.keys(reviews).length > 0) localStorage.setItem(STORAGE_KEY, JSON.stringify(reviews)); }, [reviews]);
      useEffect(() => { if (songs.length > 0) localStorage.setItem(SONGS_KEY, JSON.stringify(songs)); }, [songs]);
      useEffect(() => { localStorage.setItem(META_KEY, JSON.stringify({ artistName })); }, [artistName]);
      useEffect(() => { localStorage.setItem(ARCHIVE_KEY, JSON.stringify(archivedSessions)); }, [archivedSessions]);

      const currentSong = songs[currentIndex] || null;
      const currentReview = currentSong ? (reviews[currentSong.id] || {
        피드백: '',
        장르: currentSong.장르 || '',  // 자동 추출된 장르 사용
        점수: '',
        OP명: currentSong.OP명,
        저작자: currentSong.저작자
      }) : null;
      const reviewedCount = useMemo(() => songs.filter(s => reviews[s.id]?.점수).length, [songs, reviews]);
      const progress = songs.length > 0 ? ((reviewedCount / songs.length) * 100).toFixed(0) : 0;

      const filteredSongs = useMemo(() => {
        return songs.filter(song => {
          const review = reviews[song.id] || {};
          const matchesSearch = song.곡명.toLowerCase().includes(searchTerm.toLowerCase()) ||
            song.저작자.toLowerCase().includes(searchTerm.toLowerCase()) ||
            (review.OP명 || song.OP명 || '').toLowerCase().includes(searchTerm.toLowerCase());
          if (filterStatus === 'reviewed') return matchesSearch && review?.점수;
          if (filterStatus === 'pending') return matchesSearch && !review?.점수;
          if (filterStatus === 'recommended') return matchesSearch && parseFloat(review?.점수 || 0) >= 4.0;
          return matchesSearch;
        });
      }, [songs, reviews, searchTerm, filterStatus]);

      // ★★★ 경로 붙여넣기 처리 (Windows 탐색기에서 "경로로 복사") ★★★
      const handlePathPaste = (pathText) => {
        if (!pathText.trim()) { alert('경로를 입력해주세요.'); return null; }
        const lines = pathText.split('\n').map(l => l.trim().replace(/^["']+|["']+$/g, '').trim()).filter(l => l);
        const audioLines = lines.filter(l => /\.(mp3|wav|m4a|flac|aiff)$/i.test(l));
        if (audioLines.length === 0) { alert('음원 파일 경로가 없습니다.\n\n지원 형식: MP3, WAV, M4A, FLAC, AIFF\n\n윈도우 탐색기에서 파일 선택 → 우클릭 → "경로로 복사"'); return null; }

        // 첫 번째 파일 경로에서 아티스트 추출
        const firstPath = audioLines[0];
        const detectedArtist = extractArtistFromPath(firstPath);
        if (detectedArtist && !artistName) setArtistName(detectedArtist);

        const newSongs = audioLines.map((fullPath, idx) => {
          // Windows 경로에서 파일명 추출: C:\Demo\GL Music\song.mp3 → song.mp3
          const filename = fullPath.replace(/\\/g, '/').split('/').pop() || fullPath;
          // 전체 경로에서 폴더 경로 추출
          const folderPath = fullPath.replace(/\\/g, '/').replace(/\/[^/]+$/, '');
          const parsed = parseFileName(filename, folderPath);

          // 전체 경로에서 날짜 추출 시도
          const extractedDate = extractDateFromPath(fullPath);
          const uploadDate = extractedDate || new Date().toISOString().split('T')[0];

          return {
            id: Date.now() + idx + Math.random(),
            곡명: parsed.songName,
            저작자: parsed.composer,
            OP명: parsed.opName,
            이메일: parsed.email,
            장르: parsed.genre || '',
            BPM: parsed.bpm || '',
            원본파일명: filename,
            원본경로: fullPath,
            업로드날짜: uploadDate,
            추가일시: new Date().toISOString()
          };
        });

        return newSongs;
      };

      // 경로 + 크레딧 통합 처리
      const handlePathAndCreditSubmit = () => {
        const pathText = pathTextRef.current || '';
        const creditTextVal = creditTextRef.current || '';

        const newSongs = handlePathPaste(pathText);
        if (!newSongs) return;

        // 크레딧이 있으면 바로 적용
        if (creditTextVal.trim()) {
          const { credits, sgOpNames } = parseCreditText(creditTextVal);
          console.log('=== 크레딧 파싱 시작 ===');
          console.log('파싱된 크레딧 (원본):', credits);
          console.log('곡명 개수:', Object.keys(credits).length);

          const normalizedCredits = {};
          for (const [key, value] of Object.entries(credits)) {
            normalizedCredits[normalizeSongName(key)] = value;
          }
          const normalizedSgOpNames = {};
          for (const [key, value] of Object.entries(sgOpNames)) {
            normalizedSgOpNames[normalizeSongName(key)] = value;
          }

          const matchResults = { matched: 0, unmatched: [] };
          const updatedSongs = newSongs.map(song => {
            const songNameNormalized = normalizeSongName(song.곡명);
            const matchedCredit = normalizedCredits[songNameNormalized];
            const matchedSgOp = normalizedSgOpNames[songNameNormalized];

            let updatedSong = { ...song };
            if (matchedSgOp) updatedSong.OP명 = matchedSgOp;
            if (matchedCredit) {
              updatedSong.저작자 = matchedCredit;
              matchResults.matched++;
              if (!updatedSong.OP명) {
                const firstComposer = matchedCredit.split(/[,/]/)[0].trim();
                const composerOP = getOPFromComposer(firstComposer);
                if (composerOP) updatedSong.OP명 = composerOP;
              }
            } else {
              matchResults.unmatched.push(song.곡명);
            }
            return updatedSong;
          });

          console.log('=== 크레딧 매칭 결과 ===');
          console.log('매칭 성공:', matchResults.matched, '/ 전체:', updatedSongs.length);
          console.log('미매칭 곡명:', matchResults.unmatched);
          console.log('---');
          console.log('정규화된 크레딧 키:', Object.keys(normalizedCredits));
          console.log('정규화된 파일 곡명:', updatedSongs.map(s => normalizeSongName(s.곡명)));
          console.log('---');
          console.log('상세 매칭 분석:');
          updatedSongs.forEach((song, idx) => {
            const normalized = normalizeSongName(song.곡명);
            const matched = normalizedCredits[normalized];
            console.log(`${idx + 1}. "${song.곡명}" → normalize: "${normalized}" → ${matched ? '✓ 매칭됨' : '✗ 미매칭'}`);
          });
          console.log('======================');

          setSongs(prev => [...prev, ...updatedSongs]);

          let alertMsg = `${updatedSongs.length}곡이 추가되었습니다.\n크레딧 매칭: ${matchResults.matched}곡`;
          if (matchResults.unmatched.length > 0) {
            alertMsg += `\n미매칭: ${matchResults.unmatched.slice(0, 3).join(', ')}`;
            if (matchResults.unmatched.length > 3) alertMsg += ` 외 ${matchResults.unmatched.length - 3}곡`;
          }
          alert(alertMsg);
        } else {
          setSongs(prev => [...prev, ...newSongs]);
          alert(`${newSongs.length}곡이 추가되었습니다.`);
        }

        // 초기화
        pathTextRef.current = '';
        creditTextRef.current = '';
        setView('review');
      };

      // 폴더 업로드 처리
      const handleFolderUpload = async (files) => {
        const audioFiles = Array.from(files).filter(f => {
          const isAudio = /\.(mp3|wav|m4a|flac|aiff)$/i.test(f.name);
          const isMacOS = f.webkitRelativePath?.includes('__MACOSX') || f.name.startsWith('._');
          return isAudio && !isMacOS;
        });

        if (audioFiles.length === 0) {
          alert('음원 파일이 없습니다.\n\n지원 형식: MP3, WAV, M4A, FLAC, AIFF');
          return;
        }

        const firstPath = audioFiles[0].webkitRelativePath || '';
        const detectedArtist = extractArtistFromPath(firstPath);
        if (detectedArtist && !artistName) setArtistName(detectedArtist);

        const newSongs = audioFiles.map((file, idx) => {
          const path = file.webkitRelativePath || file.name;
          const parsed = parseFileName(file.name, path);

          // 폴더 경로에서 날짜 추출 시도, 없으면 파일 수정일 사용
          const extractedDate = extractDateFromPath(path);
          const uploadDate = extractedDate || formatDate(file.lastModified);

          return {
            id: Date.now() + idx + Math.random(),
            곡명: parsed.songName,
            저작자: parsed.composer,
            OP명: parsed.opName,
            이메일: parsed.email,
            장르: parsed.genre || '',  // 자동 추출된 장르
            BPM: parsed.bpm || '',     // 자동 추출된 BPM
            원본파일명: file.name,
            원본경로: path,
            업로드날짜: uploadDate,
            추가일시: new Date().toISOString()
          };
        });

        // 크레딧 입력 화면으로 이동
        setPendingSongs(newSongs);
        setView('credit');
      };

      // 곡명 정규화 (특수문자 통일, 공백 정리, URL/접미사 제거)
      const normalizeSongName = (name) => {
        return name
          .toLowerCase()
          // URL 패턴 제거 (www., http://, https:// 등)
          .replace(/\s*[-–]\s*(www\.|http:\/\/|https:\/\/)[\w./-]+/gi, '')
          // 이메일 패턴 제거
          .replace(/\s*[-–]?\s*[\w._%+-]+@[\w.-]+\.[a-zA-Z]{2,}/gi, '')
          // 어포스트로피 통일 (모든 유니코드 변형)
          .replace(/[´`''ʼ]/g, "'")
          // 따옴표 통일
          .replace(/[""]/g, '"')
          // DEMO, AR, MR, INST 제거
          .replace(/[\s_-]*demo[\s_#\d]*/gi, '')
          .replace(/\s+(ar|mr|inst)$/i, '')
          // (가제), (데모) 등 괄호 부가정보 제거
          .replace(/\s*\([^)]*[가제데모demo][^)]*\)/gi, '')
          // 파일 확장자 제거
          .replace(/\.(mp3|wav|m4a|flac|aiff)$/i, '')
          // 특수문자 정규화 (하이픈/대시/언더스코어 통일)
          .replace(/[–—_]/g, '-')
          // 연속된 하이픈 정리
          .replace(/-+/g, '-')
          // 공백 정리
          .replace(/\s+/g, ' ')
          .trim();
      };

      // 크레딧 적용 및 검토 시작
      const applyCreditsAndStart = () => {
        let updatedSongs = [...pendingSongs];
        const textToUse = creditTextRef.current || creditText;

        if (textToUse.trim()) {
          const { credits, sgOpNames } = parseCreditText(textToUse);
          console.log('파싱된 크레딧:', credits);
          console.log('파싱된 SG OP명:', sgOpNames);

          // 정규화된 키로 크레딧 맵 재생성
          const normalizedCredits = {};
          for (const [key, value] of Object.entries(credits)) {
            const normalized = normalizeSongName(key);
            normalizedCredits[normalized] = value;
            console.log(`크레딧 정규화: "${key}" → "${normalized}"`);
          }

          // 정규화된 키로 SG OP명 맵 재생성
          const normalizedSgOpNames = {};
          for (const [key, value] of Object.entries(sgOpNames)) {
            const normalized = normalizeSongName(key);
            normalizedSgOpNames[normalized] = value;
          }

          updatedSongs = pendingSongs.map(song => {
            const songNameNormalized = normalizeSongName(song.곡명);
            const matchedCredit = normalizedCredits[songNameNormalized];
            const matchedSgOp = normalizedSgOpNames[songNameNormalized];

            console.log(`곡명 매칭 시도: "${song.곡명}" → "${songNameNormalized}" → ${matchedCredit ? '매칭 성공' : '매칭 실패'}`);

            let updatedSong = { ...song };

            // SG OP명 적용
            if (matchedSgOp) {
              updatedSong.OP명 = matchedSgOp;
              updatedSong.이메일 = 'shun@soundgraphics.net';
            }

            // 저작자 정보 적용
            if (matchedCredit) {
              updatedSong.저작자 = matchedCredit;
            }

            return updatedSong;
          });
        }

        setSongs(prev => [...prev, ...updatedSongs]);
        setPendingSongs([]);
        setCreditText('');
        creditTextRef.current = '';
        setView('review');
        alert(`${updatedSongs.length}곡이 추가되었습니다.`);
      };

      // 크레딧 없이 진행
      const skipCredits = () => {
        setSongs(prev => [...prev, ...pendingSongs]);
        setPendingSongs([]);
        setCreditText('');
        creditTextRef.current = '';
        setView('review');
        alert(`${pendingSongs.length}곡이 추가되었습니다.`);
      };

      const handleUpdate = (field, value) => {
        if (!currentSong) return;
        setReviews(prev => ({ ...prev, [currentSong.id]: { ...currentReview, [field]: value } }));
      };

      const goNext = () => { if (currentIndex < songs.length - 1) setCurrentIndex(currentIndex + 1); };
      const goPrev = () => { if (currentIndex > 0) setCurrentIndex(currentIndex - 1); };
      const goToSong = (idx) => { setCurrentIndex(idx); setView('review'); };
      const deleteSong = (id) => {
        if (confirm('삭제하시겠습니까?')) {
          setSongs(prev => prev.filter(s => s.id !== id));
          setReviews(prev => { const n = { ...prev }; delete n[id]; return n; });
          if (currentIndex >= songs.length - 1) setCurrentIndex(Math.max(0, songs.length - 2));
        }
      };

      // CSV 다운로드
      const downloadCSV = () => {
        try {
          const allData = songs.map(song => {
            const review = reviews[song.id] || {};
            const opName = review.OP명 || song.OP명 || '';
            const composerInfo = review.저작자 || song.저작자 || '';

            return {
              '음원업로드날짜': song.업로드날짜 || new Date().toISOString().split('T')[0],
              '저작자 정보': composerInfo,
              '원본 데모 작품명': song.곡명,
              'PITCHING 데모': `${song.곡명}_${opName}_Pitched by MC`,
              'OP명 / 작가명': opName,
              'Genre': review.장르 || '',
              'Tag(Note)': review.피드백 || '',
              'Note(선호도)': review.점수 ? `${review.점수}/5` : '',
              '이메일 주소': review.이메일 || song.이메일 || '',
              '피칭 아티스트': artistName
            };
          });

          const convertToCSV = (data) => {
            if (data.length === 0) return '';
            const headers = Object.keys(data[0]);
            const csvRows = [headers.join(',')];
            for (const row of data) {
              const values = headers.map(h => {
                const v = String(row[h] || '');
                return (v.includes(',') || v.includes('"') || v.includes('\n')) ? `"${v.replace(/"/g, '""')}"` : v;
              });
              csvRows.push(values.join(','));
            }
            return csvRows.join('\n');
          };

          const BOM = '\uFEFF';
          const today = new Date().toISOString().split('T')[0].replace(/-/g, '.');

          const blob = new Blob([BOM + convertToCSV(allData)], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = `${artistName || 'DEMO'}_전체DEMO_${today}.csv`;
          link.click();

          const recommended = allData.filter((_, i) => parseFloat(reviews[songs[i].id]?.점수 || 0) >= 4.0);
          if (recommended.length > 0) {
            setTimeout(() => {
              const blob2 = new Blob([BOM + convertToCSV(recommended)], { type: 'text/csv;charset=utf-8;' });
              const link2 = document.createElement('a');
              link2.href = URL.createObjectURL(blob2);
              link2.download = `${artistName || 'DEMO'}_추천DEMO_${today}.csv`;
              link2.click();
            }, 500);
          }

          alert(`다운로드 완료\n전체: ${allData.length}곡 | 추천: ${recommended.length}곡`);
        } catch (error) { alert('다운로드 실패: ' + error.message); }
      };

      // ★★★ 세션 아카이브 (완료된 리뷰 데이터 영구 저장) ★★★
      const archiveCurrentSession = () => {
        if (songs.length === 0) { alert('저장할 데이터가 없습니다.'); return; }
        const today = new Date().toISOString().split('T')[0];
        const sessionData = {
          id: Date.now(),
          날짜: today,
          아티스트: artistName || '미지정',
          총곡수: songs.length,
          완료곡수: songs.filter(s => reviews[s.id]?.점수).length,
          추천곡수: songs.filter(s => parseFloat(reviews[s.id]?.점수 || 0) >= 4.0).length,
          songs: songs.map(song => {
            const review = reviews[song.id] || {};
            return {
              곡명: song.곡명,
              저작자: review.저작자 || song.저작자 || '',
              OP명: review.OP명 || song.OP명 || '',
              이메일: review.이메일 || song.이메일 || '',
              장르: review.장르 || song.장르 || '',
              BPM: song.BPM || '',
              점수: review.점수 || '',
              피드백: review.피드백 || '',
              원본파일명: song.원본파일명 || '',
              업로드날짜: song.업로드날짜 || today
            };
          })
        };
        setArchivedSessions(prev => {
          const updated = [sessionData, ...prev];
          // 저장 후 백업 권장 (5개 세션마다)
          if (updated.length % 5 === 0) {
            setTimeout(() => {
              if (confirm(`✅ "${sessionData.아티스트}" 세션이 저장되었습니다!\n\n⚠️ 현재 ${updated.length}개의 세션이 브라우저에만 저장되어 있습니다.\n데이터 손실 방지를 위해 JSON 백업을 권장합니다.\n\n지금 백업하시겠습니까?`)) {
                exportArchiveJSON();
              }
            }, 100);
          } else {
            alert(`✅ "${sessionData.아티스트}" 세션 (${sessionData.총곡수}곡) 저장 완료!\n\n💡 브라우저 로컬 저장소에만 저장됩니다.\n정기적으로 JSON 백업을 권장합니다.`);
          }
          return updated;
        });
      };

      // JSON 내보내기 (전체 아카이브 백업)
      const exportArchiveJSON = () => {
        const data = { exportDate: new Date().toISOString(), sessions: archivedSessions };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `PEERMUSIC_Archive_${new Date().toISOString().split('T')[0]}.json`;
        link.click();
      };

      // JSON 가져오기 (아카이브 복원)
      const importArchiveJSON = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const data = JSON.parse(ev.target.result);
            if (data.sessions && Array.isArray(data.sessions)) {
              setArchivedSessions(prev => {
                const existingIds = new Set(prev.map(s => s.id));
                const newSessions = data.sessions.filter(s => !existingIds.has(s.id));
                return [...newSessions, ...prev];
              });
              alert(`${data.sessions.length}개 세션 가져오기 완료!`);
            }
          } catch (err) { alert('파일 형식이 올바르지 않습니다.'); }
        };
        reader.readAsText(file);
      };

      // HTML/PDF 내보내기는 별도 JS 파일로 분리 예정 - 현재는 CSV만 지원
      const exportSessionHTML = () => { alert('HTML 내보내기는 CSV를 이용해주세요.'); };
      const exportSessionPDF = () => { alert('PDF 내보내기는 CSV를 이용해주세요.'); };
      const exportCurrentSession = () => { alert('CSV 내보내기를 이용해주세요.'); };

      // 아카이브 세션 삭제
      const deleteArchivedSession = (sessionId) => {
        if (confirm('이 세션을 삭제하시겠습니까?')) {
          setArchivedSessions(prev => prev.filter(s => s.id !== sessionId));
        }
      };

      // 아카이브에서 검색
      const searchArchive = (term) => {
        if (!term) return archivedSessions;
        const lower = term.toLowerCase();
        return archivedSessions.filter(session =>
          session.아티스트.toLowerCase().includes(lower) ||
          session.날짜.includes(lower) ||
          session.songs.some(s =>
            (s.곡명 || '').toLowerCase().includes(lower) ||
            (s.저작자 || '').toLowerCase().includes(lower) ||
            (s.OP명 || '').toLowerCase().includes(lower)
          )
        );
      };

      const resetAll = () => {
        if (confirm('모든 데이터를 초기화하시겠습니까? (아카이브 데이터는 유지됩니다)')) {
          setSongs([]); setReviews({}); setCurrentIndex(0); setView('upload'); setArtistName('');
          localStorage.removeItem(STORAGE_KEY); localStorage.removeItem(SONGS_KEY);
        }
      };

      // PathTextArea - 경로 붙여넣기용 독립 컴포넌트
      const PathTextArea = React.memo(({ textRef }) => {
        const [localValue, setLocalValue] = useState('');
        const handleChange = (e) => { const v = e.target.value; setLocalValue(v); textRef.current = v; };
        // 붙여넣기 시 줄 수 카운트
        const lineCount = localValue.split('\n').filter(l => /\.(mp3|wav|m4a|flac|aiff)$/i.test(l.trim())).length;
        return (
          <div className="relative">
            <textarea value={localValue} onChange={handleChange}
              className="w-full h-48 bg-black/50 text-gray-300 px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500 resize-none font-mono text-sm"
              placeholder={`윈도우 탐색기에서 파일 선택 → 우클릭 → "경로로 복사" 후 여기에 붙여넣기

예시:
C:\\Users\\demo\\GL Music\\Vendetta.mp3
C:\\Users\\demo\\GL Music\\Sugar.mp3
C:\\Users\\demo\\Wavecandy\\JETSKI.mp3`} />
            {lineCount > 0 && (
              <span className="absolute top-2 right-3 text-xs text-indigo-400 bg-black/60 px-2 py-1 rounded">{lineCount}곡 감지</span>
            )}
          </div>
        );
      });

      // 업로드 화면 (통합: 경로 붙여넣기 + 크레딧 + 폴더 업로드)
      const UploadView = () => (
        <div className="min-h-screen flex items-center justify-center p-6 fade-in">
          <div className="w-full max-w-3xl">
            <div className="text-center mb-8">
              <h1 className="text-5xl font-bold gradient-text mb-2">PEERMUSIC</h1>
              <p className="text-gray-500 text-lg">DEMO Review System</p>
            </div>

            {/* 1. 파일 경로 붙여넣기 (메인 입력) */}
            <div className="glass rounded-2xl p-6 mb-4">
              <h3 className="text-white font-semibold mb-2">1. 파일 경로 붙여넣기</h3>
              <p className="text-gray-500 text-sm mb-3">
                윈도우 탐색기에서 음원 파일 선택 → 우클릭 → "경로로 복사" → 여기에 붙여넣기
              </p>
              <PathTextArea textRef={pathTextRef} />
            </div>

            {/* 2. 추가 크레딧 정보 */}
            <div className="glass rounded-2xl p-6 mb-4">
              <h3 className="text-white font-semibold mb-2">2. 추가 크레딧 정보 (선택사항)</h3>
              <p className="text-gray-500 text-sm mb-3">
                곡명 + 작곡/작사/편곡 정보, Track Title 형식, 번호 리스트 등
              </p>
              <CreditTextArea textRef={creditTextRef} />
            </div>

            {/* 검토 시작 버튼 */}
            <button onClick={handlePathAndCreditSubmit}
              className="w-full btn-primary py-4 rounded-xl text-white font-semibold text-lg mb-4">
              검토 시작 →
            </button>

            {/* 저장된 데이터가 있으면 이어서 검토 */}
            {songs.length > 0 && (
              <div className="glass rounded-2xl p-5 text-center mb-4">
                <p className="text-gray-400 mb-3">저장된 데이터: <span className="text-white font-bold">{songs.length}곡</span> ({reviewedCount}곡 완료)</p>
                <div className="flex gap-3 justify-center flex-wrap">
                  <button onClick={() => setView('review')} className="btn-primary px-8 py-3 rounded-xl text-white font-medium">
                    이어서 검토하기 →
                  </button>
                  <button onClick={resetAll} className="px-6 py-3 rounded-xl bg-red-500/20 text-red-400 hover:bg-red-500/30 font-medium border border-red-500/30">
                    🗑️ 초기화
                  </button>
                </div>
              </div>
            )}

            {archivedSessions.length > 0 && (
              <div className="glass rounded-2xl p-4 text-center">
                <button onClick={() => setView('archive')} className="text-purple-400 hover:text-purple-300 font-medium">
                  📦 아카이브 ({archivedSessions.length}개 세션, {archivedSessions.reduce((sum, s) => sum + s.songs.length, 0)}곡)
                </button>
              </div>
            )}
          </div>
        </div>
      );

      const CreditView = () => (
        <div className="min-h-screen flex items-center justify-center p-6 fade-in">
          <div className="w-full max-w-3xl">
            <div className="text-center mb-8">
              <h1 className="text-3xl font-bold text-white mb-2">크레딧 정보 입력</h1>
              <p className="text-gray-500">폴더 업로드 {pendingSongs.length}곡 - 추가 저작자 정보를 입력하세요</p>
            </div>

            {/* 업로드된 곡 목록 */}
            <div className="glass rounded-2xl p-4 mb-6 max-h-48 overflow-y-auto">
              <h3 className="text-sm font-medium text-gray-400 mb-3">감지된 곡 목록 ({pendingSongs.length}곡)</h3>
              <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                {pendingSongs.map((song, idx) => (
                  <div key={idx} className="credit-item px-3 py-2 rounded-lg text-sm">
                    <span className="text-white">{song.곡명}</span>
                    {song.저작자 && <span className="text-gray-500 text-xs block">{song.저작자}</span>}
                  </div>
                ))}
              </div>
            </div>

            {/* 크레딧 입력 */}
            <div className="glass rounded-2xl p-6 mb-6">
              <h3 className="text-white font-medium mb-3">추가 크레딧 정보 (선택사항)</h3>
              <p className="text-gray-500 text-sm mb-4">
                곡명 + 작곡/작사/편곡 정보를 붙여넣으면 자동 매칭됩니다
              </p>
              <CreditTextArea textRef={creditTextRef} />
            </div>

            {/* 버튼 */}
            <div className="flex gap-4">
              <button
                onClick={() => { setPendingSongs([]); setCreditText(''); creditTextRef.current = ''; setView('upload'); }}
                className="flex-1 btn-secondary py-4 rounded-xl text-gray-300 font-medium"
              >
                ← 취소
              </button>
              <button
                onClick={skipCredits}
                className="flex-1 btn-secondary py-4 rounded-xl text-gray-300 font-medium"
              >
                건너뛰기
              </button>
              <button
                onClick={applyCreditsAndStart}
                className="flex-1 btn-primary py-4 rounded-xl text-white font-medium"
              >
                적용 및 검토 시작 →
              </button>
            </div>
          </div>
        </div>
      );

      // 검토 화면
      const ReviewView = () => {
        if (!currentSong) return (
          <div className="min-h-screen flex items-center justify-center">
            <div className="text-center">
              <p className="text-xl text-gray-500 mb-4">검토할 곡이 없습니다</p>
              <button onClick={() => setView('upload')} className="btn-primary px-6 py-3 rounded-xl text-white">곡 추가</button>
            </div>
          </div>
        );

        return (
          <div className="max-w-5xl mx-auto p-4 md:p-6 fade-in">
            <div className="glass rounded-2xl p-4 mb-4">
              <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
                <div className="flex items-center gap-4">
                  <button onClick={() => setView('upload')} className="p-2 hover:bg-white/10 rounded-lg text-gray-400 hover:text-white">🏠</button>
                  <div>
                    <StableInput
                      key={`artist-${artistName ? 'set' : 'empty'}`}
                      initialValue={artistName}
                      onValueChange={(v) => setArtistName(v)}
                      className="text-xl font-bold text-white bg-transparent border-b border-transparent hover:border-gray-600 focus:border-indigo-500 outline-none"
                      placeholder="아티스트명 입력"
                    />
                    <p className="text-sm text-gray-500">{songs.length}곡</p>
                  </div>
                </div>
                <div className="flex items-center gap-3">
                  <button onClick={() => setView('list')} className="px-4 py-2 rounded-lg text-gray-400 hover:text-white hover:bg-white/10">📋 목록</button>
                  <button onClick={() => setView('archive')} className="px-4 py-2 rounded-lg text-gray-400 hover:text-white hover:bg-white/10">📦 아카이브</button>
                  <button onClick={downloadCSV} className="btn-primary px-4 py-2 rounded-lg text-white font-medium">📥 CSV</button>
                </div>
              </div>
              <div className="mt-4">
                <div className="flex justify-between text-sm mb-1">
                  <span className="text-gray-500">진행률</span>
                  <span className="text-white font-medium">{reviewedCount} / {songs.length} ({progress}%)</span>
                </div>
                <div className="h-1.5 bg-gray-800 rounded-full overflow-hidden">
                  <div className="h-full bg-gradient-to-r from-indigo-500 to-purple-500 transition-all" style={{ width: `${progress}%` }} />
                </div>
              </div>
            </div>

            <div className="flex gap-4 items-stretch">
              <button onClick={goPrev} disabled={currentIndex === 0}
                className="nav-button hidden md:flex items-center justify-center w-14 glass rounded-2xl hover:bg-white/5 text-gray-400 hover:text-white"
                style={{ '--direction': '-5px' }}><span className="text-2xl">←</span></button>

              <div className="flex-1 glass rounded-3xl p-6 md:p-8">
                <div className="text-center mb-6">
                  <span className="inline-block px-3 py-1 bg-indigo-500/20 text-indigo-400 rounded-full text-sm font-medium mb-3">#{currentIndex + 1}</span>
                  <h2 className="text-3xl md:text-4xl font-bold text-white mb-1">{currentSong.곡명}</h2>
                  <p className="text-gray-500 text-sm break-all">{currentSong.업로드날짜} | {currentSong.원본파일명}</p>
                </div>

                <div className="space-y-5">
                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-2">저작자 정보</label>
                    <StableInput
                      key={`composer-${currentSong?.id}`}
                      initialValue={currentReview.저작자 ?? currentSong.저작자 ?? ''}
                      onValueChange={(v) => handleUpdate('저작자', v)}
                      className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                      placeholder="예: OneTop, Zeenan"
                    />
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-400 mb-2">OP명 / 작가명</label>
                      <StableInput
                        key={`op-${currentSong?.id}`}
                        initialValue={currentReview.OP명 ?? currentSong.OP명 ?? ''}
                        onValueChange={(v) => handleUpdate('OP명', v)}
                        className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                        placeholder="예: OneTop, SJJ"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-400 mb-2">이메일</label>
                      <StableInput
                        key={`email-${currentSong?.id}`}
                        initialValue={currentReview.이메일 ?? currentSong.이메일 ?? ''}
                        onValueChange={(v) => handleUpdate('이메일', v)}
                        className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                        placeholder="이메일 주소"
                      />
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-3 text-center">선호도</label>
                    <div className="flex justify-center"><StarRating value={currentReview.점수} onChange={(v) => handleUpdate('점수', v)} /></div>
                    <div className="flex flex-wrap justify-center gap-2 mt-3">
                      {SCORES.map(s => (
                        <button key={s} onClick={() => handleUpdate('점수', s)}
                          className={`px-3 py-1 rounded-lg text-sm font-medium transition-all ${currentReview.점수 === s ? `bg-gradient-to-r ${getScoreColor(s)} text-white` : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>{s}</button>
                      ))}
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-2">Genre</label>
                    <select value={GENRE_PRESETS.includes(currentReview.장르) ? currentReview.장르 : ''}
                      onChange={(e) => {
                        if (e.target.value) {
                          handleUpdate('장르', e.target.value);
                        }
                      }}
                      className="w-full bg-black/50 text-white px-4 py-3 rounded-xl border border-gray-700 focus:border-indigo-500 mb-2">
                      <option value="">장르 선택</option>
                      {GENRE_PRESETS.map(g => <option key={g} value={g}>{g}</option>)}
                    </select>
                    <StableInput
                      key={`genre-${currentSong?.id}`}
                      initialValue={currentReview.장르 || ''}
                      onValueChange={(v) => handleUpdate('장르', v)}
                      className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                      placeholder="또는 직접 입력: 발라드, 어쿠스틱 팝, POP BALLAD"
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-2">Tag(Note)</label>
                    <select value={FEEDBACK_PRESETS.includes(currentReview.피드백) ? currentReview.피드백 : ''}
                      onChange={(e) => {
                        if (e.target.value) {
                          handleUpdate('피드백', e.target.value);
                          setPresetVersion(v => v + 1); // 피드백 필드 재생성
                        }
                      }}
                      className="w-full bg-black/50 text-white px-4 py-3 rounded-xl border border-gray-700 focus:border-indigo-500 mb-2">
                      <option value="">프리셋 선택</option>
                      {FEEDBACK_PRESETS.map(p => <option key={p} value={p}>{p}</option>)}
                    </select>
                    <StableTextarea
                      key={`feedback-${currentSong?.id}-${presetVersion}`}
                      initialValue={currentReview.피드백 || ''}
                      onValueChange={(v) => handleUpdate('피드백', v)}
                      className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500 resize-none"
                      rows={2}
                      placeholder="피드백 입력..."
                    />
                  </div>

                  {parseFloat(currentReview.점수 || 0) >= 4.0 && (
                    <div className="text-center">
                      <span className="inline-block px-4 py-2 bg-gradient-to-r from-rose-500 to-pink-500 text-white rounded-xl font-bold">❤️ 추천곡</span>
                    </div>
                  )}
                </div>

                <div className="flex md:hidden gap-3 mt-6">
                  <button onClick={goPrev} disabled={currentIndex === 0} className="flex-1 py-3 bg-gray-800 rounded-xl text-white disabled:opacity-40">← 이전</button>
                  <button onClick={goNext} disabled={currentIndex === songs.length - 1} className="flex-1 py-3 btn-primary rounded-xl text-white disabled:opacity-40">다음 →</button>
                </div>
              </div>

              <button onClick={goNext} disabled={currentIndex === songs.length - 1}
                className="nav-button hidden md:flex items-center justify-center w-14 glass rounded-2xl hover:bg-white/5 text-gray-400 hover:text-white"
                style={{ '--direction': '5px' }}><span className="text-2xl">→</span></button>
            </div>

            <div className="mt-4 glass rounded-xl p-4">
              <div className="flex items-center justify-between">
                <button onClick={() => setCurrentIndex(0)} className="text-sm text-gray-500 hover:text-white">⏮️</button>
                <div className="flex items-center gap-2">
                  <input type="number" min={1} max={songs.length} value={currentIndex + 1}
                    onChange={(e) => { const i = parseInt(e.target.value) - 1; if (i >= 0 && i < songs.length) setCurrentIndex(i); }}
                    className="w-14 bg-black/30 text-white text-center px-2 py-1 rounded-lg border border-gray-800" />
                  <span className="text-gray-500">/ {songs.length}</span>
                </div>
                <button onClick={() => setCurrentIndex(songs.length - 1)} className="text-sm text-gray-500 hover:text-white">⏭️</button>
              </div>
            </div>
          </div>
        );
      };

      // 목록 화면
      const ListView = () => (
        <div className="max-w-6xl mx-auto p-4 md:p-6 fade-in">
          <div className="glass rounded-2xl p-4 mb-4">
            <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
              <div className="flex items-center gap-4">
                <button onClick={() => setView('review')} className="text-gray-400 hover:text-white">← 검토</button>
                <h1 className="text-xl font-bold text-white">전체 목록 ({filteredSongs.length}곡)</h1>
              </div>
              <div className="flex gap-2 flex-wrap">
                <button onClick={downloadCSV} className="btn-primary px-3 py-2 rounded-lg text-white font-medium text-sm">📥 CSV</button>
                <button onClick={archiveCurrentSession} className="px-3 py-2 rounded-lg bg-emerald-500/20 text-emerald-400 hover:bg-emerald-500/30 text-sm font-medium">💾 저장</button>
                <button onClick={() => setView('archive')} className="px-3 py-2 rounded-lg bg-purple-500/20 text-purple-400 hover:bg-purple-500/30 text-sm font-medium">📦 아카이브</button>
                <button onClick={resetAll} className="px-3 py-2 rounded-lg bg-red-500/20 text-red-400 hover:bg-red-500/30 text-sm font-medium">🗑️ 초기화</button>
              </div>
            </div>
          </div>

          <div className="glass rounded-2xl p-4 mb-4">
            <div className="flex flex-col md:flex-row gap-4">
              <input
                type="text"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="flex-1 bg-black/30 text-white px-4 py-2 rounded-xl border border-gray-800 focus:border-indigo-500"
                placeholder="🔍 검색..."
              />
              <div className="flex gap-2">
                {[{ k: 'all', l: '전체' }, { k: 'reviewed', l: '완료' }, { k: 'pending', l: '미검토' }, { k: 'recommended', l: '추천' }].map(({ k, l }) => (
                  <button key={k} onClick={() => setFilterStatus(k)}
                    className={`px-4 py-2 rounded-xl font-medium ${filterStatus === k ? 'btn-primary text-white' : 'bg-gray-800 text-gray-400'}`}>{l}</button>
                ))}
              </div>
            </div>
          </div>

          <div className="glass rounded-2xl overflow-hidden">
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead className="bg-black/30">
                  <tr>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">#</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">곡명</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">저작자</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">OP명</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">날짜</th>
                    <th className="px-4 py-3 text-center text-sm font-medium text-gray-400">점수</th>
                    <th className="px-4 py-3 text-center text-sm font-medium text-gray-400"></th>
                  </tr>
                </thead>
                <tbody>
                  {filteredSongs.map(song => {
                    const review = reviews[song.id] || {};
                    const idx = songs.findIndex(s => s.id === song.id);
                    const isRec = parseFloat(review.점수 || 0) >= 4.0;
                    return (
                      <tr key={song.id} className="border-t border-gray-800 hover:bg-white/5">
                        <td className="px-4 py-3 text-sm text-gray-500">{idx + 1}</td>
                        <td className="px-4 py-3">
                          <button onClick={() => goToSong(idx)} className="text-indigo-400 hover:underline">{song.곡명}</button>
                          {isRec && <span className="ml-2">❤️</span>}
                        </td>
                        <td className="px-4 py-3 text-sm text-gray-400">{review.저작자 || song.저작자 || '-'}</td>
                        <td className="px-4 py-3 text-sm text-gray-400">{review.OP명 || song.OP명 || '-'}</td>
                        <td className="px-4 py-3 text-sm text-gray-500">{song.업로드날짜}</td>
                        <td className="px-4 py-3 text-center">
                          {review.점수 && <span className={`px-2 py-1 rounded-full text-xs font-bold text-white bg-gradient-to-r ${getScoreColor(review.점수)}`}>{review.점수}</span>}
                        </td>
                        <td className="px-4 py-3 text-center">
                          <button onClick={() => deleteSong(song.id)} className="text-red-400 hover:text-red-300">🗑️</button>
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>

          <div className="mt-4 grid grid-cols-4 gap-4">
            {[{ n: songs.length, l: '전체', c: 'text-indigo-400' }, { n: reviewedCount, l: '완료', c: 'text-emerald-400' },
              { n: songs.length - reviewedCount, l: '미검토', c: 'text-amber-400' },
              { n: songs.filter(s => parseFloat(reviews[s.id]?.점수 || 0) >= 4.0).length, l: '추천', c: 'text-rose-400' }
            ].map(({ n, l, c }) => (
              <div key={l} className="glass rounded-xl p-4 text-center">
                <div className={`text-2xl font-bold ${c}`}>{n}</div>
                <div className="text-sm text-gray-500">{l}</div>
              </div>
            ))}
          </div>
        </div>
      );

      // ★★★ 아카이브 화면 (저장된 세션 관리, 검색, 내보내기) ★★★
      const ArchiveView = () => {
        const filtered = searchArchive(archiveSearch);
        const expandedId = archiveExpandedId;
        const setExpandedId = setArchiveExpandedId;
        const jsonInputRef = jsonImportRef;

        return (
          <div className="max-w-6xl mx-auto p-4 md:p-6 fade-in">
            {/* 저장 위치 경고 메시지 */}
            <div className="glass rounded-2xl p-4 mb-4 border-l-4 border-yellow-500">
              <div className="flex items-start gap-3">
                <span className="text-2xl">⚠️</span>
                <div className="flex-1">
                  <h3 className="text-yellow-400 font-bold mb-2">데이터 저장 위치 안내</h3>
                  <p className="text-sm text-gray-300 mb-2">
                    아카이브 데이터는 <strong className="text-white">현재 브라우저의 로컬 저장소</strong>에만 저장됩니다.
                  </p>
                  <ul className="text-xs text-gray-400 space-y-1 mb-3">
                    <li>❌ 다른 브라우저(Chrome/Edge/Firefox)에서 접근 불가</li>
                    <li>❌ 다른 컴퓨터에서 접근 불가</li>
                    <li>❌ 브라우저 캐시/쿠키 삭제 시 데이터 손실</li>
                    <li>❌ 시크릿 모드에서는 별도 저장</li>
                  </ul>
                  <div className="flex gap-2 flex-wrap">
                    <button onClick={exportArchiveJSON} disabled={archivedSessions.length === 0}
                      className="px-3 py-1.5 rounded-lg bg-emerald-500/20 text-emerald-400 hover:bg-emerald-500/30 disabled:opacity-40 text-xs font-bold border border-emerald-500/30">
                      ✅ 정기적으로 JSON 백업하기
                    </button>
                    <span className="text-xs text-gray-500 self-center">← 중요한 데이터는 반드시 백업하세요!</span>
                  </div>
                </div>
              </div>
            </div>

            <div className="glass rounded-2xl p-4 mb-4">
              <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
                <div className="flex items-center gap-4">
                  <button onClick={() => setView(songs.length > 0 ? 'review' : 'upload')} className="text-gray-400 hover:text-white">← 돌아가기</button>
                  <h1 className="text-xl font-bold text-white">데이터 아카이브 ({archivedSessions.length}개 세션)</h1>
                </div>
                <div className="flex gap-2 flex-wrap">
                  <button onClick={archiveCurrentSession} disabled={songs.length === 0}
                    className="px-3 py-2 rounded-lg bg-emerald-500/20 text-emerald-400 hover:bg-emerald-500/30 disabled:opacity-40 text-sm font-medium">
                    💾 현재 세션 저장
                  </button>
                  <button onClick={exportArchiveJSON} disabled={archivedSessions.length === 0}
                    className="px-3 py-2 rounded-lg bg-blue-500/20 text-blue-400 hover:bg-blue-500/30 disabled:opacity-40 text-sm font-medium">
                    📤 JSON 백업
                  </button>
                  <button onClick={() => jsonInputRef.current?.click()}
                    className="px-3 py-2 rounded-lg bg-purple-500/20 text-purple-400 hover:bg-purple-500/30 text-sm font-medium">
                    📥 JSON 복원
                  </button>
                  <input ref={jsonInputRef} type="file" accept=".json" onChange={importArchiveJSON} className="hidden" />
                </div>
              </div>
            </div>

            <div className="glass rounded-2xl p-4 mb-4">
              <input type="text" value={archiveSearch} onChange={(e) => setArchiveSearch(e.target.value)}
                className="w-full bg-black/30 text-white px-4 py-2 rounded-xl border border-gray-800 focus:border-indigo-500"
                placeholder="🔍 곡명, 저작자, OP명, 아티스트, 날짜로 검색..." />
            </div>

            {filtered.length === 0 ? (
              <div className="glass rounded-2xl p-12 text-center">
                <p className="text-4xl mb-4 opacity-60">📦</p>
                <p className="text-gray-400">{archivedSessions.length === 0 ? '저장된 세션이 없습니다. 리뷰 완료 후 "현재 세션 저장" 버튼을 눌러주세요.' : '검색 결과가 없습니다.'}</p>
              </div>
            ) : (
              <div className="space-y-4">
                {filtered.map(session => (
                  <div key={session.id} className="glass rounded-2xl overflow-hidden">
                    <div className="p-4 flex flex-col md:flex-row md:items-center justify-between gap-3 cursor-pointer hover:bg-white/5"
                      onClick={() => setExpandedId(expandedId === session.id ? null : session.id)}>
                      <div className="flex items-center gap-4">
                        <span className="text-2xl">{expandedId === session.id ? '📂' : '📁'}</span>
                        <div>
                          <h3 className="text-white font-semibold">{session.아티스트}</h3>
                          <p className="text-sm text-gray-500">{session.날짜} | {session.총곡수}곡 | 완료 {session.완료곡수}곡 | 추천 {session.추천곡수}곡</p>
                        </div>
                      </div>
                      <div className="flex gap-2">
                        <button onClick={(e) => { e.stopPropagation(); exportSessionHTML(session); }}
                          className="px-3 py-1.5 rounded-lg bg-indigo-500/20 text-indigo-400 hover:bg-indigo-500/30 text-xs font-medium">HTML</button>
                        <button onClick={(e) => { e.stopPropagation(); exportSessionPDF(session); }}
                          className="px-3 py-1.5 rounded-lg bg-orange-500/20 text-orange-400 hover:bg-orange-500/30 text-xs font-medium">PDF</button>
                        <button onClick={(e) => { e.stopPropagation(); deleteArchivedSession(session.id); }}
                          className="px-3 py-1.5 rounded-lg bg-red-500/20 text-red-400 hover:bg-red-500/30 text-xs font-medium">삭제</button>
                      </div>
                    </div>
                    {expandedId === session.id && (
                      <div className="border-t border-gray-800 overflow-x-auto">
                        <table className="w-full">
                          <thead className="bg-black/30">
                            <tr>
                              <th className="px-3 py-2 text-left text-xs text-gray-500">#</th>
                              <th className="px-3 py-2 text-left text-xs text-gray-500">곡명</th>
                              <th className="px-3 py-2 text-left text-xs text-gray-500">저작자</th>
                              <th className="px-3 py-2 text-left text-xs text-gray-500">OP명</th>
                              <th className="px-3 py-2 text-left text-xs text-gray-500">장르</th>
                              <th className="px-3 py-2 text-center text-xs text-gray-500">점수</th>
                              <th className="px-3 py-2 text-left text-xs text-gray-500">피드백</th>
                            </tr>
                          </thead>
                          <tbody>
                            {session.songs.map((s, i) => {
                              const isRec = parseFloat(s.점수 || 0) >= 4.0;
                              return (
                                <tr key={i} className="border-t border-gray-800/50 hover:bg-white/3">
                                  <td className="px-3 py-2 text-xs text-gray-600">{i + 1}</td>
                                  <td className="px-3 py-2 text-sm text-white">{s.곡명}{isRec && <span className="ml-1 text-rose-400">&#10084;</span>}</td>
                                  <td className="px-3 py-2 text-xs text-gray-400">{s.저작자 || '-'}</td>
                                  <td className="px-3 py-2 text-xs text-gray-400">{s.OP명 || '-'}</td>
                                  <td className="px-3 py-2 text-xs text-gray-400">{s.장르 || '-'}</td>
                                  <td className="px-3 py-2 text-center">
                                    {s.점수 && <span className={`px-2 py-0.5 rounded-full text-xs font-bold text-white bg-gradient-to-r ${getScoreColor(s.점수)}`}>{s.점수}</span>}
                                  </td>
                                  <td className="px-3 py-2 text-xs text-gray-500 max-w-[200px] truncate">{s.피드백 || '-'}</td>
                                </tr>
                              );
                            })}
                          </tbody>
                        </table>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}

            <div className="mt-4 glass rounded-xl p-4">
              <div className="text-center text-sm text-gray-400 mb-2">
                <span className="text-white font-semibold">총 {archivedSessions.reduce((sum, s) => sum + s.songs.length, 0)}곡</span> 저장됨
              </div>
              <div className="flex items-center justify-center gap-2 text-xs">
                <span className="text-gray-500">
                  현재 브라우저({navigator.userAgent.includes('Chrome') ? 'Chrome' : navigator.userAgent.includes('Firefox') ? 'Firefox' : navigator.userAgent.includes('Edge') ? 'Edge' : '브라우저'}) 저장소 사용량:
                </span>
                <span className={`font-mono font-bold ${
                  (new Blob([JSON.stringify(archivedSessions)]).size / 1024) > 4000 ? 'text-red-400' :
                  (new Blob([JSON.stringify(archivedSessions)]).size / 1024) > 3000 ? 'text-yellow-400' : 'text-emerald-400'
                }`}>
                  {(new Blob([JSON.stringify(archivedSessions)]).size / 1024).toFixed(1)}KB
                </span>
                <span className="text-gray-600">/ 5,120KB</span>
              </div>
              {(new Blob([JSON.stringify(archivedSessions)]).size / 1024) > 3000 && (
                <div className="mt-2 text-center text-xs text-yellow-400">
                  ⚠️ 저장 공간이 부족합니다. JSON 백업 후 오래된 세션을 삭제하세요.
                </div>
              )}
            </div>
          </div>
        );
      };

      return (
        <div className="min-h-screen">
          {view === 'upload' && UploadView()}
          {view === 'credit' && CreditView()}
          {view === 'review' && ReviewView()}
          {view === 'list' && ListView()}
          {view === 'archive' && ArchiveView()}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<DemoReviewSystem />);
  </script>
</body>
</html>
