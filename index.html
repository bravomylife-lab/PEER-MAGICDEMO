<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PEERMUSIC DEMO ê²€í†  ì‹œìŠ¤í…œ</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');

    * {
      font-family: 'Inter', 'Noto Sans KR', sans-serif;
    }

    body {
      background: #0a0a0a;
    }

    .glass {
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .gradient-text {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .upload-zone {
      border: 2px dashed rgba(255,255,255,0.15);
      transition: all 0.3s ease;
    }

    .upload-zone:hover {
      border-color: #667eea;
      background: rgba(102,126,234,0.1);
      transform: scale(1.01);
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      transition: all 0.3s ease;
    }

    .btn-primary:hover {
      box-shadow: 0 10px 40px rgba(102,126,234,0.3);
      transform: translateY(-2px);
    }

    .btn-secondary {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      transition: all 0.3s ease;
    }

    .btn-secondary:hover {
      background: rgba(255,255,255,0.15);
    }

    .star { cursor: pointer; transition: all 0.2s ease; font-size: 28px; }
    .star:hover { transform: scale(1.2); }
    .star.filled { color: #fbbf24; }
    .star.empty { color: #4b5563; }

    input:focus, textarea:focus, select:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
    }

    .fade-in { animation: fadeIn 0.4s ease-out; }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: #1a1a1a; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: #444; }

    .nav-button { transition: all 0.3s ease; }
    .nav-button:hover:not(:disabled) { transform: translateX(var(--direction, 0)); }
    .nav-button:disabled { opacity: 0.3; cursor: not-allowed; }

    .credit-item {
      background: rgba(102,126,234,0.1);
      border: 1px solid rgba(102,126,234,0.3);
    }
  </style>
</head>
<body class="min-h-screen">
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    const FEEDBACK_PRESETS = [
      'ë°ëª¨ì˜ í€„ë¦¬í‹°ê°€ í˜„ì €íˆ ë‚®ìŒ',
      'ì†¡ë¦¬ë“œì™€ ìƒì´í•œ ë°ëª¨',
      'ì•„í‹°ìŠ¤íŠ¸ì™€ ì–´ìš¸ë¦¬ì§€ ì•ŠëŠ” ë°ëª¨',
      'ê³¡ì€ ì¢‹ìœ¼ë‚˜ í•´ë‹¹ ë¦¬ë“œì™€ëŠ” ì–´ìš¸ë¦¬ì§€ ì•ŠëŠ” ë°ëª¨'
    ];

    const SCORES = ['5.0', '4.5', '4.0', '3.5', '3.0', '2.5', '2.0', '1.5', '1.0'];

    // ì¥ë¥´ í‚¤ì›Œë“œ ëª©ë¡ (ìë™ ë¶„ë¥˜ìš©)
    const GENRE_KEYWORDS = [
      'House', 'Hiphop', 'Hip-Hop', 'Hip Hop', 'Pop', 'Rock', 'Ballad', 'R&B', 'RnB',
      'Dance', 'EDM', 'Electronic', 'Jazz', 'Soul', 'Funk', 'Disco', 'Reggae',
      'Country', 'Folk', 'Blues', 'Classical', 'Latin', 'Trap', 'Drill', 'Rage',
      'K-Pop', 'J-Pop', 'City Pop', 'Synth', 'Acoustic', 'Alternative',
      'Indie', 'Metal', 'Punk', 'Grunge', 'Lo-Fi', 'Lofi', 'Chill',
      'Afrobeat', 'Reggaeton', 'Moombahton', 'Future Bass', 'Dubstep',
      'Trance', 'Techno', 'Progressive', 'Ambient', 'New Age',
      'Gospel', 'Worship', 'Christmas', 'Slow Jam', 'Uptempo',
      'Midtempo', 'Downtempo', 'UK Garage', 'Garage', 'Grime',
      'HIP&GEN-Z', 'GEN-Z', 'Y2K', 'Retro', 'Modern', '80s', '90s'
    ];

    // ì¥ë¥´ í‚¤ì›Œë“œì¸ì§€ í™•ì¸
    const isGenreKeyword = (text) => {
      const lowerText = text.toLowerCase().replace(/[&-]/g, '');
      return GENRE_KEYWORDS.some(genre =>
        lowerText.includes(genre.toLowerCase().replace(/[&-]/g, ''))
      );
    };

    // ì•Œë ¤ì§„ ì‘ê³¡ê°€ ëª©ë¡ (ìë™ ì¸ì‹ìš©)
    const KNOWN_COMPOSERS = new Set([
      'Smob', 'SMOB', 'Sooyoon', 'Zomay', 'Chris Alice', 'TAN', 'Sisyphus',
      'ì˜ì›í¬', 'Karrinator', 'ì¼€ë¹ˆì˜¤ë¹ ', 'MOGT', 'YUSU', 'OneTop', 'Zeenan',
      'Andy', 'ì„œì •ì§„', 'ì „ê·¼í™”', 'Weeky1', 'BT', 'ìœ ì •í›ˆ', 'ë°•ë¯¼ìš°', 'ë°•í˜„ê·œ',
      'ì˜¤ì˜ë¹ˆ', 'Noheul', 'ë…¸ì„', 'ì°¨ë¯¼í˜¸', 'Adam Argyle', 'Phil Plested',
      'Ron Irving', 'Dave Pickell', 'Ben Charles', 'Jose Manuel',
      "NU'MAKER", 'I-NORI', 'Gusten Dahlqvist', 'Jes Meinertz',
      'June', 'KWH', 'Andreas', 'ì„œì˜ì„±', 'ì •ì§„ìš±', 'ì´ì„±í˜',
      'ê¹€ì›', 'Renjin Zhao', 'J.S'  // ì¶”ê°€
    ]);

    // ì´ë©”ì¼/í´ë”ëª… â†’ OPëª… ë§¤í•‘ (í™•ì¥ë¨)
    const EMAIL_TO_OP = {
      // ê¸°ì¡´ ë§¤í•‘
      'tos92@naver.com': 'To.S',
      'dctsung@naver.com': 'ES2',
      'kino1229@naver.com': 'YJH',
      'ahlgus2696@naver.com': 'PHK',
      'mildang@naver.com': 'OYB',
      'daslkfj@hanmail.net': 'JGH',
      'coollife07@naver.com': 'Noheul',
      'molesmusik@yahoo.es': 'JM',
      'twobluebirds@shaw.ca': 'RON',
      'bcabox@gmail.com': 'BEN',
      'colin.hembus@eavesmusicgroup.com': 'EavesMusic',
      'atcmusic.ar.0328@gmail.com': 'ART.M',
      // ìƒˆë¡œìš´ ë§¤í•‘ (NEXZ JAPAN í”„ë¡œì íŠ¸ ë“±)
      'eunae.solcire@gmail.com': 'Solcire',
      'smobmusicofficial@gmail.com': 'SMOB',
      'oskar.larsson@glmusic.dk': 'GL Music',
      'hjkim@musiccombine.com': 'Music Combine',
      'purpl78@hanmail.net': 'KW',  // ê¹€ì› ì‘ê°€
      'modern_sound@naver.com': 'Modern Sound',
      'victoria.ree@concord.com': 'Concord',
      'info@wavecandy.com': 'Wavecandy',
      // ì¶”ê°€ êµ­ì œ í¼ë¸”ë¦¬ì…”
      'soundgraphics': 'SoundGraphics',
      'admin@soundgraphics.co.kr': 'SoundGraphics',
    };

    // ì´ë©”ì¼ â†’ ì €ì‘ì ë§¤í•‘ (ìë™ ì €ì‘ì ì…ë ¥ìš©)
    const EMAIL_TO_COMPOSER = {
      'purpl78@hanmail.net': 'ê¹€ì›',
      'molesmusik@yahoo.es': 'Jose Manuel',
    };

    // ì‘ê°€ëª… â†’ OPëª… ë§¤í•‘ (í™•ì¥ë¨)
    const COMPOSER_TO_OP = {
      // ê¸°ì¡´ ë§¤í•‘
      'onetop': 'OneTop',
      'zeenan': 'OneTop',
      'andy': 'OneTop',
      'ì„œì •ì§„': 'SJJ',
      'to.s': 'To.S',
      'es2': 'ES2',
      'june': 'ES2',
      'kwh': 'ES2',
      'andreas': 'ES2',
      'ì„œì˜ì„±': 'ES2',
      'ì „ê·¼í™”': 'JGH',
      'weeky1': 'JGH',
      'bt': 'JGH',
      'ì •ì§„ìš±': 'JGH',
      'ìœ ì •í›ˆ': 'YJH',
      'ë°•ë¯¼ìš°': 'YJH',
      'ë°•í˜„ê·œ': 'PHK',
      'phk': 'PHK',
      'ì˜¤ì˜ë¹ˆ': 'OYB',
      'noheul': 'Noheul',
      'ë…¸ì„': 'Noheul',
      'ì°¨ë¯¼í˜¸': 'ART.M',
      'adam argyle': 'EavesMusic',
      'phil plested': 'EavesMusic',
      'nick hahn': 'EavesMusic',
      'alexander hahn': 'EavesMusic',
      'ron irving': 'RON',
      'dave pickell': 'RON',
      'corey abrams': 'RON',
      'ben charles': 'BEN',
      'jose manuel': 'JM',
      'domingo morales': 'JM',
      'santiago revilla': 'JM',
      'filo ebid': 'JM',
      'josue vergara': 'JM',
      'pablo peset': 'JM',
      // ìƒˆë¡œìš´ ë§¤í•‘ (Solcire, SMOB, GL Music ë“±)
      'chris alice': 'Solcire',
      'ì˜ì›í¬': 'Solcire',
      'sisyphus': 'Solcire',
      'tan': 'Solcire',
      'karrinator': 'Solcire',
      'ì¼€ë¹ˆì˜¤ë¹ ': 'Solcire',
      'mogt': 'Solcire',
      'yusu': 'Solcire',
      'solcire': 'Solcire',
      'ì ì‹œë ˆ': 'Solcire',
      'smob': 'SMOB',
      "nu'maker": 'SMOB',
      'i-nori': 'SMOB',
      // GL Music (ë¶ìœ ëŸ½)
      'gusten dahlqvist': 'GL Music',
      'cosmos': 'COS',  // COSMOS â†’ COS
      'jes meinertz': 'GL Music',
      'johs': 'GL Music',
      'deekay': 'GL Music',
      'david west': 'GL Music',
      'lasse lindorff': 'GL Music',
      'svend gudiksen': 'GL Music',
      'mats valentin': 'GL Music',
      'jade ell': 'GL Music',
      'mattias kolstrup': 'GL Music',
      // Music Combine
      'ë®¤ì§ì»´ë°”ì¸': 'Music Combine',
      'music combine': 'Music Combine',
      // SoundGraphics
      'soundgraphics': 'SoundGraphics',
      'sg': 'SoundGraphics',
      // Concord
      'concord': 'Concord',
      // ì¶”ê°€ í•œêµ­ ì‘ê³¡ê°€
      'ì†ì—°ì„±': 'Individual',
      'ì£¼í˜„ë¯¼': 'Individual',
      'ë°•ìˆ˜ì„': 'Individual',
      'ì´ì„±í˜': 'JGH',
    };

    // ì´ë©”ì¼ì—ì„œ OPëª… ì¶”ì¶œ
    const getOPFromEmail = (email) => {
      if (!email) return '';
      const emailLower = email.toLowerCase();
      for (const [key, value] of Object.entries(EMAIL_TO_OP)) {
        if (emailLower.includes(key.toLowerCase().split('@')[0])) {
          return value;
        }
      }
      return '';
    };

    // ì €ì‘ìëª…ì—ì„œ OPëª… ì¶”ì¶œ
    const getOPFromComposer = (composer) => {
      if (!composer) return '';
      const composerLower = composer.toLowerCase();
      for (const [key, value] of Object.entries(COMPOSER_TO_OP)) {
        if (composerLower.includes(key.toLowerCase())) {
          return value;
        }
      }
      return '';
    };

    // í•œê¸€ ì´ˆì„± ì¶”ì¶œ
    const getKoreanInitials = (name) => {
      const CHO_EN = ['G','KK','N','D','DD','R','M','B','BB','S','SS','','J','JJ','CH','K','T','P','H'];
      let initials = '';
      for (let char of name) {
        const code = char.charCodeAt(0) - 44032;
        if (code >= 0 && code <= 11171) initials += CHO_EN[Math.floor(code / 588)];
      }
      return initials || name;
    };

    // ì˜ë¬¸ ì´ë‹ˆì…œ ì¶”ì¶œ
    const getEnglishInitials = (name) => {
      const words = name.split(/[\s,._-]+/).filter(w => w.length > 0);
      if (words.length === 1) return name.substring(0, 3).toUpperCase();
      return words.map(w => w[0].toUpperCase()).join('');
    };

    // í´ë” ê²½ë¡œì—ì„œ ì•„í‹°ìŠ¤íŠ¸ëª… ì¶”ì¶œ (ê°œì„ ë¨)
    const extractArtistFromPath = (path) => {
      const patterns = [
        // "NEXZ(ì¼ë³¸ì•¨ë²”) ìˆ˜ë¡ê³¡ ì „ì²´ DEMO" â†’ NEXZ
        /([ê°€-í£a-zA-Z0-9]+)\s*\([^)]+\)\s*(?:ìˆ˜ë¡ê³¡\s*)?ì „ì²´\s*DEMO/i,
        // "ì´ì°½ì„­ ì „ì²´ DEMO" â†’ ì´ì°½ì„­
        /([ê°€-í£a-zA-Z]+)\s*ì „ì²´\s*DEMO/i,
        // "NEXZ JAPAN ë°ëª¨" â†’ NEXZ JAPAN
        /\[.*?\]\s*([ê°€-í£a-zA-Z\s]+)\s*ë°ëª¨/i,
        // ì¼ë°˜ DEMO íŒ¨í„´
        /([ê°€-í£a-zA-Z]+)\s*DEMO/i,
      ];
      for (const pattern of patterns) {
        const match = path.match(pattern);
        if (match) return match[1].trim();
      }
      return '';
    };

    // í´ë” ê²½ë¡œì—ì„œ ì—…ë¡œë“œ ë‚ ì§œ ì¶”ì¶œ (ìƒˆë¡œìš´ í•¨ìˆ˜)
    const extractDateFromPath = (path) => {
      // íŒ¨í„´ 1: (2026.01.28) ë˜ëŠ” (2026-01-28) í˜•ì‹
      const parenDateMatch = path.match(/\((\d{4})[.\-](\d{2})[.\-](\d{2})\)/);
      if (parenDateMatch) {
        return `${parenDateMatch[1]}-${parenDateMatch[2]}-${parenDateMatch[3]}`;
      }

      // íŒ¨í„´ 2: 26.01.27 í˜•ì‹ (YY.MM.DD)
      const shortDateMatch = path.match(/(\d{2})[.\-](\d{2})[.\-](\d{2})/);
      if (shortDateMatch) {
        const year = parseInt(shortDateMatch[1]) < 50 ? `20${shortDateMatch[1]}` : `19${shortDateMatch[1]}`;
        return `${year}-${shortDateMatch[2]}-${shortDateMatch[3]}`;
      }

      // íŒ¨í„´ 3: 2026-01-28 ë˜ëŠ” 2026.01.28 í˜•ì‹
      const fullDateMatch = path.match(/(\d{4})[.\-](\d{2})[.\-](\d{2})/);
      if (fullDateMatch) {
        return `${fullDateMatch[1]}-${fullDateMatch[2]}-${fullDateMatch[3]}`;
      }

      return null;
    };

    // í´ë” ê²½ë¡œì—ì„œ ì´ë©”ì¼ ì¶”ì¶œ (ìˆœìˆ˜ ì´ë©”ì¼ë§Œ, _ ì•ì˜ ì•„í‹°ìŠ¤íŠ¸ëª… ì œê±°)
    const extractEmailFromPath = (path) => {
      // ì´ë©”ì¼ íŒ¨í„´ ë§¤ì¹­ (@ ê¸°í˜¸ë¥¼ ê¸°ì¤€ìœ¼ë¡œ)
      const emailMatch = path.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
      if (emailMatch) {
        return cleanEmailAddress(emailMatch[1]);
      }
      if (path.includes('ì„±ê·œí˜¸ ì‘ê°€ë‹˜') || path.includes('ëŒ€í‘œë‹˜')) {
        return 'ëŒ€í‘œë‹˜ ì „ë‹¬ DEMO';
      }
      return '';
    };

    // ì´ë©”ì¼ ì£¼ì†Œ ì •ì œ í•¨ìˆ˜ - '_' ì´í›„ ë¶€ë¶„ë§Œ ì¶”ì¶œ
    const cleanEmailAddress = (rawEmail) => {
      if (!rawEmail) return '';

      // _ ë¡œ ì‹œì‘í•˜ë©´ ì œê±° (ì˜ˆ: _daslkfj@hanmail.net â†’ daslkfj@hanmail.net)
      let email = rawEmail.startsWith('_') ? rawEmail.substring(1) : rawEmail;

      // @ ì•ë¶€ë¶„ì—ì„œ ë§ˆì§€ë§‰ '_' ì´í›„ê°€ ì‹¤ì œ ì´ë©”ì¼ ì£¼ì†Œ
      const atIndex = email.indexOf('@');
      if (atIndex > 0) {
        const localPart = email.substring(0, atIndex);
        const domain = email.substring(atIndex);

        // ë¡œì»¬íŒŒíŠ¸ì— _ê°€ ìˆìœ¼ë©´ ë§ˆì§€ë§‰ _ ì´í›„ë§Œ ì‚¬ìš©
        const lastUnderscoreIndex = localPart.lastIndexOf('_');
        if (lastUnderscoreIndex >= 0) {
          const afterUnderscore = localPart.substring(lastUnderscoreIndex + 1);
          // _ ì´í›„ì— ìœ íš¨í•œ ë¬¸ìê°€ ìˆìœ¼ë©´ ê·¸ê²ƒë§Œ ì‚¬ìš©
          if (afterUnderscore.length > 0) {
            email = afterUnderscore + domain;
          }
        }
      }

      return email;
    };

    // í´ë” ê²½ë¡œì—ì„œ ì €ì‘ì íŒíŠ¸ ì¶”ì¶œ
    const extractComposerHintFromPath = (path) => {
      const folderMatch = path.match(/([ê°€-í£]+)_[ê°€-í£]+\s*Demo/i);
      if (folderMatch) return folderMatch[1];
      const suffixMatch = path.match(/Demo_([ê°€-í£]+)/i);
      if (suffixMatch) return suffixMatch[1];
      return '';
    };

    // ë‚ ì§œ í¬ë§·
    const formatDate = (date) => {
      if (!date) return new Date().toISOString().split('T')[0];
      const d = new Date(date);
      return d.toISOString().split('T')[0];
    };

    // ëŒ€ê´„í˜¸ì—ì„œ ì €ì‘ìë“¤ ì¶”ì¶œ [A][B][C] â†’ "A, B, C"
    const extractComposersFromBrackets = (text) => {
      const matches = text.match(/\[([^\]]+)\]/g);
      if (!matches) return '';
      const composers = matches.map(m => m.replace(/[\[\]]/g, '').trim());
      return composers.join(', ');
    };

    // ========== í•µì‹¬ íŒŒì‹± í•¨ìˆ˜ (ê°•ë ¥í•œ íŒ¨í„´ ì¸ì‹) ==========
    const parseFileName = (filename, folderPath = '') => {
      const nameWithoutExt = filename.replace(/\.(mp3|wav|m4a|flac|aiff)$/i, '');
      let songName = '';
      let composer = '';
      let opName = '';
      let genre = '';
      let bpm = '';

      // íŒŒì¼ëª…ì—ì„œ ëª¨ë“  ì´ë©”ì¼ ì¶”ì¶œ ë° ì •ì œ
      const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/gi;
      const allEmails = nameWithoutExt.match(emailRegex) || [];
      const rawEmail = allEmails[0] || extractEmailFromPath(folderPath);
      const email = cleanEmailAddress(rawEmail); // ì´ë©”ì¼ ì •ì œ

      const composerHint = extractComposerHintFromPath(folderPath);
      const folderOP = extractOPFromFolderPath(folderPath);

      // ëŒ€ê´„í˜¸ì—ì„œ ì €ì‘ì ì¶”ì¶œ
      const bracketComposers = extractComposersFromBrackets(nameWithoutExt);

      // íŒŒì¼ëª…ì—ì„œ ì´ë©”ì¼ê³¼ ëŒ€ê´„í˜¸ ì œê±°í•œ ë²„ì „
      let cleanName = nameWithoutExt
        .replace(emailRegex, '')  // ì´ë©”ì¼ ì œê±°
        .replace(/\[([^\]]+)\]/g, '')  // ëŒ€ê´„í˜¸ ì œê±°
        .replace(/_+/g, '_')  // ì—°ì† ì–¸ë”ìŠ¤ì½”ì–´ ì •ë¦¬
        .replace(/^_|_$/g, '')  // ì•ë’¤ ì–¸ë”ìŠ¤ì½”ì–´ ì œê±°
        .trim();

      // â˜… ê°•ë ¥í•œ íŒ¨í„´ ì¸ì‹: ì‘ê³¡ê°€_ê³¡ëª…_BPM_ì¥ë¥´ í˜•ì‹
      // ì˜ˆ: ê°•ë™í™”_DRIVE OFF_ BPM104_POP_R&B
      const parts = cleanName.split('_').map(p => p.trim()).filter(p => p);

      if (parts.length >= 2) {
        let composerCandidate = '';
        let songNameCandidate = '';
        let idx = 0;

        // ì²« ë²ˆì§¸ íŒŒíŠ¸ ë¶„ì„
        const firstPart = parts[0];

        // ì²« ë²ˆì§¸ê°€ ì‘ê³¡ê°€ì¸ì§€ íŒë‹¨
        const isFirstPartComposer =
          KNOWN_COMPOSERS.has(firstPart) ||  // ì•Œë ¤ì§„ ì‘ê³¡ê°€
          /^[ê°€-í£]{2,4}$/.test(firstPart) ||  // í•œê¸€ 2-4ì (í•œêµ­ ì‘ê³¡ê°€ëª…)
          /^[A-Z][a-z]+(\s[A-Z][a-z]+)*$/.test(firstPart);  // ì˜ë¬¸ ì´ë¦„ í˜•ì‹

        if (isFirstPartComposer && parts.length >= 2) {
          // íŒ¨í„´: ì‘ê³¡ê°€_ê³¡ëª…_ë‚˜ë¨¸ì§€
          composerCandidate = firstPart;
          songNameCandidate = parts[1];
          idx = 2;
        } else {
          // íŒ¨í„´: ê³¡ëª…_ë‚˜ë¨¸ì§€ (ì‘ê³¡ê°€ ì—†ìŒ)
          songNameCandidate = firstPart;
          idx = 1;
        }

        songName = songNameCandidate;
        if (composerCandidate) {
          composer = composerCandidate;
        }

        // ë‚˜ë¨¸ì§€ ë¶€ë¶„ì—ì„œ BPM, ì¥ë¥´ ì¶”ì¶œ
        const genreParts = [];

        for (let i = idx; i < parts.length; i++) {
          const part = parts[i];

          // DEMO ìŠ¤í‚µ
          if (/^DEMO[#]?$/i.test(part)) continue;

          // BPM íŒ¨í„´ (BPM104, 104, Tempo104 ë“±)
          const bpmMatch = part.match(/(?:BPM|Tempo)?(\d+)/i);
          if (bpmMatch && !bpm) {
            bpm = bpmMatch[1];
            continue;
          }

          // ì¥ë¥´ í‚¤ì›Œë“œ
          if (isGenreKeyword(part)) {
            genreParts.push(part);
            continue;
          }

          // ì§€ë¶„ìœ¨ í¬í•¨ ì €ì‘ì ì •ë³´
          if (/\d+(\.\d+)?%/.test(part) && /[A-Za-zê°€-í£]/.test(part)) {
            composer = composer ? `${composer}, ${part}` : part;
            continue;
          }

          // í¼ë¸”ë¦¬ì…” í‚¤ì›Œë“œ
          if (/Peermusic|Outdustry|Publishing/i.test(part)) {
            composer = composer ? `${composer} ${part}` : part;
            continue;
          }

          // ê·¸ ì™¸ ì‘ê³¡ê°€ë¡œ ì¶”ê°€ (BPMì´ë‚˜ ìˆ«ìê°€ ì•„ë‹Œ ê²½ìš°)
          if (!/^\d+$/.test(part) && !/@/.test(part)) {
            if (!composer) {
              composer = part;
            } else if (!KNOWN_COMPOSERS.has(composer)) {
              // ì´ë¯¸ ì‘ê³¡ê°€ê°€ ìˆì§€ë§Œ ì•Œë ¤ì§€ì§€ ì•Šì€ ê²½ìš°, ì¶”ê°€ ì •ë³´ë¡œ ê²°í•©
              composer = `${composer}, ${part}`;
            }
          }
        }

        // ì¥ë¥´ ì¡°í•©
        if (genreParts.length > 0) {
          genre = genreParts.join(' / ');
        }
      } else if (parts.length === 1) {
        // ë‹¨ì¼ íŒŒíŠ¸ëŠ” ê³¡ëª…
        songName = parts[0];
      }

      // ëŒ€ê´„í˜¸ ì €ì‘ì ìš°ì„  ì‚¬ìš©
      if (bracketComposers) {
        composer = bracketComposers;
      }

      // OPëª… ê²°ì •
      opName = getOPFromEmail(email) || getOPFromComposer(composer) || folderOP || '';

      // ì´ë©”ì¼ì—ì„œ ê¸°ë³¸ ì €ì‘ì ë§¤í•‘ (ì €ì‘ìê°€ ë¹„ì–´ìˆì„ ë•Œ)
      if (!composer && email && EMAIL_TO_COMPOSER[email]) {
        composer = EMAIL_TO_COMPOSER[email];
      }

      // ê²°ê³¼ê°€ ìˆìœ¼ë©´ ë°˜í™˜
      if (songName) {
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== ê¸°ì¡´ íŠ¹ìˆ˜ íŒ¨í„´ë“¤ (fallback) ==========

      // íŒ¨í„´ 1: _Pitched by MCë¡œ ëë‚˜ëŠ” íŒŒì¼ (ì´ë¯¸ ì²˜ë¦¬ëœ íŒŒì¼)
      const pitchedMatch = nameWithoutExt.match(/^(.+?)_([^_]+)_Pitched by MC$/i);
      if (pitchedMatch) {
        songName = pitchedMatch[1].trim();
        opName = pitchedMatch[2].trim();
        composer = composerHint || opName;
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 2: [ì‘ê°€ëª…]_ê³¡ëª…_BPMìˆ«ì_ì¥ë¥´ í˜•ì‹
      const bracketMatch = nameWithoutExt.match(/^\[([^\]]+)\]_(.+?)(?:_BPM\d+)?(?:_[a-zA-Z]+)?$/i);
      if (bracketMatch) {
        composer = bracketMatch[1].trim();
        songName = bracketMatch[2].trim();
        opName = getOPFromComposer(composer) || composer;
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 3: ê³¡ëª…(ì‘ê°€+ì‘ê°€) (BPM,ì¥ë¥´) í˜•ì‹ (ES2 ìŠ¤íƒ€ì¼)
      const es2Match = nameWithoutExt.match(/^(.+?)\(([^)]+)\)\s*\([^)]*\)$/);
      if (es2Match) {
        songName = es2Match[1].trim();
        composer = es2Match[2].replace(/\+/g, ', ').trim();
        opName = getOPFromComposer(composer) || 'ES2';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 4: Weeky1- ê³¡ëª… [Tempoìˆ«ì] ì¥ë¥´ í˜•ì‹ (JGH ìŠ¤íƒ€ì¼)
      const weekyMatch = nameWithoutExt.match(/^Weeky1-\s*(.+?)\s*\[Tempo\d+\]/i);
      if (weekyMatch) {
        songName = weekyMatch[1].trim();
        composer = 'ì „ê·¼í™”(Weeky1), BT';
        opName = 'JGH';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 5: ì‘ê°€1,ì‘ê°€2_ê³¡ëª…_BPMìˆ«ì í˜•ì‹ (OneTop ìŠ¤íƒ€ì¼)
      const commaMatch = nameWithoutExt.match(/^([^_]+[,&][^_]+)_(.+?)(?:_BPM\d+)?$/i);
      if (commaMatch) {
        composer = commaMatch[1].replace(/&/g, ', ').trim();
        songName = commaMatch[2].trim();
        opName = getOPFromComposer(composer) || getEnglishInitials(composer.split(/[,&]/)[0].trim());
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 6: ìœ ì •í›ˆ_ë°•ë¯¼ìš°_ë‚˜ë¬´_B-Ab_69 í˜•ì‹ (YJH ìŠ¤íƒ€ì¼)
      const yjhMatch = nameWithoutExt.match(/^([ê°€-í£]+)_([ê°€-í£]+)_(.+?)_[A-G][#b]?[-_][A-Za-z]+_\d+$/i);
      if (yjhMatch) {
        composer = `${yjhMatch[1]}, ${yjhMatch[2]}`;
        songName = yjhMatch[3].trim();
        opName = getOPFromComposer(yjhMatch[1]) || 'YJH';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 7: 01 - Adam Argyle, ... Looks Different í˜•ì‹ (EavesMusic)
      const eavesMatch = nameWithoutExt.match(/^\d+\s*-\s*(.+?)\s*-\s*(.+)$/);
      if (eavesMatch) {
        composer = eavesMatch[1].replace(/\.\.\./g, '').trim();
        songName = eavesMatch[2].trim();
        opName = 'EavesMusic';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 8: ê³¡ëª… - ì‘ê°€ëª… í˜•ì‹ (ì—¬ëŸ¬ ìŠ¤íƒ€ì¼)
      const dashComposerMatch = nameWithoutExt.match(/^(.+?)\s*[-â€“]\s*([A-Za-z\s,]+)$/);
      if (dashComposerMatch) {
        const possibleComposer = dashComposerMatch[2].trim();
        const matchedOP = getOPFromComposer(possibleComposer.toLowerCase());
        if (matchedOP || /^[A-Z][a-z]+(\s+[A-Z][a-z]+)*$/.test(possibleComposer)) {
          songName = dashComposerMatch[1].trim();
          composer = possibleComposer;
          opName = matchedOP || getOPFromEmail(email) || folderOP || '';
          return { songName, composer, opName, email };
        }
      }

      // íŒ¨í„´ 9: ì˜¤ì˜ë¹ˆ_ë‚  ë– ë‚˜ì§€ë§ˆ_74_íŒ ë°œë¼ë“œ í˜•ì‹
      const oyoMatch = nameWithoutExt.match(/^([ê°€-í£]+)_(.+?)_\d+_/);
      if (oyoMatch) {
        composer = oyoMatch[1].trim();
        songName = oyoMatch[2].trim();
        opName = getOPFromComposer(composer) || getKoreanInitials(composer);
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 10: ê³¡ëª… DEMO_OPëª… ë˜ëŠ” ê³¡ëª…_OPëª… í˜•ì‹ (Solcire ìŠ¤íƒ€ì¼)
      // ì˜ˆ: "POP BEAT DEMO_Solcire Music.mp3" â†’ ê³¡ëª…: "POP BEAT", OP: "Solcire"
      const demoOPMatch = nameWithoutExt.match(/^(.+?)\s*(?:DEMO[#]?)?_([A-Za-z\s.]+)$/i);
      if (demoOPMatch) {
        let rawSongName = demoOPMatch[1].trim();
        const rawOP = demoOPMatch[2].trim();
        // ê³¡ëª…ì—ì„œ DEMO ì œê±°
        rawSongName = rawSongName.replace(/\s*DEMO[#]?\s*$/i, '').trim();
        songName = rawSongName;
        const matchedOP = getOPFromComposer(rawOP.toLowerCase());
        opName = matchedOP || rawOP;
        composer = composerHint || '';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 11: ê³¡ëª…_Tìˆ«ì_Key_ê°€ì´ë“œë³´ì»¬ í˜•ì‹
      // ì˜ˆ: "Saturn_T94_Gkey_ê°€ì´ë“œë³´ì»¬.mp3" â†’ ê³¡ëª…: "Saturn"
      const tempoKeyMatch = nameWithoutExt.match(/^(.+?)_T\d+_[A-G][#b]?(?:key|m)?/i);
      if (tempoKeyMatch) {
        songName = tempoKeyMatch[1].trim();
        opName = getOPFromEmail(email) || folderOP || '';
        composer = composerHint || '';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 12: ê³¡ëª…_ì¥ë¥´_ìˆ«ì_DEMO í˜•ì‹
      // ì˜ˆ: "ìˆì–ì•„ (AHMOLLA)_HIP&GEN-Z_192_DEMO.mp3" â†’ ê³¡ëª…: "ìˆì–ì•„ (AHMOLLA)" ë˜ëŠ” "ìˆì–ì•„"
      const genreNumDemoMatch = nameWithoutExt.match(/^(.+?)_[A-Za-z&-]+_\d+_DEMO$/i);
      if (genreNumDemoMatch) {
        songName = genreNumDemoMatch[1].trim();
        opName = getOPFromEmail(email) || folderOP || '';
        composer = composerHint || '';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 13: ê³¡ëª…#_ì‘ê°€ëª… í˜•ì‹
      // ì˜ˆ: "ëˆˆë¶€ì‹  ì‚¬ë‘ DEMO#_ë°•ìˆ˜ì„.mp3" â†’ ê³¡ëª…: "ëˆˆë¶€ì‹  ì‚¬ë‘"
      const hashDemoMatch = nameWithoutExt.match(/^(.+?)\s*DEMO[#]?_([ê°€-í£A-Za-z\s]+)$/i);
      if (hashDemoMatch) {
        songName = hashDemoMatch[1].trim();
        composer = hashDemoMatch[2].trim();
        opName = getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 14: ë‹¨ìˆœ ê³¡ëª…ë§Œ ìˆëŠ” ê²½ìš° (ì˜ë¬¸ ëŒ€ë¬¸ì)
      if (/^[A-Z\s'Â´!?]+$/i.test(nameWithoutExt) && nameWithoutExt.length > 2) {
        songName = nameWithoutExt.trim();
        opName = getOPFromEmail(email) || folderOP || '';
        composer = composerHint || '';
        return { songName, composer, opName, email };
      }

      // íŒ¨í„´ 15: ì•„í‹°ìŠ¤íŠ¸ Demoê°€ í¬í•¨ëœ íŒŒì¼
      const artistDemoMatch = nameWithoutExt.match(/^(.+?)\s*\(([ê°€-í£A-Za-z]+)\s*Demo\)\s*$/i);
      if (artistDemoMatch) {
        songName = artistDemoMatch[1].trim();
        composer = composerHint || '';
        opName = getOPFromComposer(composerHint) || getOPFromEmail(email) || folderOP || '';
        return { songName, composer, opName, email };
      }

      // ê¸°ë³¸: íŒŒì¼ëª… ì •ì œ
      songName = nameWithoutExt
        .replace(/_BPM\d+/gi, '')
        .replace(/_Tempo\d+/gi, '')
        .replace(/_T\d+/gi, '')
        .replace(/\s*DEMO[#]?\s*/gi, ' ')
        .replace(/\s*\[.*?\]\s*/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();

      // ë§ˆì§€ë§‰ _ ì´í›„ê°€ OPëª…ì¼ ê°€ëŠ¥ì„± ì²´í¬
      const lastUnderscoreIdx = songName.lastIndexOf('_');
      if (lastUnderscoreIdx > 0) {
        const possibleOP = songName.substring(lastUnderscoreIdx + 1).trim();
        const matchedOP = getOPFromComposer(possibleOP.toLowerCase());
        if (matchedOP || (possibleOP.length <= 15 && /^[A-Za-z\s.]+$/.test(possibleOP))) {
          songName = songName.substring(0, lastUnderscoreIdx).trim();
          opName = matchedOP || possibleOP;
        }
      }

      if (!opName) {
        opName = getOPFromEmail(email) || folderOP || '';
      }
      composer = composerHint || '';

      return { songName, composer, opName, email };
    };

    // í´ë” ê²½ë¡œì—ì„œ OPëª… ì¶”ì¶œ (ìƒˆë¡œìš´ í•¨ìˆ˜)
    const extractOPFromFolderPath = (path) => {
      // [ì ì‹œë ˆë®¤ì§], [SMOB] ë“± ëŒ€ê´„í˜¸ ì•ˆì˜ OPëª… ì¶”ì¶œ
      const bracketOPMatch = path.match(/\[([ê°€-í£A-Za-z]+(?:ë®¤ì§|Music)?)\]/i);
      if (bracketOPMatch) {
        const opHint = bracketOPMatch[1].trim();
        // ë§¤í•‘ í…Œì´ë¸”ì—ì„œ ì°¾ê¸°
        const matchedOP = getOPFromComposer(opHint.toLowerCase().replace(/ë®¤ì§|music/gi, ''));
        if (matchedOP) return matchedOP;
        // ê·¸ëŒ€ë¡œ ë°˜í™˜
        return opHint.replace(/ë®¤ì§$/i, '').replace(/Music$/i, '').trim();
      }
      return '';
    };

    // ========== ì™„ì „ ë…ë¦½ ì…ë ¥ ì»´í¬ë„ŒíŠ¸ (blur ë¹„ë™ê¸° ì²˜ë¦¬ë¡œ ë–¨ë¦¼ ë°©ì§€) ==========
    const StableInput = React.memo(({ initialValue, onValueChange, placeholder, className, type = 'text', readOnly = false }) => {
      const [localValue, setLocalValue] = useState(initialValue || '');
      const initialRef = useRef(initialValue);
      const blurTimeoutRef = useRef(null);

      const handleChange = (e) => {
        setLocalValue(e.target.value);
      };

      const handleBlur = () => {
        // blur ì²˜ë¦¬ë¥¼ ë¹„ë™ê¸°ë¡œ ì§€ì—° - í´ë¦­ ì´ë²¤íŠ¸ê°€ ë¨¼ì € ì²˜ë¦¬ë˜ë„ë¡ í•¨
        if (blurTimeoutRef.current) {
          clearTimeout(blurTimeoutRef.current);
        }

        blurTimeoutRef.current = setTimeout(() => {
          if (localValue !== initialRef.current && onValueChange) {
            onValueChange(localValue);
            initialRef.current = localValue;
          }
        }, 0);
      };

      // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ íƒ€ì´ë¨¸ ì •ë¦¬
      useEffect(() => {
        return () => {
          if (blurTimeoutRef.current) {
            clearTimeout(blurTimeoutRef.current);
          }
        };
      }, []);

      return (
        <input
          type={type}
          value={localValue}
          onChange={handleChange}
          onBlur={handleBlur}
          className={className}
          placeholder={placeholder}
          readOnly={readOnly}
        />
      );
    });

    // ì™„ì „ ë…ë¦½ Textarea ì»´í¬ë„ŒíŠ¸ (blur ë¹„ë™ê¸° ì²˜ë¦¬)
    const StableTextarea = React.memo(({ initialValue, onValueChange, placeholder, className, rows = 2 }) => {
      const [localValue, setLocalValue] = useState(initialValue || '');
      const initialRef = useRef(initialValue);
      const blurTimeoutRef = useRef(null);

      const handleChange = (e) => {
        setLocalValue(e.target.value);
      };

      const handleBlur = () => {
        if (blurTimeoutRef.current) {
          clearTimeout(blurTimeoutRef.current);
        }

        blurTimeoutRef.current = setTimeout(() => {
          if (localValue !== initialRef.current && onValueChange) {
            onValueChange(localValue);
            initialRef.current = localValue;
          }
        }, 0);
      };

      useEffect(() => {
        return () => {
          if (blurTimeoutRef.current) {
            clearTimeout(blurTimeoutRef.current);
          }
        };
      }, []);

      return (
        <textarea
          value={localValue}
          onChange={handleChange}
          onBlur={handleBlur}
          className={className}
          placeholder={placeholder}
          rows={rows}
        />
      );
    });

    // í¬ë ˆë”§ ì…ë ¥ ì»´í¬ë„ŒíŠ¸ (DemoReviewSystem ì™¸ë¶€ì— ì •ì˜í•˜ì—¬ ë¦¬ë Œë”ë§ ë°©ì§€)
    const CreditTextArea = React.memo(({ textRef }) => {
      const localRef = useRef(null);
      const [localValue, setLocalValue] = useState('');

      const handleChange = (e) => {
        const newValue = e.target.value;
        setLocalValue(newValue);
        textRef.current = newValue;
      };

      return (
        <textarea
          ref={localRef}
          value={localValue}
          onChange={handleChange}
          className="w-full h-64 bg-black/50 text-gray-300 px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500 resize-none mb-4 font-mono text-sm"
          placeholder={`ì˜ˆì‹œ:

ê±°ê¸°ì„œ ê±°ê¸°
ì‘ê³¡ ì „ê·¼í™”
ì‘ì‚¬ ì „ê·¼í™”
í¸ê³¡ ì •ì§„ìš±

Hamburger
writers CC, Ron, JJ

ë„ˆì™€ì˜ ë°¤
ì‘ê³¡ ì „ê·¼í™”(Weeky1), BT
ì‘ì‚¬ ì „ê·¼í™”`}
        />
      );
    });

    // í¬ë ˆë”§ í…ìŠ¤íŠ¸ íŒŒì‹± (í™•ì¥ë¨ - Metadata, Composer í˜•ì‹ ì§€ì›)
    const parseCreditText = (creditText) => {
      const credits = {};
      const lines = creditText.split('\n').map(l => l.trim()).filter(l => l);

      let currentSong = null;
      let currentCredits = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // ì„¹ì…˜ í—¤ë” ìŠ¤í‚µ (íƒ€ì´í‹€, ìˆ˜ë¡ì„±, Metadata ë“±)
        if (/^(íƒ€ì´í‹€|ìˆ˜ë¡ì„±|ìˆ˜ë¡ê³¡|\(íƒ€ì´í‹€\)|\(ìˆ˜ë¡ì„±\)|Metadata|##?\s)/i.test(line)) {
          continue;
        }

        // íŒ¨í„´ 1: ë²ˆí˜¸. ê³¡ëª… - ì‘ê°€1, ì‘ê°€2 í˜•ì‹ (ë§ˆí¬ë‹¤ìš´ ë¦¬ìŠ¤íŠ¸)
        // ì˜ˆ: "1. AEROBATIC PLUM - Chris Alice, ì˜ì›í¬, Sisyphus"
        const numberedMatch = line.match(/^(\d+)\.\s*(.+?)\s*[-â€“]\s*(.+)$/);
        if (numberedMatch) {
          const songName = numberedMatch[2].trim();
          const composer = numberedMatch[3].trim();
          credits[songName.toLowerCase()] = composer;
          continue;
        }

        // íŒ¨í„´ 2: "ê³¡ëª….mp3 | Powered by Box" í˜•ì‹ (Boxì—ì„œ ë³µì‚¬í•œ í˜•ì‹)
        const boxMatch = line.match(/^(.+?)\.(mp3|wav|m4a|flac|aiff)\s*\|\s*Powered by Box$/i);
        if (boxMatch) {
          // ì´ì „ ê³¡ ì €ì¥
          if (currentSong && currentCredits.length > 0) {
            credits[currentSong.toLowerCase()] = currentCredits.join(', ');
          }
          currentSong = boxMatch[1].trim();
          currentCredits = [];
          continue;
        }

        // íŒ¨í„´ 3: í…Œì´ë¸” í˜•ì‹ (| # | ê³¡ëª… | ì €ì‘ì |)
        const tableMatch = line.match(/^\|\s*\d+\s*\|\s*(.+?)\s*\|\s*(.+?)\s*\|$/);
        if (tableMatch) {
          const songName = tableMatch[1].trim();
          const composer = tableMatch[2].trim();
          if (songName && composer && songName !== 'ê³¡ëª…' && composer !== 'ì €ì‘ì') {
            credits[songName.toLowerCase()] = composer;
          }
          continue;
        }

        // íŒ¨í„´ 4: "Composer\tJay Made (GL Music) / Camilia (Lifted House)" í˜•ì‹
        // íƒ­ìœ¼ë¡œ êµ¬ë¶„ëœ Composer í•„ë“œ
        const composerTabMatch = line.match(/^Composer\s+(.+)$/i);
        if (composerTabMatch && currentSong) {
          const composerInfo = composerTabMatch[1].trim();
          currentCredits.push(composerInfo);
          continue;
        }

        // íŒ¨í„´ 5: ì‘ê³¡/ì‘ì‚¬/í¸ê³¡/writersë¡œ ì‹œì‘í•˜ëŠ” í¬ë ˆë”§ ë¼ì¸
        const isKoreanCredit = /^(ì‘ê³¡|ì‘ì‚¬|í¸ê³¡|writers?|composer|lyricist|arranger)\s*[-:ï¼š]?\s*/i.test(line);

        // íŒ¨í„´ 6: í¼ì„¼íŠ¸(%)ê°€ í¬í•¨ëœ í¬ë ˆë”§ ë¼ì¸ (Jose Manuel 50% í˜•ì‹)
        const hasPercentage = /%/.test(line);

        // íŒ¨í„´ 7: PEERMUSICì´ í¬í•¨ëœ ë¼ì¸ (í¬ë ˆë”§ ì •ë³´)
        const hasPeermusic = /PEERMUSIC/i.test(line);

        if (currentSong && (isKoreanCredit || hasPercentage || hasPeermusic)) {
          // í¬ë ˆë”§ ì •ë³´ ì¶”ì¶œ
          let creditInfo = line
            .replace(/^(ì‘ê³¡|ì‘ì‚¬|í¸ê³¡|writers?|composer|lyricist|arranger)\s*[-:ï¼š]?\s*/i, '')
            .replace(/\s*PEERMUSIC\s*$/i, '') // ëì˜ PEERMUSIC ì œê±°
            .replace(/\s*\d+(\.\d+)?%/g, '') // í¼ì„¼íŠ¸ ì •ë³´ ì œê±°
            .trim();
          if (creditInfo) {
            currentCredits.push(creditInfo);
          }
        } else if (!isKoreanCredit && !hasPercentage && !hasPeermusic && line.length > 0 && !/^Composer/i.test(line)) {
          // ìƒˆë¡œìš´ ê³¡ëª…ìœ¼ë¡œ ì¸ì‹ (ê¸°ì¡´ í˜•ì‹)
          // ì´ì „ ê³¡ ì €ì¥
          if (currentSong && currentCredits.length > 0) {
            credits[currentSong.toLowerCase()] = currentCredits.join(', ');
          }
          currentSong = line;
          currentCredits = [];
        }
      }

      // ë§ˆì§€ë§‰ ê³¡ ì €ì¥
      if (currentSong && currentCredits.length > 0) {
        credits[currentSong.toLowerCase()] = currentCredits.join(', ');
      }

      return credits;
    };

    const getScoreColor = (score) => {
      const colors = { '5.0': 'from-emerald-500 to-emerald-600', '4.5': 'from-blue-500 to-blue-600', '4.0': 'from-cyan-500 to-cyan-600', '3.5': 'from-purple-500 to-purple-600', '3.0': 'from-amber-500 to-amber-600', '2.5': 'from-orange-500 to-orange-600', '2.0': 'from-red-500 to-red-600', '1.5': 'from-gray-500 to-gray-600', '1.0': 'from-gray-400 to-gray-500' };
      return colors[score] || 'from-gray-300 to-gray-400';
    };

    const StarRating = React.memo(({ value, onChange }) => {
      const [hover, setHover] = useState(0);
      return (
        <div className="flex gap-1 items-center">
          {[1,2,3,4,5].map(i => (
            <span key={i} className={`star ${(hover || parseFloat(value) || 0) >= i ? 'filled' : 'empty'}`}
              onMouseEnter={() => setHover(i)} onMouseLeave={() => setHover(0)}
              onClick={() => onChange(i + '.0')}>{(hover || parseFloat(value) || 0) >= i ? 'â˜…' : 'â˜†'}</span>
          ))}
          {value && <span className="ml-2 text-lg font-bold text-white">{value}</span>}
        </div>
      );
    });

    function DemoReviewSystem() {
      const [songs, setSongs] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [reviews, setReviews] = useState({});
      const [view, setView] = useState('upload'); // upload, credit, review, list
      const [artistName, setArtistName] = useState('');
      const [searchTerm, setSearchTerm] = useState('');
      const [filterStatus, setFilterStatus] = useState('all');
      const [creditText, setCreditText] = useState('');
      const [pendingSongs, setPendingSongs] = useState([]);
      const [presetVersion, setPresetVersion] = useState(0); // í”„ë¦¬ì…‹ ì„ íƒ ì‹œ ì¦ê°€í•˜ì—¬ í”¼ë“œë°± í•„ë“œ ì¬ìƒì„±

      const folderInputRef = useRef(null);
      const creditTextRef = useRef('');

      const STORAGE_KEY = 'peermusic_demo_reviews_v6';
      const SONGS_KEY = 'peermusic_demo_songs_v6';
      const META_KEY = 'peermusic_demo_meta_v6';

      useEffect(() => {
        const savedReviews = localStorage.getItem(STORAGE_KEY);
        const savedSongs = localStorage.getItem(SONGS_KEY);
        const savedMeta = localStorage.getItem(META_KEY);
        if (savedReviews) try { setReviews(JSON.parse(savedReviews)); } catch (e) {}
        if (savedSongs) try { const s = JSON.parse(savedSongs); setSongs(s); if (s.length > 0) setView('review'); } catch (e) {}
        if (savedMeta) try { const m = JSON.parse(savedMeta); setArtistName(m.artistName || ''); } catch (e) {}
      }, []);

      useEffect(() => { if (Object.keys(reviews).length > 0) localStorage.setItem(STORAGE_KEY, JSON.stringify(reviews)); }, [reviews]);
      useEffect(() => { if (songs.length > 0) localStorage.setItem(SONGS_KEY, JSON.stringify(songs)); }, [songs]);
      useEffect(() => { localStorage.setItem(META_KEY, JSON.stringify({ artistName })); }, [artistName]);

      const currentSong = songs[currentIndex] || null;
      const currentReview = currentSong ? (reviews[currentSong.id] || {
        í”¼ë“œë°±: '',
        ì¥ë¥´: currentSong.ì¥ë¥´ || '',  // ìë™ ì¶”ì¶œëœ ì¥ë¥´ ì‚¬ìš©
        ì ìˆ˜: '',
        OPëª…: currentSong.OPëª…,
        ì €ì‘ì: currentSong.ì €ì‘ì
      }) : null;
      const reviewedCount = useMemo(() => songs.filter(s => reviews[s.id]?.ì ìˆ˜).length, [songs, reviews]);
      const progress = songs.length > 0 ? ((reviewedCount / songs.length) * 100).toFixed(0) : 0;

      const filteredSongs = useMemo(() => {
        return songs.filter(song => {
          const review = reviews[song.id] || {};
          const matchesSearch = song.ê³¡ëª….toLowerCase().includes(searchTerm.toLowerCase()) ||
            song.ì €ì‘ì.toLowerCase().includes(searchTerm.toLowerCase()) ||
            (review.OPëª… || song.OPëª… || '').toLowerCase().includes(searchTerm.toLowerCase());
          if (filterStatus === 'reviewed') return matchesSearch && review?.ì ìˆ˜;
          if (filterStatus === 'pending') return matchesSearch && !review?.ì ìˆ˜;
          if (filterStatus === 'recommended') return matchesSearch && parseFloat(review?.ì ìˆ˜ || 0) >= 4.0;
          return matchesSearch;
        });
      }, [songs, reviews, searchTerm, filterStatus]);

      // í´ë” ì—…ë¡œë“œ ì²˜ë¦¬
      const handleFolderUpload = async (files) => {
        const audioFiles = Array.from(files).filter(f => {
          const isAudio = /\.(mp3|wav|m4a|flac|aiff)$/i.test(f.name);
          const isMacOS = f.webkitRelativePath?.includes('__MACOSX') || f.name.startsWith('._');
          return isAudio && !isMacOS;
        });

        if (audioFiles.length === 0) {
          alert('ìŒì› íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.\n\nì§€ì› í˜•ì‹: MP3, WAV, M4A, FLAC, AIFF');
          return;
        }

        const firstPath = audioFiles[0].webkitRelativePath || '';
        const detectedArtist = extractArtistFromPath(firstPath);
        if (detectedArtist && !artistName) setArtistName(detectedArtist);

        const newSongs = audioFiles.map((file, idx) => {
          const path = file.webkitRelativePath || file.name;
          const parsed = parseFileName(file.name, path);

          // í´ë” ê²½ë¡œì—ì„œ ë‚ ì§œ ì¶”ì¶œ ì‹œë„, ì—†ìœ¼ë©´ íŒŒì¼ ìˆ˜ì •ì¼ ì‚¬ìš©
          const extractedDate = extractDateFromPath(path);
          const uploadDate = extractedDate || formatDate(file.lastModified);

          return {
            id: Date.now() + idx + Math.random(),
            ê³¡ëª…: parsed.songName,
            ì €ì‘ì: parsed.composer,
            OPëª…: parsed.opName,
            ì´ë©”ì¼: parsed.email,
            ì¥ë¥´: parsed.genre || '',  // ìë™ ì¶”ì¶œëœ ì¥ë¥´
            BPM: parsed.bpm || '',     // ìë™ ì¶”ì¶œëœ BPM
            ì›ë³¸íŒŒì¼ëª…: file.name,
            ì›ë³¸ê²½ë¡œ: path,
            ì—…ë¡œë“œë‚ ì§œ: uploadDate,
            ì¶”ê°€ì¼ì‹œ: new Date().toISOString()
          };
        });

        // í¬ë ˆë”§ ì…ë ¥ í™”ë©´ìœ¼ë¡œ ì´ë™
        setPendingSongs(newSongs);
        setView('credit');
      };

      // ê³¡ëª… ì •ê·œí™” (íŠ¹ìˆ˜ë¬¸ì í†µì¼, ê³µë°± ì •ë¦¬)
      const normalizeSongName = (name) => {
        return name
          .toLowerCase()
          .replace(/[Â´`'']/g, "'")  // ë‹¤ì–‘í•œ ì–´í¬ìŠ¤íŠ¸ë¡œí”¼ í†µì¼
          .replace(/[""]/g, '"')    // ë”°ì˜´í‘œ í†µì¼
          .replace(/\s+/g, ' ')     // ê³µë°± ì •ë¦¬
          .trim();
      };

      // í¬ë ˆë”§ ì ìš© ë° ê²€í†  ì‹œì‘
      const applyCreditsAndStart = () => {
        let updatedSongs = [...pendingSongs];
        const textToUse = creditTextRef.current || creditText;

        if (textToUse.trim()) {
          const credits = parseCreditText(textToUse);

          // ì •ê·œí™”ëœ í‚¤ë¡œ í¬ë ˆë”§ ë§µ ì¬ìƒì„±
          const normalizedCredits = {};
          for (const [key, value] of Object.entries(credits)) {
            normalizedCredits[normalizeSongName(key)] = value;
          }

          updatedSongs = pendingSongs.map(song => {
            const songNameNormalized = normalizeSongName(song.ê³¡ëª…);
            const matchedCredit = normalizedCredits[songNameNormalized];

            if (matchedCredit) {
              return {
                ...song,
                ì €ì‘ì: matchedCredit
              };
            }
            return song;
          });
        }

        setSongs(prev => [...prev, ...updatedSongs]);
        setPendingSongs([]);
        setCreditText('');
        creditTextRef.current = '';
        setView('review');
        alert(`${updatedSongs.length}ê³¡ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      };

      // í¬ë ˆë”§ ì—†ì´ ì§„í–‰
      const skipCredits = () => {
        setSongs(prev => [...prev, ...pendingSongs]);
        setPendingSongs([]);
        setCreditText('');
        creditTextRef.current = '';
        setView('review');
        alert(`${pendingSongs.length}ê³¡ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      };

      const handleUpdate = (field, value) => {
        if (!currentSong) return;
        setReviews(prev => ({ ...prev, [currentSong.id]: { ...currentReview, [field]: value } }));
      };

      const goNext = () => { if (currentIndex < songs.length - 1) setCurrentIndex(currentIndex + 1); };
      const goPrev = () => { if (currentIndex > 0) setCurrentIndex(currentIndex - 1); };
      const goToSong = (idx) => { setCurrentIndex(idx); setView('review'); };
      const deleteSong = (id) => {
        if (confirm('ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
          setSongs(prev => prev.filter(s => s.id !== id));
          setReviews(prev => { const n = { ...prev }; delete n[id]; return n; });
          if (currentIndex >= songs.length - 1) setCurrentIndex(Math.max(0, songs.length - 2));
        }
      };

      // CSV ë‹¤ìš´ë¡œë“œ
      const downloadCSV = () => {
        try {
          const allData = songs.map(song => {
            const review = reviews[song.id] || {};
            const opName = review.OPëª… || song.OPëª… || '';
            const composerInfo = review.ì €ì‘ì || song.ì €ì‘ì || '';

            return {
              'ìŒì›ì—…ë¡œë“œë‚ ì§œ': song.ì—…ë¡œë“œë‚ ì§œ || new Date().toISOString().split('T')[0],
              'ì €ì‘ì ì •ë³´': composerInfo,
              'ì›ë³¸ ë°ëª¨ ì‘í’ˆëª…': song.ê³¡ëª…,
              'PITCHING ë°ëª¨': `${song.ê³¡ëª…}_${opName}_Pitched by MC`,
              'OPëª… / ì‘ê°€ëª…': opName,
              'Genre': review.ì¥ë¥´ || '',
              'Tag(Note)': review.í”¼ë“œë°± || '',
              'Note(ì„ í˜¸ë„)': review.ì ìˆ˜ ? `${review.ì ìˆ˜}/5` : '',
              'ì´ë©”ì¼ ì£¼ì†Œ': review.ì´ë©”ì¼ || song.ì´ë©”ì¼ || '',
              'í”¼ì¹­ ì•„í‹°ìŠ¤íŠ¸': artistName
            };
          });

          const convertToCSV = (data) => {
            if (data.length === 0) return '';
            const headers = Object.keys(data[0]);
            const csvRows = [headers.join(',')];
            for (const row of data) {
              const values = headers.map(h => {
                const v = String(row[h] || '');
                return (v.includes(',') || v.includes('"') || v.includes('\n')) ? `"${v.replace(/"/g, '""')}"` : v;
              });
              csvRows.push(values.join(','));
            }
            return csvRows.join('\n');
          };

          const BOM = '\uFEFF';
          const today = new Date().toISOString().split('T')[0].replace(/-/g, '.');

          const blob = new Blob([BOM + convertToCSV(allData)], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = `${artistName || 'DEMO'}_ì „ì²´DEMO_${today}.csv`;
          link.click();

          const recommended = allData.filter((_, i) => parseFloat(reviews[songs[i].id]?.ì ìˆ˜ || 0) >= 4.0);
          if (recommended.length > 0) {
            setTimeout(() => {
              const blob2 = new Blob([BOM + convertToCSV(recommended)], { type: 'text/csv;charset=utf-8;' });
              const link2 = document.createElement('a');
              link2.href = URL.createObjectURL(blob2);
              link2.download = `${artistName || 'DEMO'}_ì¶”ì²œDEMO_${today}.csv`;
              link2.click();
            }, 500);
          }

          alert(`ë‹¤ìš´ë¡œë“œ ì™„ë£Œ\nì „ì²´: ${allData.length}ê³¡ | ì¶”ì²œ: ${recommended.length}ê³¡`);
        } catch (error) { alert('ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: ' + error.message); }
      };

      const resetAll = () => {
        if (confirm('ëª¨ë“  ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
          setSongs([]); setReviews({}); setCurrentIndex(0); setView('upload'); setArtistName('');
          localStorage.removeItem(STORAGE_KEY); localStorage.removeItem(SONGS_KEY);
        }
      };

      // ì—…ë¡œë“œ í™”ë©´
      const UploadView = () => (
        <div className="min-h-screen flex items-center justify-center p-6 fade-in">
          <div className="w-full max-w-2xl">
            <div className="text-center mb-12">
              <h1 className="text-5xl font-bold gradient-text mb-2">PEERMUSIC</h1>
              <p className="text-gray-500 text-lg">DEMO Review System</p>
            </div>

            <div
              className="upload-zone rounded-3xl p-16 text-center cursor-pointer mb-4"
              onClick={() => folderInputRef.current?.click()}
            >
              <div className="text-6xl mb-6 opacity-60">ğŸ“‚</div>
              <h2 className="text-2xl font-semibold text-white mb-3">
                í´ë¦­í•˜ì—¬ í´ë” ì„ íƒ
              </h2>
              <p className="text-gray-500">MP3, WAV, M4A, FLAC, AIFF</p>
              <input
                ref={folderInputRef}
                type="file"
                webkitdirectory=""
                directory=""
                multiple
                onChange={(e) => e.target.files && handleFolderUpload(e.target.files)}
                className="hidden"
              />
            </div>

            {songs.length > 0 && (
              <div className="glass rounded-2xl p-6 text-center mb-4">
                <p className="text-gray-400 mb-3">ì €ì¥ëœ ë°ì´í„°: <span className="text-white font-bold">{songs.length}ê³¡</span> ({reviewedCount}ê³¡ ì™„ë£Œ)</p>
                <div className="flex gap-3 justify-center">
                  <button onClick={() => setView('review')} className="btn-primary px-8 py-3 rounded-xl text-white font-medium">
                    ì´ì–´ì„œ ê²€í† í•˜ê¸° â†’
                  </button>
                  <button onClick={resetAll} className="px-6 py-3 rounded-xl bg-red-500/20 text-red-400 hover:bg-red-500/30 font-medium border border-red-500/30">
                    ğŸ—‘ï¸ ì´ˆê¸°í™”
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>
      );

      const CreditView = () => (
        <div className="min-h-screen flex items-center justify-center p-6 fade-in">
          <div className="w-full max-w-3xl">
            <div className="text-center mb-8">
              <h1 className="text-3xl font-bold text-white mb-2">í¬ë ˆë”§ ì •ë³´ ì…ë ¥</h1>
              <p className="text-gray-500">ì—…ë¡œë“œëœ {pendingSongs.length}ê³¡ì˜ ì¶”ê°€ ì €ì‘ì ì •ë³´ë¥¼ ì…ë ¥í•˜ì„¸ìš”</p>
            </div>

            {/* ì—…ë¡œë“œëœ ê³¡ ëª©ë¡ */}
            <div className="glass rounded-2xl p-4 mb-6 max-h-48 overflow-y-auto">
              <h3 className="text-sm font-medium text-gray-400 mb-3">ì—…ë¡œë“œëœ ê³¡ ëª©ë¡</h3>
              <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                {pendingSongs.map((song, idx) => (
                  <div key={idx} className="credit-item px-3 py-2 rounded-lg text-sm">
                    <span className="text-white">{song.ê³¡ëª…}</span>
                    {song.ì €ì‘ì && <span className="text-gray-500 text-xs block">{song.ì €ì‘ì}</span>}
                  </div>
                ))}
              </div>
            </div>

            {/* í¬ë ˆë”§ ì…ë ¥ */}
            <div className="glass rounded-2xl p-6 mb-6">
              <h3 className="text-white font-medium mb-3">ğŸ“ ì¶”ê°€ í¬ë ˆë”§ ì •ë³´ (ì„ íƒì‚¬í•­)</h3>
              <p className="text-gray-500 text-sm mb-4">
                ê³¡ëª…ì„ ë¨¼ì € ì“°ê³ , ê·¸ ì•„ë˜ì— ì‘ê³¡/ì‘ì‚¬/í¸ê³¡ ë˜ëŠ” writers ì •ë³´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.
              </p>
              <CreditTextArea textRef={creditTextRef} />
            </div>

            {/* ë²„íŠ¼ */}
            <div className="flex gap-4">
              <button
                onClick={() => { setPendingSongs([]); setCreditText(''); creditTextRef.current = ''; setView('upload'); }}
                className="flex-1 btn-secondary py-4 rounded-xl text-gray-300 font-medium"
              >
                â† ì·¨ì†Œ
              </button>
              <button
                onClick={skipCredits}
                className="flex-1 btn-secondary py-4 rounded-xl text-gray-300 font-medium"
              >
                ê±´ë„ˆë›°ê¸°
              </button>
              <button
                onClick={applyCreditsAndStart}
                className="flex-1 btn-primary py-4 rounded-xl text-white font-medium"
              >
                ì ìš© ë° ê²€í†  ì‹œì‘ â†’
              </button>
            </div>
          </div>
        </div>
      );

      // ê²€í†  í™”ë©´
      const ReviewView = () => {
        if (!currentSong) return (
          <div className="min-h-screen flex items-center justify-center">
            <div className="text-center">
              <p className="text-xl text-gray-500 mb-4">ê²€í† í•  ê³¡ì´ ì—†ìŠµë‹ˆë‹¤</p>
              <button onClick={() => setView('upload')} className="btn-primary px-6 py-3 rounded-xl text-white">ê³¡ ì¶”ê°€</button>
            </div>
          </div>
        );

        return (
          <div className="max-w-5xl mx-auto p-4 md:p-6 fade-in">
            <div className="glass rounded-2xl p-4 mb-4">
              <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
                <div className="flex items-center gap-4">
                  <button onClick={() => setView('upload')} className="p-2 hover:bg-white/10 rounded-lg text-gray-400 hover:text-white">ğŸ </button>
                  <div>
                    <StableInput
                      key={`artist-${artistName ? 'set' : 'empty'}`}
                      initialValue={artistName}
                      onValueChange={(v) => setArtistName(v)}
                      className="text-xl font-bold text-white bg-transparent border-b border-transparent hover:border-gray-600 focus:border-indigo-500 outline-none"
                      placeholder="ì•„í‹°ìŠ¤íŠ¸ëª… ì…ë ¥"
                    />
                    <p className="text-sm text-gray-500">{songs.length}ê³¡</p>
                  </div>
                </div>
                <div className="flex items-center gap-3">
                  <button onClick={() => setView('list')} className="px-4 py-2 rounded-lg text-gray-400 hover:text-white hover:bg-white/10">ğŸ“‹ ëª©ë¡</button>
                  <button onClick={downloadCSV} className="btn-primary px-4 py-2 rounded-lg text-white font-medium">ğŸ“¥ CSV</button>
                </div>
              </div>
              <div className="mt-4">
                <div className="flex justify-between text-sm mb-1">
                  <span className="text-gray-500">ì§„í–‰ë¥ </span>
                  <span className="text-white font-medium">{reviewedCount} / {songs.length} ({progress}%)</span>
                </div>
                <div className="h-1.5 bg-gray-800 rounded-full overflow-hidden">
                  <div className="h-full bg-gradient-to-r from-indigo-500 to-purple-500 transition-all" style={{ width: `${progress}%` }} />
                </div>
              </div>
            </div>

            <div className="flex gap-4 items-stretch">
              <button onClick={goPrev} disabled={currentIndex === 0}
                className="nav-button hidden md:flex items-center justify-center w-14 glass rounded-2xl hover:bg-white/5 text-gray-400 hover:text-white"
                style={{ '--direction': '-5px' }}><span className="text-2xl">â†</span></button>

              <div className="flex-1 glass rounded-3xl p-6 md:p-8">
                <div className="text-center mb-6">
                  <span className="inline-block px-3 py-1 bg-indigo-500/20 text-indigo-400 rounded-full text-sm font-medium mb-3">#{currentIndex + 1}</span>
                  <h2 className="text-3xl md:text-4xl font-bold text-white mb-1">{currentSong.ê³¡ëª…}</h2>
                  <p className="text-gray-500 text-sm">{currentSong.ì—…ë¡œë“œë‚ ì§œ} | {currentSong.ì›ë³¸íŒŒì¼ëª…}</p>
                </div>

                <div className="space-y-5">
                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-2">ì €ì‘ì ì •ë³´</label>
                    <StableInput
                      key={`composer-${currentSong?.id}`}
                      initialValue={currentReview.ì €ì‘ì ?? currentSong.ì €ì‘ì ?? ''}
                      onValueChange={(v) => handleUpdate('ì €ì‘ì', v)}
                      className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                      placeholder="ì˜ˆ: OneTop, Zeenan"
                    />
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-400 mb-2">OPëª… / ì‘ê°€ëª…</label>
                      <StableInput
                        key={`op-${currentSong?.id}`}
                        initialValue={currentReview.OPëª… ?? currentSong.OPëª… ?? ''}
                        onValueChange={(v) => handleUpdate('OPëª…', v)}
                        className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                        placeholder="ì˜ˆ: OneTop, SJJ"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-400 mb-2">ì´ë©”ì¼</label>
                      <StableInput
                        key={`email-${currentSong?.id}`}
                        initialValue={currentReview.ì´ë©”ì¼ ?? currentSong.ì´ë©”ì¼ ?? ''}
                        onValueChange={(v) => handleUpdate('ì´ë©”ì¼', v)}
                        className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                        placeholder="ì´ë©”ì¼ ì£¼ì†Œ"
                      />
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-3 text-center">ì„ í˜¸ë„</label>
                    <div className="flex justify-center"><StarRating value={currentReview.ì ìˆ˜} onChange={(v) => handleUpdate('ì ìˆ˜', v)} /></div>
                    <div className="flex flex-wrap justify-center gap-2 mt-3">
                      {SCORES.map(s => (
                        <button key={s} onClick={() => handleUpdate('ì ìˆ˜', s)}
                          className={`px-3 py-1 rounded-lg text-sm font-medium transition-all ${currentReview.ì ìˆ˜ === s ? `bg-gradient-to-r ${getScoreColor(s)} text-white` : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>{s}</button>
                      ))}
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-2">Genre</label>
                    <StableInput
                      key={`genre-${currentSong?.id}`}
                      initialValue={currentReview.ì¥ë¥´ || ''}
                      onValueChange={(v) => handleUpdate('ì¥ë¥´', v)}
                      className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                      placeholder="ì˜ˆ: ë°œë¼ë“œ, ì–´ì¿ ìŠ¤í‹± íŒ, POP BALLAD"
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-2">Tag(Note)</label>
                    <select value={FEEDBACK_PRESETS.includes(currentReview.í”¼ë“œë°±) ? currentReview.í”¼ë“œë°± : ''}
                      onChange={(e) => {
                        if (e.target.value) {
                          handleUpdate('í”¼ë“œë°±', e.target.value);
                          setPresetVersion(v => v + 1); // í”¼ë“œë°± í•„ë“œ ì¬ìƒì„±
                        }
                      }}
                      className="w-full bg-black/50 text-white px-4 py-3 rounded-xl border border-gray-700 focus:border-indigo-500 mb-2">
                      <option value="">í”„ë¦¬ì…‹ ì„ íƒ</option>
                      {FEEDBACK_PRESETS.map(p => <option key={p} value={p}>{p}</option>)}
                    </select>
                    <StableTextarea
                      key={`feedback-${currentSong?.id}-${presetVersion}`}
                      initialValue={currentReview.í”¼ë“œë°± || ''}
                      onValueChange={(v) => handleUpdate('í”¼ë“œë°±', v)}
                      className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500 resize-none"
                      rows={2}
                      placeholder="í”¼ë“œë°± ì…ë ¥..."
                    />
                  </div>

                  {parseFloat(currentReview.ì ìˆ˜ || 0) >= 4.0 && (
                    <div className="text-center">
                      <span className="inline-block px-4 py-2 bg-gradient-to-r from-rose-500 to-pink-500 text-white rounded-xl font-bold">â¤ï¸ ì¶”ì²œê³¡</span>
                    </div>
                  )}
                </div>

                <div className="flex md:hidden gap-3 mt-6">
                  <button onClick={goPrev} disabled={currentIndex === 0} className="flex-1 py-3 bg-gray-800 rounded-xl text-white disabled:opacity-40">â† ì´ì „</button>
                  <button onClick={goNext} disabled={currentIndex === songs.length - 1} className="flex-1 py-3 btn-primary rounded-xl text-white disabled:opacity-40">ë‹¤ìŒ â†’</button>
                </div>
              </div>

              <button onClick={goNext} disabled={currentIndex === songs.length - 1}
                className="nav-button hidden md:flex items-center justify-center w-14 glass rounded-2xl hover:bg-white/5 text-gray-400 hover:text-white"
                style={{ '--direction': '5px' }}><span className="text-2xl">â†’</span></button>
            </div>

            <div className="mt-4 glass rounded-xl p-4">
              <div className="flex items-center justify-between">
                <button onClick={() => setCurrentIndex(0)} className="text-sm text-gray-500 hover:text-white">â®ï¸</button>
                <div className="flex items-center gap-2">
                  <input type="number" min={1} max={songs.length} value={currentIndex + 1}
                    onChange={(e) => { const i = parseInt(e.target.value) - 1; if (i >= 0 && i < songs.length) setCurrentIndex(i); }}
                    className="w-14 bg-black/30 text-white text-center px-2 py-1 rounded-lg border border-gray-800" />
                  <span className="text-gray-500">/ {songs.length}</span>
                </div>
                <button onClick={() => setCurrentIndex(songs.length - 1)} className="text-sm text-gray-500 hover:text-white">â­ï¸</button>
              </div>
            </div>
          </div>
        );
      };

      // ëª©ë¡ í™”ë©´
      const ListView = () => (
        <div className="max-w-6xl mx-auto p-4 md:p-6 fade-in">
          <div className="glass rounded-2xl p-4 mb-4">
            <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
              <div className="flex items-center gap-4">
                <button onClick={() => setView('review')} className="text-gray-400 hover:text-white">â† ê²€í† </button>
                <h1 className="text-xl font-bold text-white">ì „ì²´ ëª©ë¡ ({filteredSongs.length}ê³¡)</h1>
              </div>
              <div className="flex gap-3">
                <button onClick={downloadCSV} className="btn-primary px-4 py-2 rounded-lg text-white font-medium">ğŸ“¥ CSV</button>
                <button onClick={resetAll} className="px-4 py-2 rounded-lg bg-red-500/20 text-red-400 hover:bg-red-500/30">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
              </div>
            </div>
          </div>

          <div className="glass rounded-2xl p-4 mb-4">
            <div className="flex flex-col md:flex-row gap-4">
              <input
                type="text"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="flex-1 bg-black/30 text-white px-4 py-2 rounded-xl border border-gray-800 focus:border-indigo-500"
                placeholder="ğŸ” ê²€ìƒ‰..."
              />
              <div className="flex gap-2">
                {[{ k: 'all', l: 'ì „ì²´' }, { k: 'reviewed', l: 'ì™„ë£Œ' }, { k: 'pending', l: 'ë¯¸ê²€í† ' }, { k: 'recommended', l: 'ì¶”ì²œ' }].map(({ k, l }) => (
                  <button key={k} onClick={() => setFilterStatus(k)}
                    className={`px-4 py-2 rounded-xl font-medium ${filterStatus === k ? 'btn-primary text-white' : 'bg-gray-800 text-gray-400'}`}>{l}</button>
                ))}
              </div>
            </div>
          </div>

          <div className="glass rounded-2xl overflow-hidden">
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead className="bg-black/30">
                  <tr>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">#</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">ê³¡ëª…</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">ì €ì‘ì</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">OPëª…</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">ë‚ ì§œ</th>
                    <th className="px-4 py-3 text-center text-sm font-medium text-gray-400">ì ìˆ˜</th>
                    <th className="px-4 py-3 text-center text-sm font-medium text-gray-400"></th>
                  </tr>
                </thead>
                <tbody>
                  {filteredSongs.map(song => {
                    const review = reviews[song.id] || {};
                    const idx = songs.findIndex(s => s.id === song.id);
                    const isRec = parseFloat(review.ì ìˆ˜ || 0) >= 4.0;
                    return (
                      <tr key={song.id} className="border-t border-gray-800 hover:bg-white/5">
                        <td className="px-4 py-3 text-sm text-gray-500">{idx + 1}</td>
                        <td className="px-4 py-3">
                          <button onClick={() => goToSong(idx)} className="text-indigo-400 hover:underline">{song.ê³¡ëª…}</button>
                          {isRec && <span className="ml-2">â¤ï¸</span>}
                        </td>
                        <td className="px-4 py-3 text-sm text-gray-400">{review.ì €ì‘ì || song.ì €ì‘ì || '-'}</td>
                        <td className="px-4 py-3 text-sm text-gray-400">{review.OPëª… || song.OPëª… || '-'}</td>
                        <td className="px-4 py-3 text-sm text-gray-500">{song.ì—…ë¡œë“œë‚ ì§œ}</td>
                        <td className="px-4 py-3 text-center">
                          {review.ì ìˆ˜ && <span className={`px-2 py-1 rounded-full text-xs font-bold text-white bg-gradient-to-r ${getScoreColor(review.ì ìˆ˜)}`}>{review.ì ìˆ˜}</span>}
                        </td>
                        <td className="px-4 py-3 text-center">
                          <button onClick={() => deleteSong(song.id)} className="text-red-400 hover:text-red-300">ğŸ—‘ï¸</button>
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>

          <div className="mt-4 grid grid-cols-4 gap-4">
            {[{ n: songs.length, l: 'ì „ì²´', c: 'text-indigo-400' }, { n: reviewedCount, l: 'ì™„ë£Œ', c: 'text-emerald-400' },
              { n: songs.length - reviewedCount, l: 'ë¯¸ê²€í† ', c: 'text-amber-400' },
              { n: songs.filter(s => parseFloat(reviews[s.id]?.ì ìˆ˜ || 0) >= 4.0).length, l: 'ì¶”ì²œ', c: 'text-rose-400' }
            ].map(({ n, l, c }) => (
              <div key={l} className="glass rounded-xl p-4 text-center">
                <div className={`text-2xl font-bold ${c}`}>{n}</div>
                <div className="text-sm text-gray-500">{l}</div>
              </div>
            ))}
          </div>
        </div>
      );

      return (
        <div className="min-h-screen">
          {view === 'upload' && UploadView()}
          {view === 'credit' && CreditView()}
          {view === 'review' && ReviewView()}
          {view === 'list' && ListView()}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<DemoReviewSystem />);
  </script>
</body>
</html>
