<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PEERMUSIC DEMO 검토 시스템</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');

    * {
      font-family: 'Inter', 'Noto Sans KR', sans-serif;
    }

    body {
      background: #0a0a0a;
    }

    .glass {
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .gradient-text {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .upload-zone {
      border: 2px dashed rgba(255,255,255,0.15);
      transition: all 0.3s ease;
    }

    .upload-zone:hover {
      border-color: #667eea;
      background: rgba(102,126,234,0.1);
      transform: scale(1.01);
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      transition: all 0.3s ease;
    }

    .btn-primary:hover {
      box-shadow: 0 10px 40px rgba(102,126,234,0.3);
      transform: translateY(-2px);
    }

    .btn-secondary {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      transition: all 0.3s ease;
    }

    .btn-secondary:hover {
      background: rgba(255,255,255,0.15);
    }

    .star { cursor: pointer; transition: all 0.2s ease; font-size: 28px; }
    .star:hover { transform: scale(1.2); }
    .star.filled { color: #fbbf24; }
    .star.empty { color: #4b5563; }

    input:focus, textarea:focus, select:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
    }

    .fade-in { animation: fadeIn 0.4s ease-out; }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: #1a1a1a; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: #444; }

    .nav-button { transition: all 0.3s ease; }
    .nav-button:hover:not(:disabled) { transform: translateX(var(--direction, 0)); }
    .nav-button:disabled { opacity: 0.3; cursor: not-allowed; }

    .credit-item {
      background: rgba(102,126,234,0.1);
      border: 1px solid rgba(102,126,234,0.3);
    }
  </style>
</head>
<body class="min-h-screen">
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    const FEEDBACK_PRESETS = [
      '데모의 퀄리티가 현저히 낮음',
      '송리드와 상이한 데모',
      '아티스트와 어울리지 않는 데모',
      '곡은 좋으나 해당 리드와는 어울리지 않는 데모'
    ];

    const SCORES = ['5.0', '4.5', '4.0', '3.5', '3.0', '2.5', '2.0', '1.5', '1.0'];

    // 장르 키워드 목록 (자동 분류용)
    const GENRE_KEYWORDS = [
      'House', 'Hiphop', 'Hip-Hop', 'Hip Hop', 'Pop', 'Rock', 'Ballad', 'R&B', 'RnB',
      'Dance', 'EDM', 'Electronic', 'Jazz', 'Soul', 'Funk', 'Disco', 'Reggae',
      'Country', 'Folk', 'Blues', 'Classical', 'Latin', 'Trap', 'Drill', 'Rage',
      'K-Pop', 'J-Pop', 'City Pop', 'Synth', 'Acoustic', 'Alternative',
      'Indie', 'Metal', 'Punk', 'Grunge', 'Lo-Fi', 'Lofi', 'Chill',
      'Afrobeat', 'Reggaeton', 'Moombahton', 'Future Bass', 'Dubstep',
      'Trance', 'Techno', 'Progressive', 'Ambient', 'New Age',
      'Gospel', 'Worship', 'Christmas', 'Slow Jam', 'Uptempo',
      'Midtempo', 'Downtempo', 'UK Garage', 'Garage', 'Grime',
      'HIP&GEN-Z', 'GEN-Z', 'Y2K', 'Retro', 'Modern', '80s', '90s'
    ];

    // 장르 키워드인지 확인
    const isGenreKeyword = (text) => {
      const lowerText = text.toLowerCase().replace(/[&-]/g, '');
      return GENRE_KEYWORDS.some(genre =>
        lowerText.includes(genre.toLowerCase().replace(/[&-]/g, ''))
      );
    };

    // 알려진 작곡가 목록 (자동 인식용)
    const KNOWN_COMPOSERS = new Set([
      'Smob', 'SMOB', 'Sooyoon', 'Zomay', 'Chris Alice', 'TAN', 'Sisyphus',
      '영원희', 'Karrinator', '케빈오빠', 'MOGT', 'YUSU', 'OneTop', 'Zeenan',
      'Andy', '서정진', '전근화', 'Weeky1', 'BT', '유정훈', '박민우', '박현규',
      '오영빈', 'Noheul', '노을', '차민호', 'Adam Argyle', 'Phil Plested',
      'Ron Irving', 'Dave Pickell', 'Ben Charles', 'Jose Manuel',
      "NU'MAKER", 'I-NORI', 'Gusten Dahlqvist', 'Jes Meinertz',
      'June', 'KWH', 'Andreas', '서의성', '정진욱', '이성혁',
      '김원', 'Renjin Zhao', 'J.S'  // 추가
    ]);

    // 이메일/폴더명 → OP명 매핑 (확장됨)
    const EMAIL_TO_OP = {
      // 기존 매핑
      'tos92@naver.com': 'To.S',
      'dctsung@naver.com': 'ES2',
      'kino1229@naver.com': 'YJH',
      'ahlgus2696@naver.com': 'PHK',
      'mildang@naver.com': 'OYB',
      'daslkfj@hanmail.net': 'JGH',
      'coollife07@naver.com': 'Noheul',
      'molesmusik@yahoo.es': 'JM',
      'twobluebirds@shaw.ca': 'RON',
      'bcabox@gmail.com': 'BEN',
      'colin.hembus@eavesmusicgroup.com': 'EavesMusic',
      'atcmusic.ar.0328@gmail.com': 'ART.M',
      // 새로운 매핑 (NEXZ JAPAN 프로젝트 등)
      'eunae.solcire@gmail.com': 'Solcire',
      'smobmusicofficial@gmail.com': 'SMOB',
      'oskar.larsson@glmusic.dk': 'GL Music',
      'hjkim@musiccombine.com': 'Music Combine',
      'purpl78@hanmail.net': 'KW',  // 김원 작가
      'modern_sound@naver.com': 'Modern Sound',
      'victoria.ree@concord.com': 'Concord',
      'info@wavecandy.com': 'Wavecandy',
      // 추가 국제 퍼블리셔
      'soundgraphics': 'SoundGraphics',
      'admin@soundgraphics.co.kr': 'SoundGraphics',
    };

    // 이메일 → 저작자 매핑 (자동 저작자 입력용)
    const EMAIL_TO_COMPOSER = {
      'purpl78@hanmail.net': '김원',
      'molesmusik@yahoo.es': 'Jose Manuel',
    };

    // 작가명 → OP명 매핑 (확장됨)
    const COMPOSER_TO_OP = {
      // 기존 매핑
      'onetop': 'OneTop',
      'zeenan': 'OneTop',
      'andy': 'OneTop',
      '서정진': 'SJJ',
      'to.s': 'To.S',
      'es2': 'ES2',
      'june': 'ES2',
      'kwh': 'ES2',
      'andreas': 'ES2',
      '서의성': 'ES2',
      '전근화': 'JGH',
      'weeky1': 'JGH',
      'bt': 'JGH',
      '정진욱': 'JGH',
      '유정훈': 'YJH',
      '박민우': 'YJH',
      '박현규': 'PHK',
      'phk': 'PHK',
      '오영빈': 'OYB',
      'noheul': 'Noheul',
      '노을': 'Noheul',
      '차민호': 'ART.M',
      'adam argyle': 'EavesMusic',
      'phil plested': 'EavesMusic',
      'nick hahn': 'EavesMusic',
      'alexander hahn': 'EavesMusic',
      'ron irving': 'RON',
      'dave pickell': 'RON',
      'corey abrams': 'RON',
      'ben charles': 'BEN',
      'jose manuel': 'JM',
      'domingo morales': 'JM',
      'santiago revilla': 'JM',
      'filo ebid': 'JM',
      'josue vergara': 'JM',
      'pablo peset': 'JM',
      // 새로운 매핑 (Solcire, SMOB, GL Music 등)
      'chris alice': 'Solcire',
      '영원희': 'Solcire',
      'sisyphus': 'Solcire',
      'tan': 'Solcire',
      'karrinator': 'Solcire',
      '케빈오빠': 'Solcire',
      'mogt': 'Solcire',
      'yusu': 'Solcire',
      'solcire': 'Solcire',
      '쏠시레': 'Solcire',
      'smob': 'SMOB',
      "nu'maker": 'SMOB',
      'i-nori': 'SMOB',
      // GL Music (북유럽)
      'gusten dahlqvist': 'GL Music',
      'cosmos': 'COS',  // COSMOS → COS
      'jes meinertz': 'GL Music',
      'johs': 'GL Music',
      'deekay': 'GL Music',
      'david west': 'GL Music',
      'lasse lindorff': 'GL Music',
      'svend gudiksen': 'GL Music',
      'mats valentin': 'GL Music',
      'jade ell': 'GL Music',
      'mattias kolstrup': 'GL Music',
      // Music Combine
      '뮤직컴바인': 'Music Combine',
      'music combine': 'Music Combine',
      // SoundGraphics
      'soundgraphics': 'SoundGraphics',
      'sg': 'SoundGraphics',
      // Concord
      'concord': 'Concord',
      // 추가 한국 작곡가
      '손연성': 'Individual',
      '주현민': 'Individual',
      '박수석': 'Individual',
      '이성혁': 'JGH',
    };

    // 이메일에서 OP명 추출 (확장됨 - 자동 추출 지원)
    const getOPFromEmail = (email) => {
      if (!email) return '';
      const emailLower = email.toLowerCase();

      // 1. 기존 매핑 테이블에서 검색
      for (const [key, value] of Object.entries(EMAIL_TO_OP)) {
        if (emailLower.includes(key.toLowerCase().split('@')[0])) {
          return value;
        }
      }

      // 2. 이메일 로컬파트에서 자동 추출
      // 예: audiofreaksmusic@gmail.com → audiofreak
      const atIndex = email.indexOf('@');
      if (atIndex > 0) {
        let localPart = email.substring(0, atIndex);

        // "music", "publishing", "records" 등의 접미사 제거
        localPart = localPart
          .replace(/music$/i, '')
          .replace(/publishing$/i, '')
          .replace(/records$/i, '')
          .replace(/productions?$/i, '')
          .replace(/entertainment$/i, '')
          .replace(/media$/i, '')
          .replace(/s$/i, ''); // 복수형 s 제거

        // 첫 글자 대문자로 변환
        if (localPart.length > 0) {
          return localPart.charAt(0).toUpperCase() + localPart.slice(1);
        }
      }

      return '';
    };

    // 저작자명에서 OP명 추출
    const getOPFromComposer = (composer) => {
      if (!composer) return '';
      const composerLower = composer.toLowerCase();
      for (const [key, value] of Object.entries(COMPOSER_TO_OP)) {
        if (composerLower.includes(key.toLowerCase())) {
          return value;
        }
      }
      return '';
    };

    // 한글 초성 추출
    const getKoreanInitials = (name) => {
      const CHO_EN = ['G','KK','N','D','DD','R','M','B','BB','S','SS','','J','JJ','CH','K','T','P','H'];
      let initials = '';
      for (let char of name) {
        const code = char.charCodeAt(0) - 44032;
        if (code >= 0 && code <= 11171) initials += CHO_EN[Math.floor(code / 588)];
      }
      return initials || name;
    };

    // 영문 이니셜 추출
    const getEnglishInitials = (name) => {
      const words = name.split(/[\s,._-]+/).filter(w => w.length > 0);
      if (words.length === 1) return name.substring(0, 3).toUpperCase();
      return words.map(w => w[0].toUpperCase()).join('');
    };

    // 폴더 경로에서 아티스트명 추출 (개선됨)
    const extractArtistFromPath = (path) => {
      const patterns = [
        // "NEXZ(일본앨범) 수록곡 전체 DEMO" → NEXZ
        /([가-힣a-zA-Z0-9]+)\s*\([^)]+\)\s*(?:수록곡\s*)?전체\s*DEMO/i,
        // "이창섭 전체 DEMO" → 이창섭
        /([가-힣a-zA-Z]+)\s*전체\s*DEMO/i,
        // "NEXZ JAPAN 데모" → NEXZ JAPAN
        /\[.*?\]\s*([가-힣a-zA-Z\s]+)\s*데모/i,
        // 일반 DEMO 패턴
        /([가-힣a-zA-Z]+)\s*DEMO/i,
      ];
      for (const pattern of patterns) {
        const match = path.match(pattern);
        if (match) return match[1].trim();
      }
      return '';
    };

    // 폴더 경로에서 업로드 날짜 추출 (새로운 함수)
    const extractDateFromPath = (path) => {
      // 패턴 1: (2026.01.28) 또는 (2026-01-28) 형식
      const parenDateMatch = path.match(/\((\d{4})[.\-](\d{2})[.\-](\d{2})\)/);
      if (parenDateMatch) {
        return `${parenDateMatch[1]}-${parenDateMatch[2]}-${parenDateMatch[3]}`;
      }

      // 패턴 2: 26.01.27 형식 (YY.MM.DD)
      const shortDateMatch = path.match(/(\d{2})[.\-](\d{2})[.\-](\d{2})/);
      if (shortDateMatch) {
        const year = parseInt(shortDateMatch[1]) < 50 ? `20${shortDateMatch[1]}` : `19${shortDateMatch[1]}`;
        return `${year}-${shortDateMatch[2]}-${shortDateMatch[3]}`;
      }

      // 패턴 3: 2026-01-28 또는 2026.01.28 형식
      const fullDateMatch = path.match(/(\d{4})[.\-](\d{2})[.\-](\d{2})/);
      if (fullDateMatch) {
        return `${fullDateMatch[1]}-${fullDateMatch[2]}-${fullDateMatch[3]}`;
      }

      return null;
    };

    // 폴더 경로에서 이메일 추출 (순수 이메일만, _ 앞의 아티스트명 제거)
    const extractEmailFromPath = (path) => {
      // 이메일 패턴 매칭 (@ 기호를 기준으로)
      const emailMatch = path.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
      if (emailMatch) {
        return cleanEmailAddress(emailMatch[1]);
      }
      if (path.includes('성규호 작가님') || path.includes('대표님')) {
        return '대표님 전달 DEMO';
      }
      return '';
    };

    // 이메일 주소 정제 함수 - '_' 이후 부분만 추출
    const cleanEmailAddress = (rawEmail) => {
      if (!rawEmail) return '';

      // _ 로 시작하면 제거 (예: _daslkfj@hanmail.net → daslkfj@hanmail.net)
      let email = rawEmail.startsWith('_') ? rawEmail.substring(1) : rawEmail;

      // @ 앞부분에서 마지막 '_' 이후가 실제 이메일 주소
      const atIndex = email.indexOf('@');
      if (atIndex > 0) {
        const localPart = email.substring(0, atIndex);
        const domain = email.substring(atIndex);

        // 로컬파트에 _가 있으면 마지막 _ 이후만 사용
        const lastUnderscoreIndex = localPart.lastIndexOf('_');
        if (lastUnderscoreIndex >= 0) {
          const afterUnderscore = localPart.substring(lastUnderscoreIndex + 1);
          // _ 이후에 유효한 문자가 있으면 그것만 사용
          if (afterUnderscore.length > 0) {
            email = afterUnderscore + domain;
          }
        }
      }

      return email;
    };

    // 폴더 경로에서 저작자 힌트 추출
    const extractComposerHintFromPath = (path) => {
      const folderMatch = path.match(/([가-힣]+)_[가-힣]+\s*Demo/i);
      if (folderMatch) return folderMatch[1];
      const suffixMatch = path.match(/Demo_([가-힣]+)/i);
      if (suffixMatch) return suffixMatch[1];
      return '';
    };

    // 날짜 포맷
    const formatDate = (date) => {
      if (!date) return new Date().toISOString().split('T')[0];
      const d = new Date(date);
      return d.toISOString().split('T')[0];
    };

    // 대괄호에서 저작자들 추출 [A][B][C] → "A, B, C"
    const extractComposersFromBrackets = (text) => {
      const matches = text.match(/\[([^\]]+)\]/g);
      if (!matches) return '';
      const composers = matches.map(m => m.replace(/[\[\]]/g, '').trim());
      return composers.join(', ');
    };

    // ========== 핵심 파싱 함수 (강력한 패턴 인식) ==========
    const parseFileName = (filename, folderPath = '') => {
      const nameWithoutExt = filename.replace(/\.(mp3|wav|m4a|flac|aiff)$/i, '');
      let songName = '';
      let composer = '';
      let opName = '';
      let genre = '';
      let bpm = '';

      // 파일명에서 모든 이메일 추출 및 정제
      const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/gi;
      const allEmails = nameWithoutExt.match(emailRegex) || [];
      const rawEmail = allEmails[0] || extractEmailFromPath(folderPath);
      const email = cleanEmailAddress(rawEmail); // 이메일 정제

      const composerHint = extractComposerHintFromPath(folderPath);
      const folderOP = extractOPFromFolderPath(folderPath);

      // ========== 우선 패턴: 작곡가,작곡가 [곡명] 형식 ==========
      // 예: KRXB,YEON [Heart reaction] DEMO_jty9142@gmail.com.mp3
      const composersBracketPattern = /^([A-Z]+(?:,[A-Z]+)*)\s*\[([^\]]+)\]/i;
      const composersBracketMatch = nameWithoutExt.match(composersBracketPattern);
      if (composersBracketMatch) {
        composer = composersBracketMatch[1].replace(/,/g, ', ').trim();
        songName = composersBracketMatch[2].trim();
        opName = getOPFromEmail(email) || getOPFromComposer(composer) || folderOP || '';
        return { songName, composer, opName, email, genre, bpm };
      }

      // 대괄호에서 저작자 추출 (기존 로직)
      const bracketComposers = extractComposersFromBrackets(nameWithoutExt);

      // 파일명에서 이메일과 대괄호 제거한 버전
      let cleanName = nameWithoutExt
        .replace(emailRegex, '')  // 이메일 제거
        .replace(/\[([^\]]+)\]/g, '')  // 대괄호 제거
        .replace(/_+/g, '_')  // 연속 언더스코어 정리
        .replace(/^_|_$/g, '')  // 앞뒤 언더스코어 제거
        .trim();

      // ★ 강력한 패턴 인식: 작곡가_곡명_BPM_장르 형식
      // 예: 강동화_DRIVE OFF_ BPM104_POP_R&B
      const parts = cleanName.split('_').map(p => p.trim()).filter(p => p);

      if (parts.length >= 2) {
        let composerCandidate = '';
        let songNameCandidate = '';
        let idx = 0;

        // 첫 번째 파트 분석
        const firstPart = parts[0];

        // 첫 번째가 작곡가인지 판단
        const isFirstPartComposer =
          KNOWN_COMPOSERS.has(firstPart) ||  // 알려진 작곡가
          /^[가-힣]{2,4}$/.test(firstPart) ||  // 한글 2-4자 (한국 작곡가명)
          /^[A-Z][a-z]+(\s[A-Z][a-z]+)*$/.test(firstPart);  // 영문 이름 형식

        if (isFirstPartComposer && parts.length >= 2) {
          // 패턴: 작곡가_곡명_나머지
          composerCandidate = firstPart;
          songNameCandidate = parts[1];
          idx = 2;
        } else {
          // 패턴: 곡명_나머지 (작곡가 없음)
          songNameCandidate = firstPart;
          idx = 1;
        }

        songName = songNameCandidate;
        if (composerCandidate) {
          composer = composerCandidate;
        }

        // 나머지 부분에서 BPM, 장르 추출
        const genreParts = [];

        for (let i = idx; i < parts.length; i++) {
          const part = parts[i];

          // DEMO 스킵
          if (/^DEMO[#]?$/i.test(part)) continue;

          // BPM 패턴 (BPM104, 104, Tempo104 등)
          const bpmMatch = part.match(/(?:BPM|Tempo)?(\d+)/i);
          if (bpmMatch && !bpm) {
            bpm = bpmMatch[1];
            continue;
          }

          // 장르 키워드
          if (isGenreKeyword(part)) {
            genreParts.push(part);
            continue;
          }

          // 지분율 포함 저작자 정보
          if (/\d+(\.\d+)?%/.test(part) && /[A-Za-z가-힣]/.test(part)) {
            composer = composer ? `${composer}, ${part}` : part;
            continue;
          }

          // 퍼블리셔 키워드
          if (/Peermusic|Outdustry|Publishing/i.test(part)) {
            composer = composer ? `${composer} ${part}` : part;
            continue;
          }

          // 그 외 작곡가로 추가 (BPM이나 숫자가 아닌 경우)
          if (!/^\d+$/.test(part) && !/@/.test(part)) {
            if (!composer) {
              composer = part;
            } else if (!KNOWN_COMPOSERS.has(composer)) {
              // 이미 작곡가가 있지만 알려지지 않은 경우, 추가 정보로 결합
              composer = `${composer}, ${part}`;
            }
          }
        }

        // 장르 조합
        if (genreParts.length > 0) {
          genre = genreParts.join(' / ');
        }
      } else if (parts.length === 1) {
        // 단일 파트는 곡명
        songName = parts[0];
      }

      // 대괄호 저작자 우선 사용
      if (bracketComposers) {
        composer = bracketComposers;
      }

      // OP명 결정
      opName = getOPFromEmail(email) || getOPFromComposer(composer) || folderOP || '';

      // 이메일에서 기본 저작자 매핑 (저작자가 비어있을 때)
      if (!composer && email && EMAIL_TO_COMPOSER[email]) {
        composer = EMAIL_TO_COMPOSER[email];
      }

      // 결과가 있으면 반환
      if (songName) {
        return { songName, composer, opName, email, genre, bpm };
      }

      // ========== 기존 특수 패턴들 (fallback) ==========

      // 패턴 1: _Pitched by MC로 끝나는 파일 (이미 처리된 파일)
      const pitchedMatch = nameWithoutExt.match(/^(.+?)_([^_]+)_Pitched by MC$/i);
      if (pitchedMatch) {
        songName = pitchedMatch[1].trim();
        opName = pitchedMatch[2].trim();
        composer = composerHint || opName;
        return { songName, composer, opName, email };
      }

      // 패턴 2: [작가명]_곡명_BPM숫자_장르 형식
      const bracketMatch = nameWithoutExt.match(/^\[([^\]]+)\]_(.+?)(?:_BPM\d+)?(?:_[a-zA-Z]+)?$/i);
      if (bracketMatch) {
        composer = bracketMatch[1].trim();
        songName = bracketMatch[2].trim();
        opName = getOPFromComposer(composer) || composer;
        return { songName, composer, opName, email };
      }

      // 패턴 3: 곡명(작가+작가) (BPM,장르) 형식 (ES2 스타일)
      const es2Match = nameWithoutExt.match(/^(.+?)\(([^)]+)\)\s*\([^)]*\)$/);
      if (es2Match) {
        songName = es2Match[1].trim();
        composer = es2Match[2].replace(/\+/g, ', ').trim();
        opName = getOPFromComposer(composer) || 'ES2';
        return { songName, composer, opName, email };
      }

      // 패턴 4: Weeky1- 곡명 [Tempo숫자] 장르 형식 (JGH 스타일)
      const weekyMatch = nameWithoutExt.match(/^Weeky1-\s*(.+?)\s*\[Tempo\d+\]/i);
      if (weekyMatch) {
        songName = weekyMatch[1].trim();
        composer = '전근화(Weeky1), BT';
        opName = 'JGH';
        return { songName, composer, opName, email };
      }

      // 패턴 5: 작가1,작가2_곡명_BPM숫자 형식 (OneTop 스타일)
      const commaMatch = nameWithoutExt.match(/^([^_]+[,&][^_]+)_(.+?)(?:_BPM\d+)?$/i);
      if (commaMatch) {
        composer = commaMatch[1].replace(/&/g, ', ').trim();
        songName = commaMatch[2].trim();
        opName = getOPFromComposer(composer) || getEnglishInitials(composer.split(/[,&]/)[0].trim());
        return { songName, composer, opName, email };
      }

      // 패턴 6: 유정훈_박민우_나무_B-Ab_69 형식 (YJH 스타일)
      const yjhMatch = nameWithoutExt.match(/^([가-힣]+)_([가-힣]+)_(.+?)_[A-G][#b]?[-_][A-Za-z]+_\d+$/i);
      if (yjhMatch) {
        composer = `${yjhMatch[1]}, ${yjhMatch[2]}`;
        songName = yjhMatch[3].trim();
        opName = getOPFromComposer(yjhMatch[1]) || 'YJH';
        return { songName, composer, opName, email };
      }

      // 패턴 7: 01 - Adam Argyle, ... Looks Different 형식 (EavesMusic)
      const eavesMatch = nameWithoutExt.match(/^\d+\s*-\s*(.+?)\s*-\s*(.+)$/);
      if (eavesMatch) {
        composer = eavesMatch[1].replace(/\.\.\./g, '').trim();
        songName = eavesMatch[2].trim();
        opName = 'EavesMusic';
        return { songName, composer, opName, email };
      }

      // 패턴 8: 곡명 - 작가명 형식 (여러 스타일)
      const dashComposerMatch = nameWithoutExt.match(/^(.+?)\s*[-–]\s*([A-Za-z\s,]+)$/);
      if (dashComposerMatch) {
        const possibleComposer = dashComposerMatch[2].trim();
        const matchedOP = getOPFromComposer(possibleComposer.toLowerCase());
        if (matchedOP || /^[A-Z][a-z]+(\s+[A-Z][a-z]+)*$/.test(possibleComposer)) {
          songName = dashComposerMatch[1].trim();
          composer = possibleComposer;
          opName = matchedOP || getOPFromEmail(email) || folderOP || '';
          return { songName, composer, opName, email };
        }
      }

      // 패턴 9: 오영빈_날 떠나지마_74_팝 발라드 형식
      const oyoMatch = nameWithoutExt.match(/^([가-힣]+)_(.+?)_\d+_/);
      if (oyoMatch) {
        composer = oyoMatch[1].trim();
        songName = oyoMatch[2].trim();
        opName = getOPFromComposer(composer) || getKoreanInitials(composer);
        return { songName, composer, opName, email };
      }

      // 패턴 10: 곡명 DEMO_OP명 또는 곡명_OP명 형식 (Solcire 스타일)
      // 예: "POP BEAT DEMO_Solcire Music.mp3" → 곡명: "POP BEAT", OP: "Solcire"
      const demoOPMatch = nameWithoutExt.match(/^(.+?)\s*(?:DEMO[#]?)?_([A-Za-z\s.]+)$/i);
      if (demoOPMatch) {
        let rawSongName = demoOPMatch[1].trim();
        const rawOP = demoOPMatch[2].trim();
        // 곡명에서 DEMO 제거
        rawSongName = rawSongName.replace(/\s*DEMO[#]?\s*$/i, '').trim();
        songName = rawSongName;
        const matchedOP = getOPFromComposer(rawOP.toLowerCase());
        opName = matchedOP || rawOP;
        composer = composerHint || '';
        return { songName, composer, opName, email };
      }

      // 패턴 11: 곡명_T숫자_Key_가이드보컬 형식
      // 예: "Saturn_T94_Gkey_가이드보컬.mp3" → 곡명: "Saturn"
      const tempoKeyMatch = nameWithoutExt.match(/^(.+?)_T\d+_[A-G][#b]?(?:key|m)?/i);
      if (tempoKeyMatch) {
        songName = tempoKeyMatch[1].trim();
        opName = getOPFromEmail(email) || folderOP || '';
        composer = composerHint || '';
        return { songName, composer, opName, email };
      }

      // 패턴 12: 곡명_장르_숫자_DEMO 형식
      // 예: "있잖아 (AHMOLLA)_HIP&GEN-Z_192_DEMO.mp3" → 곡명: "있잖아 (AHMOLLA)" 또는 "있잖아"
      const genreNumDemoMatch = nameWithoutExt.match(/^(.+?)_[A-Za-z&-]+_\d+_DEMO$/i);
      if (genreNumDemoMatch) {
        songName = genreNumDemoMatch[1].trim();
        opName = getOPFromEmail(email) || folderOP || '';
        composer = composerHint || '';
        return { songName, composer, opName, email };
      }

      // 패턴 13: 곡명#_작가명 형식
      // 예: "눈부신 사랑 DEMO#_박수석.mp3" → 곡명: "눈부신 사랑"
      const hashDemoMatch = nameWithoutExt.match(/^(.+?)\s*DEMO[#]?_([가-힣A-Za-z\s]+)$/i);
      if (hashDemoMatch) {
        songName = hashDemoMatch[1].trim();
        composer = hashDemoMatch[2].trim();
        opName = getOPFromComposer(composer) || getOPFromEmail(email) || folderOP || '';
        return { songName, composer, opName, email };
      }

      // 패턴 14: 단순 곡명만 있는 경우 (영문 대문자)
      if (/^[A-Z\s'´!?]+$/i.test(nameWithoutExt) && nameWithoutExt.length > 2) {
        songName = nameWithoutExt.trim();
        opName = getOPFromEmail(email) || folderOP || '';
        composer = composerHint || '';
        return { songName, composer, opName, email };
      }

      // 패턴 15: 아티스트 Demo가 포함된 파일
      const artistDemoMatch = nameWithoutExt.match(/^(.+?)\s*\(([가-힣A-Za-z]+)\s*Demo\)\s*$/i);
      if (artistDemoMatch) {
        songName = artistDemoMatch[1].trim();
        composer = composerHint || '';
        opName = getOPFromComposer(composerHint) || getOPFromEmail(email) || folderOP || '';
        return { songName, composer, opName, email };
      }

      // 기본: 파일명 정제
      songName = nameWithoutExt
        .replace(/_BPM\d+/gi, '')
        .replace(/_Tempo\d+/gi, '')
        .replace(/_T\d+/gi, '')
        .replace(/\s*DEMO[#]?\s*/gi, ' ')
        .replace(/\s*\[.*?\]\s*/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();

      // 마지막 _ 이후가 OP명일 가능성 체크
      const lastUnderscoreIdx = songName.lastIndexOf('_');
      if (lastUnderscoreIdx > 0) {
        const possibleOP = songName.substring(lastUnderscoreIdx + 1).trim();
        const matchedOP = getOPFromComposer(possibleOP.toLowerCase());
        if (matchedOP || (possibleOP.length <= 15 && /^[A-Za-z\s.]+$/.test(possibleOP))) {
          songName = songName.substring(0, lastUnderscoreIdx).trim();
          opName = matchedOP || possibleOP;
        }
      }

      if (!opName) {
        opName = getOPFromEmail(email) || folderOP || '';
      }
      composer = composerHint || '';

      return { songName, composer, opName, email };
    };

    // 폴더 경로에서 OP명 추출 (새로운 함수)
    const extractOPFromFolderPath = (path) => {
      // [쏠시레뮤직], [SMOB] 등 대괄호 안의 OP명 추출
      const bracketOPMatch = path.match(/\[([가-힣A-Za-z]+(?:뮤직|Music)?)\]/i);
      if (bracketOPMatch) {
        const opHint = bracketOPMatch[1].trim();
        // 매핑 테이블에서 찾기
        const matchedOP = getOPFromComposer(opHint.toLowerCase().replace(/뮤직|music/gi, ''));
        if (matchedOP) return matchedOP;
        // 그대로 반환
        return opHint.replace(/뮤직$/i, '').replace(/Music$/i, '').trim();
      }
      return '';
    };

    // ========== 완전 독립 입력 컴포넌트 (blur 비동기 처리로 떨림 방지) ==========
    const StableInput = React.memo(({ initialValue, onValueChange, placeholder, className, type = 'text', readOnly = false }) => {
      const [localValue, setLocalValue] = useState(initialValue || '');
      const initialRef = useRef(initialValue);
      const blurTimeoutRef = useRef(null);

      const handleChange = (e) => {
        setLocalValue(e.target.value);
      };

      const handleBlur = () => {
        // blur 처리를 비동기로 지연 - 클릭 이벤트가 먼저 처리되도록 함
        if (blurTimeoutRef.current) {
          clearTimeout(blurTimeoutRef.current);
        }

        blurTimeoutRef.current = setTimeout(() => {
          if (localValue !== initialRef.current && onValueChange) {
            onValueChange(localValue);
            initialRef.current = localValue;
          }
        }, 0);
      };

      // 컴포넌트 언마운트 시 타이머 정리
      useEffect(() => {
        return () => {
          if (blurTimeoutRef.current) {
            clearTimeout(blurTimeoutRef.current);
          }
        };
      }, []);

      return (
        <input
          type={type}
          value={localValue}
          onChange={handleChange}
          onBlur={handleBlur}
          className={className}
          placeholder={placeholder}
          readOnly={readOnly}
        />
      );
    });

    // 완전 독립 Textarea 컴포넌트 (blur 비동기 처리)
    const StableTextarea = React.memo(({ initialValue, onValueChange, placeholder, className, rows = 2 }) => {
      const [localValue, setLocalValue] = useState(initialValue || '');
      const initialRef = useRef(initialValue);
      const blurTimeoutRef = useRef(null);

      const handleChange = (e) => {
        setLocalValue(e.target.value);
      };

      const handleBlur = () => {
        if (blurTimeoutRef.current) {
          clearTimeout(blurTimeoutRef.current);
        }

        blurTimeoutRef.current = setTimeout(() => {
          if (localValue !== initialRef.current && onValueChange) {
            onValueChange(localValue);
            initialRef.current = localValue;
          }
        }, 0);
      };

      useEffect(() => {
        return () => {
          if (blurTimeoutRef.current) {
            clearTimeout(blurTimeoutRef.current);
          }
        };
      }, []);

      return (
        <textarea
          value={localValue}
          onChange={handleChange}
          onBlur={handleBlur}
          className={className}
          placeholder={placeholder}
          rows={rows}
        />
      );
    });

    // 크레딧 입력 컴포넌트 (DemoReviewSystem 외부에 정의하여 리렌더링 방지)
    const CreditTextArea = React.memo(({ textRef }) => {
      const localRef = useRef(null);
      const [localValue, setLocalValue] = useState('');

      const handleChange = (e) => {
        const newValue = e.target.value;
        setLocalValue(newValue);
        textRef.current = newValue;
      };

      return (
        <textarea
          ref={localRef}
          value={localValue}
          onChange={handleChange}
          className="w-full h-64 bg-black/50 text-gray-300 px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500 resize-none mb-4 font-mono text-sm"
          placeholder={`예시:

거기서 거기
작곡 전근화
작사 전근화
편곡 정진욱

Hamburger
writers CC, Ron, JJ

너와의 밤
작곡 전근화(Weeky1), BT
작사 전근화`}
        />
      );
    });

    // 크레딧 텍스트 파싱 (확장됨 - Track Title, WRITERS DETAILS 지원)
    const parseCreditText = (creditText) => {
      const credits = {};
      const lines = creditText.split('\n').map(l => l.trim()).filter(l => l);

      let currentSong = null;
      let currentCredits = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // 섹션 헤더 스킵 (타이틀, 수록성, Metadata, Link, WRITERS DETAILS 등)
        if (/^(타이틀|수록성|수록곡|\(타이틀\)|\(수록성\)|Metadata|Link:|WRITERS DETAILS:|##?\s)/i.test(line)) {
          continue;
        }

        // 패턴 0: Track Title: 곡명
        const trackTitleMatch = line.match(/^Track Title:\s*(.+)$/i);
        if (trackTitleMatch) {
          // 이전 곡 저장
          if (currentSong && currentCredits.length > 0) {
            credits[currentSong.toLowerCase()] = currentCredits.join(', ');
          }
          currentSong = trackTitleMatch[1].trim();
          currentCredits = [];
          continue;
        }

        // 패턴 0-1: WRITERS DETAILS 섹션 내 작가 정보
        // 예: [33.33%]  Scott Russell Stoddart (CAE: 679119701)
        const writerDetailsMatch = line.match(/^\[[\d.]+%\]\s+([^(]+)(?:\(CAE:[^)]*\))?\s*(.*)$/);
        if (writerDetailsMatch && currentSong) {
          const writerName = writerDetailsMatch[1].trim();
          // CAE 번호와 퍼블리셔 정보 제거하고 작가명만 추출
          if (writerName && !currentCredits.includes(writerName)) {
            currentCredits.push(writerName);
          }
          continue;
        }

        // 패턴 1: 번호. 곡명 - 작가1, 작가2 형식 (마크다운 리스트)
        // 예: "1. AEROBATIC PLUM - Chris Alice, 영원희, Sisyphus"
        const numberedMatch = line.match(/^(\d+)\.\s*(.+?)\s*[-–]\s*(.+)$/);
        if (numberedMatch) {
          const songName = numberedMatch[2].trim();
          const composer = numberedMatch[3].trim();
          credits[songName.toLowerCase()] = composer;
          continue;
        }

        // 패턴 2: "곡명.mp3 | Powered by Box" 형식 (Box에서 복사한 형식)
        const boxMatch = line.match(/^(.+?)\.(mp3|wav|m4a|flac|aiff)\s*\|\s*Powered by Box$/i);
        if (boxMatch) {
          // 이전 곡 저장
          if (currentSong && currentCredits.length > 0) {
            credits[currentSong.toLowerCase()] = currentCredits.join(', ');
          }
          currentSong = boxMatch[1].trim();
          currentCredits = [];
          continue;
        }

        // 패턴 3: 테이블 형식 (| # | 곡명 | 저작자 |)
        const tableMatch = line.match(/^\|\s*\d+\s*\|\s*(.+?)\s*\|\s*(.+?)\s*\|$/);
        if (tableMatch) {
          const songName = tableMatch[1].trim();
          const composer = tableMatch[2].trim();
          if (songName && composer && songName !== '곡명' && composer !== '저작자') {
            credits[songName.toLowerCase()] = composer;
          }
          continue;
        }

        // 패턴 4: "Composer\tJay Made (GL Music) / Camilia (Lifted House)" 형식
        // 탭으로 구분된 Composer 필드
        const composerTabMatch = line.match(/^Composer\s+(.+)$/i);
        if (composerTabMatch && currentSong) {
          const composerInfo = composerTabMatch[1].trim();
          currentCredits.push(composerInfo);
          continue;
        }

        // 패턴 5: 작곡/작사/편곡/writers로 시작하는 크레딧 라인
        const isKoreanCredit = /^(작곡|작사|편곡|writers?|composer|lyricist|arranger)\s*[-:：]?\s*/i.test(line);

        // 패턴 6: 퍼센트(%)가 포함된 크레딧 라인 (Jose Manuel 50% 형식)
        const hasPercentage = /%/.test(line);

        // 패턴 7: PEERMUSIC이 포함된 라인 (크레딧 정보)
        const hasPeermusic = /PEERMUSIC/i.test(line);

        if (currentSong && (isKoreanCredit || hasPercentage || hasPeermusic)) {
          // 크레딧 정보 추출
          let creditInfo = line
            .replace(/^(작곡|작사|편곡|writers?|composer|lyricist|arranger)\s*[-:：]?\s*/i, '')
            .replace(/\s*PEERMUSIC\s*$/i, '') // 끝의 PEERMUSIC 제거
            .replace(/\s*\d+(\.\d+)?%/g, '') // 퍼센트 정보 제거
            .trim();
          if (creditInfo) {
            currentCredits.push(creditInfo);
          }
        } else if (!isKoreanCredit && !hasPercentage && !hasPeermusic && line.length > 0 && !/^Composer/i.test(line)) {
          // 새로운 곡명으로 인식 (기존 형식)
          // 이전 곡 저장
          if (currentSong && currentCredits.length > 0) {
            credits[currentSong.toLowerCase()] = currentCredits.join(', ');
          }
          currentSong = line;
          currentCredits = [];
        }
      }

      // 마지막 곡 저장
      if (currentSong && currentCredits.length > 0) {
        credits[currentSong.toLowerCase()] = currentCredits.join(', ');
      }

      return credits;
    };

    const getScoreColor = (score) => {
      const colors = { '5.0': 'from-emerald-500 to-emerald-600', '4.5': 'from-blue-500 to-blue-600', '4.0': 'from-cyan-500 to-cyan-600', '3.5': 'from-purple-500 to-purple-600', '3.0': 'from-amber-500 to-amber-600', '2.5': 'from-orange-500 to-orange-600', '2.0': 'from-red-500 to-red-600', '1.5': 'from-gray-500 to-gray-600', '1.0': 'from-gray-400 to-gray-500' };
      return colors[score] || 'from-gray-300 to-gray-400';
    };

    const StarRating = React.memo(({ value, onChange }) => {
      const [hover, setHover] = useState(0);
      return (
        <div className="flex gap-1 items-center">
          {[1,2,3,4,5].map(i => (
            <span key={i} className={`star ${(hover || parseFloat(value) || 0) >= i ? 'filled' : 'empty'}`}
              onMouseEnter={() => setHover(i)} onMouseLeave={() => setHover(0)}
              onClick={() => onChange(i + '.0')}>{(hover || parseFloat(value) || 0) >= i ? '★' : '☆'}</span>
          ))}
          {value && <span className="ml-2 text-lg font-bold text-white">{value}</span>}
        </div>
      );
    });

    function DemoReviewSystem() {
      const [songs, setSongs] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [reviews, setReviews] = useState({});
      const [view, setView] = useState('upload'); // upload, credit, review, list
      const [artistName, setArtistName] = useState('');
      const [searchTerm, setSearchTerm] = useState('');
      const [filterStatus, setFilterStatus] = useState('all');
      const [creditText, setCreditText] = useState('');
      const [pendingSongs, setPendingSongs] = useState([]);
      const [presetVersion, setPresetVersion] = useState(0); // 프리셋 선택 시 증가하여 피드백 필드 재생성

      const folderInputRef = useRef(null);
      const creditTextRef = useRef('');

      const STORAGE_KEY = 'peermusic_demo_reviews_v6';
      const SONGS_KEY = 'peermusic_demo_songs_v6';
      const META_KEY = 'peermusic_demo_meta_v6';

      useEffect(() => {
        const savedReviews = localStorage.getItem(STORAGE_KEY);
        const savedSongs = localStorage.getItem(SONGS_KEY);
        const savedMeta = localStorage.getItem(META_KEY);
        if (savedReviews) try { setReviews(JSON.parse(savedReviews)); } catch (e) {}
        if (savedSongs) try { const s = JSON.parse(savedSongs); setSongs(s); if (s.length > 0) setView('review'); } catch (e) {}
        if (savedMeta) try { const m = JSON.parse(savedMeta); setArtistName(m.artistName || ''); } catch (e) {}
      }, []);

      useEffect(() => { if (Object.keys(reviews).length > 0) localStorage.setItem(STORAGE_KEY, JSON.stringify(reviews)); }, [reviews]);
      useEffect(() => { if (songs.length > 0) localStorage.setItem(SONGS_KEY, JSON.stringify(songs)); }, [songs]);
      useEffect(() => { localStorage.setItem(META_KEY, JSON.stringify({ artistName })); }, [artistName]);

      const currentSong = songs[currentIndex] || null;
      const currentReview = currentSong ? (reviews[currentSong.id] || {
        피드백: '',
        장르: currentSong.장르 || '',  // 자동 추출된 장르 사용
        점수: '',
        OP명: currentSong.OP명,
        저작자: currentSong.저작자
      }) : null;
      const reviewedCount = useMemo(() => songs.filter(s => reviews[s.id]?.점수).length, [songs, reviews]);
      const progress = songs.length > 0 ? ((reviewedCount / songs.length) * 100).toFixed(0) : 0;

      const filteredSongs = useMemo(() => {
        return songs.filter(song => {
          const review = reviews[song.id] || {};
          const matchesSearch = song.곡명.toLowerCase().includes(searchTerm.toLowerCase()) ||
            song.저작자.toLowerCase().includes(searchTerm.toLowerCase()) ||
            (review.OP명 || song.OP명 || '').toLowerCase().includes(searchTerm.toLowerCase());
          if (filterStatus === 'reviewed') return matchesSearch && review?.점수;
          if (filterStatus === 'pending') return matchesSearch && !review?.점수;
          if (filterStatus === 'recommended') return matchesSearch && parseFloat(review?.점수 || 0) >= 4.0;
          return matchesSearch;
        });
      }, [songs, reviews, searchTerm, filterStatus]);

      // 폴더 업로드 처리
      const handleFolderUpload = async (files) => {
        const audioFiles = Array.from(files).filter(f => {
          const isAudio = /\.(mp3|wav|m4a|flac|aiff)$/i.test(f.name);
          const isMacOS = f.webkitRelativePath?.includes('__MACOSX') || f.name.startsWith('._');
          return isAudio && !isMacOS;
        });

        if (audioFiles.length === 0) {
          alert('음원 파일이 없습니다.\n\n지원 형식: MP3, WAV, M4A, FLAC, AIFF');
          return;
        }

        const firstPath = audioFiles[0].webkitRelativePath || '';
        const detectedArtist = extractArtistFromPath(firstPath);
        if (detectedArtist && !artistName) setArtistName(detectedArtist);

        const newSongs = audioFiles.map((file, idx) => {
          const path = file.webkitRelativePath || file.name;
          const parsed = parseFileName(file.name, path);

          // 폴더 경로에서 날짜 추출 시도, 없으면 파일 수정일 사용
          const extractedDate = extractDateFromPath(path);
          const uploadDate = extractedDate || formatDate(file.lastModified);

          return {
            id: Date.now() + idx + Math.random(),
            곡명: parsed.songName,
            저작자: parsed.composer,
            OP명: parsed.opName,
            이메일: parsed.email,
            장르: parsed.genre || '',  // 자동 추출된 장르
            BPM: parsed.bpm || '',     // 자동 추출된 BPM
            원본파일명: file.name,
            원본경로: path,
            업로드날짜: uploadDate,
            추가일시: new Date().toISOString()
          };
        });

        // 크레딧 입력 화면으로 이동
        setPendingSongs(newSongs);
        setView('credit');
      };

      // 곡명 정규화 (특수문자 통일, 공백 정리)
      const normalizeSongName = (name) => {
        return name
          .toLowerCase()
          .replace(/[´`'']/g, "'")  // 다양한 어포스트로피 통일
          .replace(/[""]/g, '"')    // 따옴표 통일
          .replace(/\s+/g, ' ')     // 공백 정리
          .trim();
      };

      // 크레딧 적용 및 검토 시작
      const applyCreditsAndStart = () => {
        let updatedSongs = [...pendingSongs];
        const textToUse = creditTextRef.current || creditText;

        if (textToUse.trim()) {
          const credits = parseCreditText(textToUse);

          // 정규화된 키로 크레딧 맵 재생성
          const normalizedCredits = {};
          for (const [key, value] of Object.entries(credits)) {
            normalizedCredits[normalizeSongName(key)] = value;
          }

          updatedSongs = pendingSongs.map(song => {
            const songNameNormalized = normalizeSongName(song.곡명);
            const matchedCredit = normalizedCredits[songNameNormalized];

            if (matchedCredit) {
              return {
                ...song,
                저작자: matchedCredit
              };
            }
            return song;
          });
        }

        setSongs(prev => [...prev, ...updatedSongs]);
        setPendingSongs([]);
        setCreditText('');
        creditTextRef.current = '';
        setView('review');
        alert(`${updatedSongs.length}곡이 추가되었습니다.`);
      };

      // 크레딧 없이 진행
      const skipCredits = () => {
        setSongs(prev => [...prev, ...pendingSongs]);
        setPendingSongs([]);
        setCreditText('');
        creditTextRef.current = '';
        setView('review');
        alert(`${pendingSongs.length}곡이 추가되었습니다.`);
      };

      const handleUpdate = (field, value) => {
        if (!currentSong) return;
        setReviews(prev => ({ ...prev, [currentSong.id]: { ...currentReview, [field]: value } }));
      };

      const goNext = () => { if (currentIndex < songs.length - 1) setCurrentIndex(currentIndex + 1); };
      const goPrev = () => { if (currentIndex > 0) setCurrentIndex(currentIndex - 1); };
      const goToSong = (idx) => { setCurrentIndex(idx); setView('review'); };
      const deleteSong = (id) => {
        if (confirm('삭제하시겠습니까?')) {
          setSongs(prev => prev.filter(s => s.id !== id));
          setReviews(prev => { const n = { ...prev }; delete n[id]; return n; });
          if (currentIndex >= songs.length - 1) setCurrentIndex(Math.max(0, songs.length - 2));
        }
      };

      // CSV 다운로드
      const downloadCSV = () => {
        try {
          const allData = songs.map(song => {
            const review = reviews[song.id] || {};
            const opName = review.OP명 || song.OP명 || '';
            const composerInfo = review.저작자 || song.저작자 || '';

            return {
              '음원업로드날짜': song.업로드날짜 || new Date().toISOString().split('T')[0],
              '저작자 정보': composerInfo,
              '원본 데모 작품명': song.곡명,
              'PITCHING 데모': `${song.곡명}_${opName}_Pitched by MC`,
              'OP명 / 작가명': opName,
              'Genre': review.장르 || '',
              'Tag(Note)': review.피드백 || '',
              'Note(선호도)': review.점수 ? `${review.점수}/5` : '',
              '이메일 주소': review.이메일 || song.이메일 || '',
              '피칭 아티스트': artistName
            };
          });

          const convertToCSV = (data) => {
            if (data.length === 0) return '';
            const headers = Object.keys(data[0]);
            const csvRows = [headers.join(',')];
            for (const row of data) {
              const values = headers.map(h => {
                const v = String(row[h] || '');
                return (v.includes(',') || v.includes('"') || v.includes('\n')) ? `"${v.replace(/"/g, '""')}"` : v;
              });
              csvRows.push(values.join(','));
            }
            return csvRows.join('\n');
          };

          const BOM = '\uFEFF';
          const today = new Date().toISOString().split('T')[0].replace(/-/g, '.');

          const blob = new Blob([BOM + convertToCSV(allData)], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = `${artistName || 'DEMO'}_전체DEMO_${today}.csv`;
          link.click();

          const recommended = allData.filter((_, i) => parseFloat(reviews[songs[i].id]?.점수 || 0) >= 4.0);
          if (recommended.length > 0) {
            setTimeout(() => {
              const blob2 = new Blob([BOM + convertToCSV(recommended)], { type: 'text/csv;charset=utf-8;' });
              const link2 = document.createElement('a');
              link2.href = URL.createObjectURL(blob2);
              link2.download = `${artistName || 'DEMO'}_추천DEMO_${today}.csv`;
              link2.click();
            }, 500);
          }

          alert(`다운로드 완료\n전체: ${allData.length}곡 | 추천: ${recommended.length}곡`);
        } catch (error) { alert('다운로드 실패: ' + error.message); }
      };

      const resetAll = () => {
        if (confirm('모든 데이터를 초기화하시겠습니까?')) {
          setSongs([]); setReviews({}); setCurrentIndex(0); setView('upload'); setArtistName('');
          localStorage.removeItem(STORAGE_KEY); localStorage.removeItem(SONGS_KEY);
        }
      };

      // 업로드 화면
      const UploadView = () => (
        <div className="min-h-screen flex items-center justify-center p-6 fade-in">
          <div className="w-full max-w-2xl">
            <div className="text-center mb-12">
              <h1 className="text-5xl font-bold gradient-text mb-2">PEERMUSIC</h1>
              <p className="text-gray-500 text-lg">DEMO Review System</p>
            </div>

            <div
              className="upload-zone rounded-3xl p-16 text-center cursor-pointer mb-4"
              onClick={() => folderInputRef.current?.click()}
            >
              <div className="text-6xl mb-6 opacity-60">📂</div>
              <h2 className="text-2xl font-semibold text-white mb-3">
                클릭하여 폴더 선택
              </h2>
              <p className="text-gray-500">MP3, WAV, M4A, FLAC, AIFF</p>
              <input
                ref={folderInputRef}
                type="file"
                webkitdirectory=""
                directory=""
                multiple
                onChange={(e) => e.target.files && handleFolderUpload(e.target.files)}
                className="hidden"
              />
            </div>

            {songs.length > 0 && (
              <div className="glass rounded-2xl p-6 text-center mb-4">
                <p className="text-gray-400 mb-3">저장된 데이터: <span className="text-white font-bold">{songs.length}곡</span> ({reviewedCount}곡 완료)</p>
                <div className="flex gap-3 justify-center">
                  <button onClick={() => setView('review')} className="btn-primary px-8 py-3 rounded-xl text-white font-medium">
                    이어서 검토하기 →
                  </button>
                  <button onClick={resetAll} className="px-6 py-3 rounded-xl bg-red-500/20 text-red-400 hover:bg-red-500/30 font-medium border border-red-500/30">
                    🗑️ 초기화
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>
      );

      const CreditView = () => (
        <div className="min-h-screen flex items-center justify-center p-6 fade-in">
          <div className="w-full max-w-3xl">
            <div className="text-center mb-8">
              <h1 className="text-3xl font-bold text-white mb-2">크레딧 정보 입력</h1>
              <p className="text-gray-500">업로드된 {pendingSongs.length}곡의 추가 저작자 정보를 입력하세요</p>
            </div>

            {/* 업로드된 곡 목록 */}
            <div className="glass rounded-2xl p-4 mb-6 max-h-48 overflow-y-auto">
              <h3 className="text-sm font-medium text-gray-400 mb-3">업로드된 곡 목록</h3>
              <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                {pendingSongs.map((song, idx) => (
                  <div key={idx} className="credit-item px-3 py-2 rounded-lg text-sm">
                    <span className="text-white">{song.곡명}</span>
                    {song.저작자 && <span className="text-gray-500 text-xs block">{song.저작자}</span>}
                  </div>
                ))}
              </div>
            </div>

            {/* 크레딧 입력 */}
            <div className="glass rounded-2xl p-6 mb-6">
              <h3 className="text-white font-medium mb-3">📝 추가 크레딧 정보 (선택사항)</h3>
              <p className="text-gray-500 text-sm mb-4">
                곡명을 먼저 쓰고, 그 아래에 작곡/작사/편곡 또는 writers 정보를 입력하세요.
              </p>
              <CreditTextArea textRef={creditTextRef} />
            </div>

            {/* 버튼 */}
            <div className="flex gap-4">
              <button
                onClick={() => { setPendingSongs([]); setCreditText(''); creditTextRef.current = ''; setView('upload'); }}
                className="flex-1 btn-secondary py-4 rounded-xl text-gray-300 font-medium"
              >
                ← 취소
              </button>
              <button
                onClick={skipCredits}
                className="flex-1 btn-secondary py-4 rounded-xl text-gray-300 font-medium"
              >
                건너뛰기
              </button>
              <button
                onClick={applyCreditsAndStart}
                className="flex-1 btn-primary py-4 rounded-xl text-white font-medium"
              >
                적용 및 검토 시작 →
              </button>
            </div>
          </div>
        </div>
      );

      // 검토 화면
      const ReviewView = () => {
        if (!currentSong) return (
          <div className="min-h-screen flex items-center justify-center">
            <div className="text-center">
              <p className="text-xl text-gray-500 mb-4">검토할 곡이 없습니다</p>
              <button onClick={() => setView('upload')} className="btn-primary px-6 py-3 rounded-xl text-white">곡 추가</button>
            </div>
          </div>
        );

        return (
          <div className="max-w-5xl mx-auto p-4 md:p-6 fade-in">
            <div className="glass rounded-2xl p-4 mb-4">
              <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
                <div className="flex items-center gap-4">
                  <button onClick={() => setView('upload')} className="p-2 hover:bg-white/10 rounded-lg text-gray-400 hover:text-white">🏠</button>
                  <div>
                    <StableInput
                      key={`artist-${artistName ? 'set' : 'empty'}`}
                      initialValue={artistName}
                      onValueChange={(v) => setArtistName(v)}
                      className="text-xl font-bold text-white bg-transparent border-b border-transparent hover:border-gray-600 focus:border-indigo-500 outline-none"
                      placeholder="아티스트명 입력"
                    />
                    <p className="text-sm text-gray-500">{songs.length}곡</p>
                  </div>
                </div>
                <div className="flex items-center gap-3">
                  <button onClick={() => setView('list')} className="px-4 py-2 rounded-lg text-gray-400 hover:text-white hover:bg-white/10">📋 목록</button>
                  <button onClick={downloadCSV} className="btn-primary px-4 py-2 rounded-lg text-white font-medium">📥 CSV</button>
                </div>
              </div>
              <div className="mt-4">
                <div className="flex justify-between text-sm mb-1">
                  <span className="text-gray-500">진행률</span>
                  <span className="text-white font-medium">{reviewedCount} / {songs.length} ({progress}%)</span>
                </div>
                <div className="h-1.5 bg-gray-800 rounded-full overflow-hidden">
                  <div className="h-full bg-gradient-to-r from-indigo-500 to-purple-500 transition-all" style={{ width: `${progress}%` }} />
                </div>
              </div>
            </div>

            <div className="flex gap-4 items-stretch">
              <button onClick={goPrev} disabled={currentIndex === 0}
                className="nav-button hidden md:flex items-center justify-center w-14 glass rounded-2xl hover:bg-white/5 text-gray-400 hover:text-white"
                style={{ '--direction': '-5px' }}><span className="text-2xl">←</span></button>

              <div className="flex-1 glass rounded-3xl p-6 md:p-8">
                <div className="text-center mb-6">
                  <span className="inline-block px-3 py-1 bg-indigo-500/20 text-indigo-400 rounded-full text-sm font-medium mb-3">#{currentIndex + 1}</span>
                  <h2 className="text-3xl md:text-4xl font-bold text-white mb-1">{currentSong.곡명}</h2>
                  <p className="text-gray-500 text-sm">{currentSong.업로드날짜} | {currentSong.원본파일명}</p>
                </div>

                <div className="space-y-5">
                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-2">저작자 정보</label>
                    <StableInput
                      key={`composer-${currentSong?.id}`}
                      initialValue={currentReview.저작자 ?? currentSong.저작자 ?? ''}
                      onValueChange={(v) => handleUpdate('저작자', v)}
                      className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                      placeholder="예: OneTop, Zeenan"
                    />
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-400 mb-2">OP명 / 작가명</label>
                      <StableInput
                        key={`op-${currentSong?.id}`}
                        initialValue={currentReview.OP명 ?? currentSong.OP명 ?? ''}
                        onValueChange={(v) => handleUpdate('OP명', v)}
                        className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                        placeholder="예: OneTop, SJJ"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-400 mb-2">이메일</label>
                      <StableInput
                        key={`email-${currentSong?.id}`}
                        initialValue={currentReview.이메일 ?? currentSong.이메일 ?? ''}
                        onValueChange={(v) => handleUpdate('이메일', v)}
                        className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                        placeholder="이메일 주소"
                      />
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-3 text-center">선호도</label>
                    <div className="flex justify-center"><StarRating value={currentReview.점수} onChange={(v) => handleUpdate('점수', v)} /></div>
                    <div className="flex flex-wrap justify-center gap-2 mt-3">
                      {SCORES.map(s => (
                        <button key={s} onClick={() => handleUpdate('점수', s)}
                          className={`px-3 py-1 rounded-lg text-sm font-medium transition-all ${currentReview.점수 === s ? `bg-gradient-to-r ${getScoreColor(s)} text-white` : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>{s}</button>
                      ))}
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-2">Genre</label>
                    <StableInput
                      key={`genre-${currentSong?.id}`}
                      initialValue={currentReview.장르 || ''}
                      onValueChange={(v) => handleUpdate('장르', v)}
                      className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500"
                      placeholder="예: 발라드, 어쿠스틱 팝, POP BALLAD"
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-400 mb-2">Tag(Note)</label>
                    <select value={FEEDBACK_PRESETS.includes(currentReview.피드백) ? currentReview.피드백 : ''}
                      onChange={(e) => {
                        if (e.target.value) {
                          handleUpdate('피드백', e.target.value);
                          setPresetVersion(v => v + 1); // 피드백 필드 재생성
                        }
                      }}
                      className="w-full bg-black/50 text-white px-4 py-3 rounded-xl border border-gray-700 focus:border-indigo-500 mb-2">
                      <option value="">프리셋 선택</option>
                      {FEEDBACK_PRESETS.map(p => <option key={p} value={p}>{p}</option>)}
                    </select>
                    <StableTextarea
                      key={`feedback-${currentSong?.id}-${presetVersion}`}
                      initialValue={currentReview.피드백 || ''}
                      onValueChange={(v) => handleUpdate('피드백', v)}
                      className="w-full bg-black/30 text-white px-4 py-3 rounded-xl border border-gray-800 focus:border-indigo-500 resize-none"
                      rows={2}
                      placeholder="피드백 입력..."
                    />
                  </div>

                  {parseFloat(currentReview.점수 || 0) >= 4.0 && (
                    <div className="text-center">
                      <span className="inline-block px-4 py-2 bg-gradient-to-r from-rose-500 to-pink-500 text-white rounded-xl font-bold">❤️ 추천곡</span>
                    </div>
                  )}
                </div>

                <div className="flex md:hidden gap-3 mt-6">
                  <button onClick={goPrev} disabled={currentIndex === 0} className="flex-1 py-3 bg-gray-800 rounded-xl text-white disabled:opacity-40">← 이전</button>
                  <button onClick={goNext} disabled={currentIndex === songs.length - 1} className="flex-1 py-3 btn-primary rounded-xl text-white disabled:opacity-40">다음 →</button>
                </div>
              </div>

              <button onClick={goNext} disabled={currentIndex === songs.length - 1}
                className="nav-button hidden md:flex items-center justify-center w-14 glass rounded-2xl hover:bg-white/5 text-gray-400 hover:text-white"
                style={{ '--direction': '5px' }}><span className="text-2xl">→</span></button>
            </div>

            <div className="mt-4 glass rounded-xl p-4">
              <div className="flex items-center justify-between">
                <button onClick={() => setCurrentIndex(0)} className="text-sm text-gray-500 hover:text-white">⏮️</button>
                <div className="flex items-center gap-2">
                  <input type="number" min={1} max={songs.length} value={currentIndex + 1}
                    onChange={(e) => { const i = parseInt(e.target.value) - 1; if (i >= 0 && i < songs.length) setCurrentIndex(i); }}
                    className="w-14 bg-black/30 text-white text-center px-2 py-1 rounded-lg border border-gray-800" />
                  <span className="text-gray-500">/ {songs.length}</span>
                </div>
                <button onClick={() => setCurrentIndex(songs.length - 1)} className="text-sm text-gray-500 hover:text-white">⏭️</button>
              </div>
            </div>
          </div>
        );
      };

      // 목록 화면
      const ListView = () => (
        <div className="max-w-6xl mx-auto p-4 md:p-6 fade-in">
          <div className="glass rounded-2xl p-4 mb-4">
            <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
              <div className="flex items-center gap-4">
                <button onClick={() => setView('review')} className="text-gray-400 hover:text-white">← 검토</button>
                <h1 className="text-xl font-bold text-white">전체 목록 ({filteredSongs.length}곡)</h1>
              </div>
              <div className="flex gap-3">
                <button onClick={downloadCSV} className="btn-primary px-4 py-2 rounded-lg text-white font-medium">📥 CSV</button>
                <button onClick={resetAll} className="px-4 py-2 rounded-lg bg-red-500/20 text-red-400 hover:bg-red-500/30">🗑️ 초기화</button>
              </div>
            </div>
          </div>

          <div className="glass rounded-2xl p-4 mb-4">
            <div className="flex flex-col md:flex-row gap-4">
              <input
                type="text"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="flex-1 bg-black/30 text-white px-4 py-2 rounded-xl border border-gray-800 focus:border-indigo-500"
                placeholder="🔍 검색..."
              />
              <div className="flex gap-2">
                {[{ k: 'all', l: '전체' }, { k: 'reviewed', l: '완료' }, { k: 'pending', l: '미검토' }, { k: 'recommended', l: '추천' }].map(({ k, l }) => (
                  <button key={k} onClick={() => setFilterStatus(k)}
                    className={`px-4 py-2 rounded-xl font-medium ${filterStatus === k ? 'btn-primary text-white' : 'bg-gray-800 text-gray-400'}`}>{l}</button>
                ))}
              </div>
            </div>
          </div>

          <div className="glass rounded-2xl overflow-hidden">
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead className="bg-black/30">
                  <tr>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">#</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">곡명</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">저작자</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">OP명</th>
                    <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">날짜</th>
                    <th className="px-4 py-3 text-center text-sm font-medium text-gray-400">점수</th>
                    <th className="px-4 py-3 text-center text-sm font-medium text-gray-400"></th>
                  </tr>
                </thead>
                <tbody>
                  {filteredSongs.map(song => {
                    const review = reviews[song.id] || {};
                    const idx = songs.findIndex(s => s.id === song.id);
                    const isRec = parseFloat(review.점수 || 0) >= 4.0;
                    return (
                      <tr key={song.id} className="border-t border-gray-800 hover:bg-white/5">
                        <td className="px-4 py-3 text-sm text-gray-500">{idx + 1}</td>
                        <td className="px-4 py-3">
                          <button onClick={() => goToSong(idx)} className="text-indigo-400 hover:underline">{song.곡명}</button>
                          {isRec && <span className="ml-2">❤️</span>}
                        </td>
                        <td className="px-4 py-3 text-sm text-gray-400">{review.저작자 || song.저작자 || '-'}</td>
                        <td className="px-4 py-3 text-sm text-gray-400">{review.OP명 || song.OP명 || '-'}</td>
                        <td className="px-4 py-3 text-sm text-gray-500">{song.업로드날짜}</td>
                        <td className="px-4 py-3 text-center">
                          {review.점수 && <span className={`px-2 py-1 rounded-full text-xs font-bold text-white bg-gradient-to-r ${getScoreColor(review.점수)}`}>{review.점수}</span>}
                        </td>
                        <td className="px-4 py-3 text-center">
                          <button onClick={() => deleteSong(song.id)} className="text-red-400 hover:text-red-300">🗑️</button>
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>

          <div className="mt-4 grid grid-cols-4 gap-4">
            {[{ n: songs.length, l: '전체', c: 'text-indigo-400' }, { n: reviewedCount, l: '완료', c: 'text-emerald-400' },
              { n: songs.length - reviewedCount, l: '미검토', c: 'text-amber-400' },
              { n: songs.filter(s => parseFloat(reviews[s.id]?.점수 || 0) >= 4.0).length, l: '추천', c: 'text-rose-400' }
            ].map(({ n, l, c }) => (
              <div key={l} className="glass rounded-xl p-4 text-center">
                <div className={`text-2xl font-bold ${c}`}>{n}</div>
                <div className="text-sm text-gray-500">{l}</div>
              </div>
            ))}
          </div>
        </div>
      );

      return (
        <div className="min-h-screen">
          {view === 'upload' && UploadView()}
          {view === 'credit' && CreditView()}
          {view === 'review' && ReviewView()}
          {view === 'list' && ListView()}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<DemoReviewSystem />);
  </script>
</body>
</html>
